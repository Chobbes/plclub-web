<h1>merged.bib</h1><pre>
@comment{{This file has been generated by bib2bib 1.99}}
</pre>

<pre>
@comment{{Command line: bib2bib -s -r -oc plclub.keys -ob merged.bib -c bcp:"yes"|plclub:"yes" bcp.bib weirich.bib zdancewic.bib obastani.bib}}
</pre>

<pre>
@comment{{This file has been generated by bib2bib 1.99}}
</pre>

<pre>
@comment{{Command line: bib2bib -ob bcp.bib-tmp -c 'not($key = "poplmark") and not($key = "AITR-474")' bcp.bib}}
</pre>

<pre>
@comment{{This file has been generated by bib2bib 1.99}}
</pre>

<pre>
@comment{{Command line: bib2bib -ob zdancewic.bib-tmp -c 'not($key = "ABFF+05")' zdancewic.bib}}
</pre>

<pre>
@preamble{{\newcommand{\SortNoop}[1]{}}}
</pre>

<a name="Pierce:gridapple"></a><pre>
@misc{<a href="plclub.html#Pierce:gridapple">Pierce:gridapple</a>,
  author = {Benjamin C. Pierce},
  title = {{\sc Gridapple}: an implementation of the {\sc ESRI} {\sc
                  Grid} system for the {Apple-II}},
  year = {1981},
  note = {Marketed by Environmental Systems Research Institute,
                  Redlands, CA},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce82"></a><pre>
@inproceedings{<a href="plclub.html#Pierce82">Pierce82</a>,
  author = {B. C. Pierce},
  title = {A Microcomputer-Based Geographic Information System},
  booktitle = {Proceedings of the Seventh West Coast Computer Faire},
  month = mar,
  year = 1982,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Larrabee&82"></a><pre>
@misc{<a href="plclub.html#Larrabee&amp;82">Larrabee&82</a>,
  author = {T. Larrabee and K. McCall and C. Mitchell and B. C.
                  Pierce},
  title = {Gambit: {A} Video Game Programming Language},
  howpublished = {Project report for Stanford CS-242 (Programming Language
                  Design)},
  month = {December},
  year = 1982,
  note = {See also: Larrabee, T. and Mitchell, C. ``Gambit: A
                  Prototyping Approach to Video Game Design.'' IEEE Software,
                  Vol. 1 No. 4, Oct. 1984.},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce84"></a><pre>
@inproceedings{<a href="plclub.html#Pierce84">Pierce84</a>,
  author = {B. C. Pierce},
  title = {Gridapple: {A} Microcomputer-Based Geographic Information
                  System},
  booktitle = {Harvard Computer Graphics Week},
  month = jul,
  year = 1982,
  note = {Reprinted in Marble, D., et al, {\em Basic Readings in
                  Geographic Information Systems.} Williamsville, NY: SPAD
                  Systems, Ltd., 1984},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:arcinfo"></a><pre>
@misc{<a href="plclub.html#Pierce:arcinfo">Pierce:arcinfo</a>,
  author = {Benjamin C. Pierce},
  title = {{\sc Arc-Info} plotting and display subsystem},
  year = {1982},
  note = {Marketed by Environmental Systems Research Institute,
                  Redlands, CA, USA},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:artemis"></a><pre>
@misc{<a href="plclub.html#Pierce:artemis">Pierce:artemis</a>,
  author = {Benjamin C. Pierce},
  title = {{\sc Artemis}: a graphics editor for circuit diagrams},
  year = {1986},
  note = {Used internally at DEC Western Research Lab for the design
                  of the {\sc Titan} processor and power/packaging},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Habermann&88"></a><pre>
@techreport{<a href="plclub.html#Habermann&amp;88">Habermann&88</a>,
  author = {A. N. Habermann and Charles Krueger and Benjamin Pierce
                  and Barbara Staudt and John Wenn},
  title = {Programming with Views},
  institution = {Carnegie Mellon University, Computer Science Department},
  number = {CMU-CS-87-177},
  month = jan,
  year = {1988},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PIERCE89B"></a><pre>
@techreport{<a href="plclub.html#PIERCE89B">PIERCE89B</a>,
  key = {Pierce89b},
  author = {Benjamin Pierce},
  title = {A Decision Procedure for the Subtype Relation on
                  Intersection Types with Bounded Variables},
  institution = {School of Computer Science, Carnegie Mellon University},
  type = {Technical Report},
  number = {CMU-CS-89-169},
  month = sep,
  year = {1989},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PIERCE89C"></a><pre>
@unpublished{<a href="plclub.html#PIERCE89C">PIERCE89C</a>,
  key = {PIERCE89C},
  author = {Benjamin Pierce},
  title = {Bounded Quantification and Intersection Types},
  month = sep,
  year = {1989},
  note = {Thesis proposal (unpublished)},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PIERCE89"></a><pre>
@techreport{<a href="plclub.html#PIERCE89">PIERCE89</a>,
  key = {Pierce89},
  author = {Benjamin Pierce and Scott Dietzen and Spiro Michaylov},
  title = {Programming in Higher-order Typed Lambda-Calculi},
  institution = {Carnegie Mellon University},
  type = {Technical Report},
  number = {CMU-CS-89-111},
  month = mar,
  year = {1989},
  plclub = {Yes},
  bcp = {Yes},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/leap.pdf">http://www.cis.upenn.edu/~bcpierce/papers/leap.pdf</a>},
  errata = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/leap.errata">http://www.cis.upenn.edu/~bcpierce/papers/leap.errata</a>},
  keys = {typessurveys}
}
</pre>

<a name="HarperPierce90"></a><pre>
@techreport{<a href="plclub.html#HarperPierce90">HarperPierce90</a>,
  author = {Robert W. Harper and Benjamin C. Pierce},
  title = {Extensible Records Without Subsumption},
  institution = {School of Computer Science, Carnegie Mellon University},
  year = {1990},
  month = feb,
  type = {Technical Report},
  number = {CMU-CS-90-102},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce90b"></a><pre>
@unpublished{<a href="plclub.html#Pierce90b">Pierce90b</a>,
  author = {Benjamin C. Pierce},
  title = {Preliminary Investigation of a Calculus with Intersection
                  and Union Types},
  year = 1990,
  month = jun,
  note = {Unpublished manuscript},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="HarperPierce91"></a><pre>
@inproceedings{<a href="plclub.html#HarperPierce91">HarperPierce91</a>,
  author = {Robert Harper and Benjamin Pierce},
  title = {A Record Calculus Based on Symmetric Concatenation},
  booktitle = {{ACM} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Orlando, Florida},
  year = 1991,
  pages = {131--142},
  month = jan,
  note = {Extended version available as Carnegie Mellon Technical
                  Report CMU-CS-90-157},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PIERCE91"></a><pre>
@book{<a href="plclub.html#PIERCE91">PIERCE91</a>,
  author = {Benjamin C. Pierce},
  title = {Basic Category Theory for Computer Scientists},
  year = {1991},
  publisher = {MIT Press},
  fullisbn = {0-262-66071-7},
  orderinginfo = {MIT PRESS 55 Hayward ST. Cambridge Mass 02142 USA
                  800-356-0343},
  europeinfo = {14 Bloomsbury Square London WC1A 2LP U.K. Facsimile:
                  071-404-0601},
  plclub = {Yes},
  bcp = {Yes},
  keys = {books}
}
</pre>

<a name="ABADI91"></a><pre>
@article{<a href="plclub.html#ABADI91">ABADI91</a>,
  author = {Mart\'{\i}n Abadi and Luca Cardelli and Benjamin Pierce
                  and Gordon Plotkin},
  title = {Dynamic Typing in a Statically Typed Language},
  journal = {ACM Transactions on Programming Languages and Systems},
  publisher = {ACM},
  year = 1991,
  volume = 13,
  number = 2,
  month = apr,
  pages = {237--268},
  note = {Summary in \bgroup\em {ACM} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Austin, Texas\egroup, 1989},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="ABADI91B"></a><pre>
@article{<a href="plclub.html#ABADI91B">ABADI91B</a>,
  author = {Mart\'{\i}n Abadi and Benjamin Pierce and Gordon Plotkin},
  title = {Faithful Ideal Models for Recursive Polymorphic Types},
  journal = {International Journal of Foundations of Computer Science},
  volume = 2,
  number = 1,
  month = mar,
  year = 1991,
  pages = {1--21},
  note = {Summary in Fourth Annual Symposium on Logic in Computer
                  Science, June, 1989},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce91b"></a><pre>
@techreport{<a href="plclub.html#Pierce91b">Pierce91b</a>,
  author = {Benjamin C. Pierce},
  title = {Programming with Intersection Types, Union Types, and
                  Polymorphism},
  institution = {Carnegie Mellon University},
  type = {Technical Report},
  number = {CMU-CS-91-106},
  month = feb,
  year = {1991},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceThesis"></a><pre>
@phdthesis{<a href="plclub.html#PierceThesis">PierceThesis</a>,
  author = {Benjamin C. Pierce},
  title = {Programming with Intersection Types and Bounded
                  Polymorphism},
  school = {Carnegie Mellon University},
  month = {December},
  year = {1991},
  note = {Available as School of Computer Science technical report
                  CMU-CS-91-205},
  ascii = {Benjamin C. Pierce, "Programming with Intersection Types
                  and Bounded Polymorphism." Ph.D. thesis, Carnegie Mellon
                  University, December, 1991. Available as School of Computer
                  Science technical report CMU-CS-91-205.},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:fmeet"></a><pre>
@misc{<a href="plclub.html#Pierce:fmeet">Pierce:fmeet</a>,
  author = {Benjamin C. Pierce},
  title = {{\sc Fmeet}: a polymorphic $\lambda$-calculus with
                  intersection types},
  year = {1991},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="HofmannPierce92:TR"></a><pre>
@techreport{<a href="plclub.html#HofmannPierce92:TR">HofmannPierce92:TR</a>,
  author = {Martin Hofmann and Benjamin Pierce},
  title = {An Abstract View of Objects and Subtyping (Preliminary
                  Report)},
  institution = {University of Edinburgh, LFCS},
  type = {Technical Report},
  number = {ECS-LFCS-92-226},
  year = {1992},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce92d"></a><pre>
@unpublished{<a href="plclub.html#Pierce92d">Pierce92d</a>,
  author = {Benjamin C. Pierce and Robert Pollack},
  title = {Higher-Order Subtyping},
  year = {1992},
  month = aug,
  note = {Unpublished manuscript},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:delegation"></a><pre>
@unpublished{<a href="plclub.html#Pierce:delegation">Pierce:delegation</a>,
  author = {Benjamin C. Pierce},
  title = {A Model of Delegation Based on Existential Types},
  year = {1993},
  month = apr,
  note = {Available electronically},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/delegation.ps">http://www.cis.upenn.edu/~bcpierce/papers/delegation.ps</a>}
}
</pre>

<a name="Pierce:Kyoto-talk"></a><pre>
@misc{<a href="plclub.html#Pierce:Kyoto-talk">Pierce:Kyoto-talk</a>,
  author = {Benjamin C. Pierce},
  title = {A Typed Higher-Order Programming Language Based on the
                  Pi-Calculus},
  month = jul,
  year = {1993},
  note = {Invited lecture at {\em Workshop on Type Theory and its
                  Application to Computer Systems}, Kyoto University},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceRemyTurner93"></a><pre>
@inproceedings{<a href="plclub.html#PierceRemyTurner93">PierceRemyTurner93</a>,
  author = {Benjamin C. Pierce and Didier R\'emy and David N. Turner},
  title = {A Typed Higher-Order Programming Language Based on the
                  Pi-Calculus},
  month = jul,
  year = {1993},
  booktitle = {Workshop on Type Theory and its Application to Computer
                  Systems, Kyoto University},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce92g"></a><pre>
@unpublished{<a href="plclub.html#Pierce92g">Pierce92g</a>,
  author = {Benjamin C. Pierce},
  title = {F-Omega-Sub User's Manual, Version 1.4},
  year = {1993},
  month = feb,
  note = {Available by FTP as part of the {\tt fomega}
                  implementation},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:mutable"></a><pre>
@unpublished{<a href="plclub.html#Pierce:mutable">Pierce:mutable</a>,
  author = {Benjamin C. Pierce},
  title = {Mutable Objects},
  year = {1993},
  month = jun,
  note = {Draft report; available electronically},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/mutable.ps">http://www.cis.upenn.edu/~bcpierce/papers/mutable.ps</a>}
}
</pre>

<a name="PierceTurner92:POPL"></a><pre>
@inproceedings{<a href="plclub.html#PierceTurner92:POPL">PierceTurner92:POPL</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Object-Oriented Programming Without Recursive Types},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Charleston, South Carolina},
  year = {1993},
  month = jan,
  pages = {299--312},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce93c"></a><pre>
@unpublished{<a href="plclub.html#Pierce93c">Pierce93c</a>,
  author = {Benjamin Pierce},
  title = {Object-Oriented Programming in Typed Lambda-Calculus:
                  Exercises and Solutions},
  year = {1993},
  month = apr,
  note = {Lecture notes for 1992 Frankische OOrientierungstage,
                  University of Erlangen, Germany (revised version)},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceTurner92b"></a><pre>
@techreport{<a href="plclub.html#PierceTurner92b">PierceTurner92b</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Statically Typed Friendly Functions via Partially Abstract
                  Types},
  institution = {University of Edinburgh, LFCS},
  type = {Technical Report},
  number = {ECS-LFCS-93-256},
  month = apr,
  year = {1993},
  note = {Also available as INRIA-Rocquencourt Rapport de Recherche
                  No. 1899},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/friendly.ps">http://www.cis.upenn.edu/~bcpierce/papers/friendly.ps</a>}
}
</pre>

<a name="Pierce:JFLA-talk"></a><pre>
@misc{<a href="plclub.html#Pierce:JFLA-talk">Pierce:JFLA-talk</a>,
  author = {Benjamin C. Pierce},
  title = {Typage des Traits Orient\'es-Objets},
  month = feb,
  year = {1993},
  note = {Invited lecture at {\em Journe\'es Francophones des
                  Langages Applicatifs}, Annecy, France},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceSangiorgi95"></a><pre>
@inproceedings{<a href="plclub.html#PierceSangiorgi95">PierceSangiorgi95</a>,
  author = {Benjamin C. Pierce and Davide Sangiorgi},
  title = {Typing and Subtyping for Mobile Processes},
  booktitle = {Logic in Computer Science},
  year = {1993},
  note = {Full version in \bgroup\em Mathematical Structures in
                  Computer Science \egroup, Vol.\ 6, No.\ 5, 1996},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pi.ps">http://www.cis.upenn.edu/~bcpierce/papers/pi.ps</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {pict}
}
</pre>

<a name="Pierce:fomega"></a><pre>
@misc{<a href="plclub.html#Pierce:fomega">Pierce:fomega</a>,
  author = {Benjamin C. Pierce},
  title = {{\sc F-Omega-Sub}: a polymorphic $\lambda$-calculus with
                  higher-order subtyping and object-oriented extensions},
  year = {1993},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce92a"></a><pre>
@article{<a href="plclub.html#Pierce92a">Pierce92a</a>,
  author = {Benjamin C. Pierce},
  title = {Bounded Quantification is Undecidable},
  journal = {Information and Computation},
  year = 1994,
  volume = 112,
  number = 1,
  pages = {131--165},
  month = jul,
  note = {Also in C. A. Gunter and J. C. Mitchell, editors, {\em
                    Theoretical Aspects of Object-Oriented Programming:
                    Types, Semantics, and Language Design}, MIT Press, 1994. Summary in \bgroup \em {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Albuquerque, New Mexico\egroup},
  plclub = {Yes},
  bcp = {Yes},
  keys = {subtyping},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fsubpopl.ps">http://www.cis.upenn.edu/~bcpierce/papers/fsubpopl.ps</a>}
}
</pre>

<a name="Pierce:COPC-talk"></a><pre>
@misc{<a href="plclub.html#Pierce:COPC-talk">Pierce:COPC-talk</a>,
  author = {Benjamin C. Pierce},
  title = {Concurrent Objects in a Process Calculus},
  note = {Invited lecture at {\em Theory and Practice of Parallel
                  Programming (TPPP)}, Sendai, Japan},
  year = 1994,
  month = nov,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="CastagnaPierce93"></a><pre>
@inproceedings{<a href="plclub.html#CastagnaPierce93">CastagnaPierce93</a>,
  author = {Giuseppe Castagna and Benjamin Pierce},
  title = {Decidable Bounded Quantification},
  booktitle = {Proceedings of the Twenty-First {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Portland, Oregon},
  publisher = {ACM},
  year = 1994,
  month = jan,
  plclub = {Yes},
  bcp = {Yes},
  keys = {subtyping},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fsubnew.ps">http://www.cis.upenn.edu/~bcpierce/papers/fsubnew.ps</a>}
}
</pre>

<a name="PierceSteffen95"></a><pre>
@inproceedings{<a href="plclub.html#PierceSteffen95">PierceSteffen95</a>,
  author = {Benjamin C. Pierce and Martin Steffen},
  realauthor = {Benjamin Pierce and Martin Steffen},
  title = {Higher-Order Subtyping},
  booktitle = {IFIP Working Conference on Programming Concepts, Methods
                  and Calculi (PROCOMET)},
  year = 1994,
  note = {Full version in \bgroup\em Theoretical Computer
                  Science\egroup, vol.~176, no.~1--2, pp.\  235--282, 1997
                  (corrigendum in TCS vol.~184 (1997), p.~247)},
  plclub = {Yes},
  bcp = {Yes},
  keys = {subtyping},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fomega.ps">http://www.cis.upenn.edu/~bcpierce/papers/fomega.ps</a>}
}
</pre>

<a name="SteffenPierce93:TR"></a><pre>
@techreport{<a href="plclub.html#SteffenPierce93:TR">SteffenPierce93:TR</a>,
  author = {Martin Steffen and Benjamin Pierce},
  title = {Higher-Order Subtyping},
  year = {1994},
  month = jan,
  institution = {LFCS, University of Edinburgh},
  number = {ECS-LFCS-94-280},
  note = {Also available as {Universit\"at Erlangen-N\"urnberg
                  Interner Bericht IMMD7-01/94}. To appear in Theoretical
                  Computer Science.},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="HofmannPierce94a:TR"></a><pre>
@techreport{<a href="plclub.html#HofmannPierce94a:TR">HofmannPierce94a:TR</a>,
  author = {Martin Hofmann and Benjamin Pierce},
  title = {Positive Subtyping},
  year = {1994},
  month = sep,
  institution = {LFCS, University of Edinburgh},
  number = {ECS-LFCS-94-303},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceTurner92"></a><pre>
@article{<a href="plclub.html#PierceTurner92">PierceTurner92</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Simple Type-Theoretic Foundations for Object-Oriented
                  Programming},
  note = {Summary in \bgroup\em {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Charleston, South Carolina\egroup, 1993},
  journal = {Journal of Functional Programming},
  volume = 4,
  number = 2,
  month = apr,
  pages = {207--247},
  year = {1994},
  plclub = {Yes},
  bcp = {Yes},
  pdf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/oop.pdf">http://www.cis.upenn.edu/~bcpierce/papers/oop.pdf</a>},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/oop.ps">http://www.cis.upenn.edu/~bcpierce/papers/oop.ps</a>},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/oop-popl.ps">http://www.cis.upenn.edu/~bcpierce/papers/oop-popl.ps</a>},
  keys = {oop}
}
</pre>

<a name="Pierce94a"></a><pre>
@article{<a href="plclub.html#Pierce94a">Pierce94a</a>,
  author = {Benjamin C. Pierce},
  title = {Woggles from {O}z: {W}riting Interactive Fiction},
  note = {Expanded version available electronically},
  journal = {Leonardo: Journal of the International Society for the
                  Arts, Sciences, and Technology},
  year = {1994},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="HofmannPierce94"></a><pre>
@article{<a href="plclub.html#HofmannPierce94">HofmannPierce94</a>,
  author = {Martin Hofmann and Benjamin Pierce},
  title = {A Unifying Type-Theoretic Framework for Objects},
  journal = {Journal of Functional Programming},
  volume = {5},
  number = {4},
  pages = {593--635},
  month = oct,
  note = {Previous versions appeared in the Symposium on Theoretical
                  Aspects of Computer Science, 1994, (pages 251--262) and,
                  under the title ``An Abstract View of Objects and Subtyping
                  (Preliminary Report),'' as University of Edinburgh, LFCS
                  technical report ECS-LFCS-92-226, 1992},
  year = 1995,
  plclub = {Yes},
  bcp = {Yes},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/abstroop.ps">http://www.cis.upenn.edu/~bcpierce/papers/abstroop.ps</a>},
  keys = {oop}
}
</pre>

<a name="PierceTurner94:COPC"></a><pre>
@inproceedings{<a href="plclub.html#PierceTurner94:COPC">PierceTurner94:COPC</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Concurrent Objects in a Process Calculus},
  booktitle = {Theory and Practice of Parallel Programming (TPPP),
                  Sendai, Japan (Nov.{} 1994)},
  editor = {Takayasu Ito and Akinori Yonezawa},
  year = {1995},
  month = apr,
  publisher = {Springer-Verlag},
  series = {Lecture Notes in Computer Science},
  number = {907},
  pages = {187--215},
  short = {<a href="``Concurrent Objects in a Process Calculus,'' Benjamin C.
                  Pierce and David N. Turner, invited lecture at {\it Theory
                  and Practice of Parallel Programming (TPPP)}, Sendai, Japan
                  (Nov.{} 1994). Springer Lecture Notes in Computer Science
                  907, pp.~187--215">``Concurrent Objects in a Process Calculus,'' Benjamin C.
                  Pierce and David N. Turner, invited lecture at {\it Theory
                  and Practice of Parallel Programming (TPPP)}, Sendai, Japan
                  (Nov.{} 1994). Springer Lecture Notes in Computer Science
                  907, pp.~187--215</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {pict},
  url = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/copc.ps">http://www.cis.upenn.edu/~bcpierce/papers/copc.ps</a>}
}
</pre>

<a name="CastagnaPierce95"></a><pre>
@inproceedings{<a href="plclub.html#CastagnaPierce95">CastagnaPierce95</a>,
  author = {Giuseppe Castagna and Benjamin Pierce},
  title = {Corrigendum: Decidable Bounded Quantification},
  booktitle = {Proceedings of the Twenty-Second {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Portland, Oregon},
  publisher = {ACM},
  year = 1995,
  month = jan,
  plclub = {Yes},
  bcp = {Yes},
  keys = {subtyping},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fsubnew-corrigendum.ps">http://www.cis.upenn.edu/~bcpierce/papers/fsubnew-corrigendum.ps</a>}
}
</pre>

<a name="Abadi92"></a><pre>
@article{<a href="plclub.html#Abadi92">Abadi92</a>,
  author = {Mart\'{\i}n Abadi and Luca Cardelli and Benjamin Pierce
                  and Didier R\'{e}my},
  title = {Dynamic Typing in Polymorphic Languages},
  journal = {Journal of Functional Programming},
  volume = {5},
  number = {1},
  pages = {111--130},
  month = jan,
  note = {Summary in \bgroup \em ACM SIGPLAN Workshop on ML and its
                  Applications\egroup, June 1992},
  year = 1995,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:LinearPiTalk"></a><pre>
@misc{<a href="plclub.html#Pierce:LinearPiTalk">Pierce:LinearPiTalk</a>,
  author = {Benjamin C. Pierce},
  title = {Linearity and the Pi-Calculus},
  note = {Invited lecture at {\em Advances in Type Systems for
                  Computation}, Cambridge, England},
  year = 1995,
  month = aug,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="KobayashiPierceTurner:LinearPiTR"></a><pre>
@misc{<a href="plclub.html#KobayashiPierceTurner:LinearPiTR">KobayashiPierceTurner:LinearPiTR</a>,
  author = {Naoki Kobayashi and Benjamin C. Pierce and David N.
                  Turner},
  title = {Linearity and the Pi-Calculus},
  year = {1995},
  note = {Technical report, Department of Information Science,
                  University of Tokyo and Computer Laboratory, University of
                  Cambridge},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="HofmannPierce94a"></a><pre>
@inproceedings{<a href="plclub.html#HofmannPierce94a">HofmannPierce94a</a>,
  author = {Martin Hofmann and Benjamin Pierce},
  title = {Positive Subtyping},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), San Francisco, California},
  year = {1995},
  month = jan,
  pages = {186--197},
  note = {Full version in \bgroup\em Information and
                  Computation\egroup, volume 126, number 1, April 1996. Also
                  available as University of Edinburgh technical report
                  ECS-LFCS-94-303, September 1994},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pos.ps">http://www.cis.upenn.edu/~bcpierce/papers/pos.ps</a>}
}
</pre>

<a name="Pierce:LICSSurvey"></a><pre>
@misc{<a href="plclub.html#Pierce:LICSSurvey">Pierce:LICSSurvey</a>,
  author = {Benjamin C. Pierce},
  title = {Types and Programming Languages: The Next Generation},
  note = {Invited tutorial at {\em Logic in Computer Science (LICS)}},
  year = 2003,
  plclub = {Yes},
  bcp = {Yes},
  keys = {typessurveys},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tng-lics2003-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/tng-lics2003-slides.pdf</a>}
}
</pre>

<a name="Pierce:ICMTtalk"></a><pre>
@misc{<a href="plclub.html#Pierce:ICMTtalk">Pierce:ICMTtalk</a>,
  author = {Benjamin C. Pierce},
  title = {Foundations for Bidirectional Programming, or: {H}ow To Build 
                  a Bidirectional Programming Language},
  note = {Keynote address at {\em International Conference 
                  on Model Transformation (ICMT)}},
  year = 2009,
  month = jun,
  plclub = {Yes},
  bcp = {Yes},
  keys = {harmony},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/icmt-2009-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/icmt-2009-slides.pdf</a>}
}
</pre>

<a name="Pierce:CERNtalk"></a><pre>
@misc{<a href="plclub.html#Pierce:CERNtalk">Pierce:CERNtalk</a>,
  author = {Benjamin C. Pierce},
  title = {Mysteries of Dropbox},
  note = {Keynote address at CERN {\em Workshop on Cloud Services for File Synchronisation and Sharing}},
  year = 2014,
  month = nov,
  plclub = {Yes},
  bcp = {Yes},
  keys = {harmony},
  slides = {<a href="https://indico.cern.ch/event/336753/session/1/contribution/28">https://indico.cern.ch/event/336753/session/1/contribution/28</a>},
  video = {https://indico.cern.ch/event/336753/session/1/contribution/28}
}
</pre>

<a name="Pierce:ClojureConjtalk"></a><pre>
@misc{<a href="plclub.html#Pierce:ClojureConjtalk">Pierce:ClojureConjtalk</a>,
  author = {Benjamin C. Pierce},
  title = {A Deep Specification for Dropbox},
  note = {Keynote address at Clojure/conj},
  year = 2015,
  month = nov,
  plclub = {Yes},
  bcp = {Yes},
  keys = {harmony},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/clojure-deepspec-2015.pdf">http://www.cis.upenn.edu/~bcpierce/papers/clojure-deepspec-2015.pdf</a>},
  video = {https://www.youtube.com/watch?v=Y2jQe8DFzUM}
}
</pre>

<a name="MysteriesOfDropbox2016"></a><pre>
@inproceedings{<a href="plclub.html#MysteriesOfDropbox2016">MysteriesOfDropbox2016</a>,
  author = {John Hughes and Benjamin C. Pierce and Thomas Arts 
                  and Ulf Norell},
  title = {Mysteries of {D}ropbox: {P}roperty-Based Testing 
                  of a Distributed 
                  Synchronization Service},
  year = 2016,
  booktitle = {International Conference on Software Testing, 
                  Verification and Validation (ICST)},
  month = apr,
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/ICST-2015-mysteries.pdf">http://www.cis.upenn.edu/~bcpierce/papers/ICST-2015-mysteries.pdf</a>},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/mysteriesofdropbox.pdf">http://www.cis.upenn.edu/~bcpierce/papers/mysteriesofdropbox.pdf</a>}
}
</pre>

<a name="Pierce:ChalmersDeepspecTalk"></a><pre>
@misc{<a href="plclub.html#Pierce:ChalmersDeepspecTalk">Pierce:ChalmersDeepspecTalk</a>,
  author = {Benjamin C. Pierce},
  title = {The Age of Deep Specification},
  note = {Honorary doctorate address at Chalmers University},
  year = 2015,
  month = may,
  plclub = {Yes},
  bcp = {Yes},
  akeys = {verification},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/chalmers-deepspec-2015.pdf">http://www.cis.upenn.edu/~bcpierce/papers/chalmers-deepspec-2015.pdf</a>}
}
</pre>

<a name="Pierce:LambdaTA"></a><pre>
@misc{<a href="plclub.html#Pierce:LambdaTA">Pierce:LambdaTA</a>,
  author = {Benjamin C. Pierce},
  title = {Lambda, The Ultimate {TA}: {U}sing a Proof Assistant to Teach 
                  Programming Language Foundations},
  note = {Keynote address at {\em International Conference on 
                  Functional Programming (ICFP)}},
  year = 2009,
  plclub = {Yes},
  month = sep,
  bcp = {Yes},
  keys = {verification},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/LambdaTA.pdf">http://www.cis.upenn.edu/~bcpierce/papers/LambdaTA.pdf</a>}
}
</pre>

<a name="Pierce:LambdaTA-ITP"></a><pre>
@misc{<a href="plclub.html#Pierce:LambdaTA-ITP">Pierce:LambdaTA-ITP</a>,
  author = {Benjamin C. Pierce},
  title = {Proof Assistant
                  as Teaching Assistant: A View from the Trenches},
  note = {Keynote address at {\em International Conference 
                  on Interactive Theorem Proving (ITP)}},
  year = 2010,
  plclub = {Yes},
  month = jul,
  bcp = {Yes},
  keys = {verification},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/LambdaTA-ITP.pdf">http://www.cis.upenn.edu/~bcpierce/papers/LambdaTA-ITP.pdf</a>}
}
</pre>

<a name="Pierce:ModulesTutorial"></a><pre>
@misc{<a href="plclub.html#Pierce:ModulesTutorial">Pierce:ModulesTutorial</a>,
  author = {Benjamin C. Pierce},
  title = {Advanced Module Systems: A Guide for the Perplexed},
  note = {Invited tutorial at {\em International Conference on Functional
                  Programming (ICFP)}},
  year = 2000,
  plclub = {Yes},
  bcp = {Yes},
  keys = {typessurveys},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps">http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps</a>}
}
</pre>

<a name="Pierce:HorizonDayTalk"></a><pre>
@misc{<a href="plclub.html#Pierce:HorizonDayTalk">Pierce:HorizonDayTalk</a>,
  author = {Benjamin C. Pierce},
  title = {Using Types to Compare Objects and {ADT}s},
  note = {Invited lecture at {\em Horizon Day}, Indiana University},
  year = 1995,
  month = oct,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="BruceCardelliPierce96:old"></a><pre>
@inproceedings{<a href="plclub.html#BruceCardelliPierce96:old">BruceCardelliPierce96:old</a>,
  author = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
  title = {Comparing Object Encodings},
  booktitle = {Invited lecture at Third Workshop on Foundations of Object
                  Oriented Languages (FOOL 3)},
  year = 1996,
  month = jul,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="NestmannPierce96"></a><pre>
@inproceedings{<a href="plclub.html#NestmannPierce96">NestmannPierce96</a>,
  author = {Uwe Nestmann and Benjamin C. Pierce},
  title = {Decoding Choice Encodings},
  booktitle = {Proceedings of CONCUR '96},
  year = 1996,
  month = aug,
  note = {Full version in \bgroup\em Information and
                  Computation\egroup, 163(1): 1--59 (2000)},
  plclub = {Yes},
  bcp = {Yes},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/choice.ps">http://www.cis.upenn.edu/~bcpierce/papers/choice.ps</a>},
  keys = {pict}
}
</pre>

<a name="Pierce:EvenSimpler"></a><pre>
@unpublished{<a href="plclub.html#Pierce:EvenSimpler">Pierce:EvenSimpler</a>,
  author = {Benjamin C. Pierce},
  title = {Even simpler type-theoretic foundations for {OOP}},
  month = mar,
  year = {1996},
  note = {Manuscript (circulated electronically)},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="EncyOfDBs09"></a><pre>
@incollection{<a href="plclub.html#EncyOfDBs09">EncyOfDBs09</a>,
  author = {V\'{e}ronique Benzaken and Giuseppe Castagna and Haruo
                  Hosoya and Benjamin C. Pierce and Stijn Vansummeren},
  title = {{XML}  Typechecking},
  booktitle = {Encyclopedia of Database Systems},
  publisher = {Springer},
  year = {2009},
  plclub = {Yes},
  bcp = {Yes},
  keys = {xduce}
}
</pre>

<a name="Pierce95a"></a><pre>
@incollection{<a href="plclub.html#Pierce95a">Pierce95a</a>,
  author = {Benjamin C. Pierce},
  title = {Foundational Calculi for Programming Languages},
  booktitle = {Handbook of Computer Science and Engineering},
  chapter = {139},
  publisher = {CRC Press},
  year = {1996},
  editor = {Allen B. Tucker},
  plclub = {Yes},
  bcp = {Yes},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/crchandbook.ps">http://www.cis.upenn.edu/~bcpierce/papers/crchandbook.ps</a>},
  keys = {pict}
}
</pre>

<a name="CompagnoniPierce93"></a><pre>
@article{<a href="plclub.html#CompagnoniPierce93">CompagnoniPierce93</a>,
  author = {Adriana B. Compagnoni and Benjamin C. Pierce},
  title = {Intersection Types and Multiple Inheritance},
  pages = {469--501},
  journal = {Mathematical Structures in Computer Science},
  month = oct,
  year = 1996,
  volume = 6,
  number = 5,
  source = {<a href="http://theory.lcs.mit.edu/~dmjones/hbp/mscs/mscs.bib">http://theory.lcs.mit.edu/~dmjones/hbp/mscs/mscs.bib</a>},
  note = {Preliminary version available as University of Edinburgh
                  technical report ECS-LFCS-93-275 and Catholic University
                  Nijmegen computer science technical report 93-18, Aug.
                  1993, under the title ``Multiple Inheritance via
                  Intersection Types''},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="KobayashiPierceTurner:LinearPi"></a><pre>
@inproceedings{<a href="plclub.html#KobayashiPierceTurner:LinearPi">KobayashiPierceTurner:LinearPi</a>,
  author = {Naoki Kobayashi and Benjamin C. Pierce and David N.
                  Turner},
  title = {Linearity and the Pi-Calculus},
  year = {1996},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), St.~Petersburg Beach, Florida},
  note = {Full version in \bgroup\em ACM Transactions on Programming Languages and Systems\egroup, 21(5), pp. 914--947, September 1999},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="CompagnoniPierce93:old"></a><pre>
@article{<a href="plclub.html#CompagnoniPierce93:old">CompagnoniPierce93:old</a>,
  author = {Adriana B. Compagnoni and Benjamin C. Pierce},
  title = {Multiple Inheritance via Intersection Types},
  journal = {Mathematical Structures in Computer Science},
  year = 1996,
  note = {To appear. Preliminary version available as University of
                  Edinburgh technical report ECS-LFCS-93-275 and Catholic
                  University Nijmegen computer science technical report
                  93-18, Aug. 1993},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="OnBinaryMethods"></a><pre>
@article{<a href="plclub.html#OnBinaryMethods">OnBinaryMethods</a>,
  author = {Kim B. Bruce and Luca Cardelli and Giuseppe Castagna and
                  {the Hopkins Objects Group (Jonathan Eifrig, Scott Smith,
                  Valery Trifonov)} and Gary T. Leavens and Benjamin Pierce},
  title = {On Binary Methods},
  journal = {Theory and Practice of Object Systems},
  volume = 1,
  number = 3,
  pages = {221--242},
  year = 1996,
  checked = {No},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/binary.ps">http://www.cis.upenn.edu/~bcpierce/papers/binary.ps</a>}
}
</pre>

<a name="Pierce:FMOODSTalk"></a><pre>
@misc{<a href="plclub.html#Pierce:FMOODSTalk">Pierce:FMOODSTalk</a>,
  author = {Benjamin C. Pierce},
  title = {Processes, Types, and Observations},
  note = {Invited lecture at {\em Formal Methods on Open,
                  Object-Based Distributed Systems (FMOODS)}, Paris},
  year = 1996,
  month = mar,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce96a"></a><pre>
@unpublished{<a href="plclub.html#Pierce96a">Pierce96a</a>,
  author = {Benjamin C. Pierce},
  title = {Types},
  note = {Lecture notes for an undergraduate course at Cambridge
                  University},
  month = feb,
  year = 1996,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceSangiorgi96"></a><pre>
@inproceedings{<a href="plclub.html#PierceSangiorgi96">PierceSangiorgi96</a>,
  author = {Benjamin Pierce and Davide Sangiorgi},
  title = {Behavioral Equivalence in the Polymorphic Pi-Calculus},
  year = 1997,
  booktitle = {Principles of Programming Languages (POPL)},
  note = {Full version in {\em Journal of the Association for
                  Computing Machinery (JACM)}, 47(3), May 2000},
  pages = {531--584},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/polybisim.ps">http://www.cis.upenn.edu/~bcpierce/papers/polybisim.ps</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {pict}
}
</pre>

<a name="Pierce:BQB"></a><pre>
@techreport{<a href="plclub.html#Pierce:BQB">Pierce:BQB</a>,
  author = {Benjamin C. Pierce},
  title = {Bounded Quantification with Bottom},
  year = {1997},
  institution = {Computer Science Department, Indiana University},
  series = {CSCI},
  number = {492},
  plclub = {Yes},
  bcp = {Yes},
  keys = {subtyping},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/bqb.ps">http://www.cis.upenn.edu/~bcpierce/papers/bqb.ps</a>}
}
</pre>

<a name="BruceCardelliPierce96:TACS"></a><pre>
@inproceedings{<a href="plclub.html#BruceCardelliPierce96:TACS">BruceCardelliPierce96:TACS</a>,
  author = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
  title = {Comparing Object Encodings},
  booktitle = {International Symposium on Theoretical Aspects of Computer Software (TACS)},
  year = 1997,
  month = sep,
  note = {An earlier version was presented as an invited lecture at
                  the Third International Workshop on Foundations of Object
                  Oriented Languages (FOOL 3), July 1996; full version in \bgroup\em Information and Computation\egroup, 155(1--2):108-133, 1999},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceSteffen95:old"></a><pre>
@article{<a href="plclub.html#PierceSteffen95:old">PierceSteffen95:old</a>,
  author = {Benjamin Pierce and Martin Steffen},
  title = {Higher-Order Subtyping},
  year = 1997,
  journal = {Theoretical Computer Science},
  volume = 176,
  number = {1--2},
  pages = {235--282},
  note = {Summary in IFIP Working Conference on Programming
                  Concepts, Methods and Calculi (PROCOMET), June 1994; also
                  University of Edinburgh technical report ECS-LFCS-94-280
                  and {Universit\"at Erlangen-N\"urnberg Interner Bericht
                  IMMD7-01/94}, January 1994.},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce92b"></a><pre>
@article{<a href="plclub.html#Pierce92b">Pierce92b</a>,
  author = {Benjamin C. Pierce},
  title = {Intersection Types and Bounded Polymorphism},
  pages = {129--193},
  journal = {Mathematical Structures in Computer Science},
  month = apr,
  year = 1997,
  volume = 7,
  number = 2,
  source = {<a href="http://theory.lcs.mit.edu/~dmjones/hbp/mscs/mscs.bib">http://theory.lcs.mit.edu/~dmjones/hbp/mscs/mscs.bib</a>},
  note = {Summary in {\em Typed Lambda
                  Calculi and Applications}, March 1993, pp. 346--360},
  ascii = {Benjamin C. Pierce, "Intersection Types and Bounded
                  Polymorphism." Conference on Typed Lambda Calculi and
                  Applications, March, 1993},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:LFPTW"></a><pre>
@misc{<a href="plclub.html#Pierce:LFPTW">Pierce:LFPTW</a>,
  author = {Benjamin C. Pierce},
  title = {Languages for Programming the Web},
  month = dec,
  year = {1997},
  note = {Course materials for a graduate seminar on the theory and
                  practice of mobile agent programming. Available through
                  {\tt http://www.cis.upenn.edu/$sim$bcpierce/courses/629}.},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceTurner:LTI-FSUB"></a><pre>
@techreport{<a href="plclub.html#PierceTurner:LTI-FSUB">PierceTurner:LTI-FSUB</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Local Type Argument Synthesis with Bounded Quantification},
  year = {1997},
  institution = {Computer Science Department, Indiana University},
  month = jan,
  series = {CSCI},
  number = {495},
  plclub = {Yes},
  bcp = {Yes},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti-fsub.ps">http://www.cis.upenn.edu/~bcpierce/papers/lti-fsub.ps</a>},
  keys = {inference}
}
</pre>

<a name="PierceTurner:LTI-TR"></a><pre>
@techreport{<a href="plclub.html#PierceTurner:LTI-TR">PierceTurner:LTI-TR</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Local Type Inference},
  year = {1997},
  institution = {Computer Science Department, Indiana University},
  series = {CSCI},
  number = {493},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceTurner:PictDefn"></a><pre>
@unpublished{<a href="plclub.html#PierceTurner:PictDefn">PierceTurner:PictDefn</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Pict Language Definition},
  year = {1997},
  note = {Available electronically},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceTurner:PictLib"></a><pre>
@unpublished{<a href="plclub.html#PierceTurner:PictLib">PierceTurner:PictLib</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Pict Libraries Manual},
  year = {1997},
  note = {Available electronically},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceTurner:PictCompiler"></a><pre>
@misc{<a href="plclub.html#PierceTurner:PictCompiler">PierceTurner:PictCompiler</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Pict: A Programming Language Based on the Pi-Calculus},
  year = {1997},
  note = {\URL{http://www.cis.upenn.edu/~bcpierce/papers/pict}},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PictDistribution"></a><pre>
@misc{<a href="plclub.html#PictDistribution">PictDistribution</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {The {Pict} Programming Language},
  year = {2001},
  homepage = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pict/Html/Pict.html">http://www.cis.upenn.edu/~bcpierce/papers/pict/Html/Pict.html</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {pict},
  note = {This directory contains various papers, including a tutorial and user's manual, as well as complete compiler sources and installation instructions. (Be sure not to miss the artwork department!)}
}
</pre>

<a name="Pierce94b"></a><pre>
@unpublished{<a href="plclub.html#Pierce94b">Pierce94b</a>,
  author = {Benjamin C. Pierce},
  title = {Programming in the Pi-Calculus: {A} Tutorial Introduction
                  to {P}ict},
  year = {1997},
  note = {Available electronically},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce98:ACReview"></a><pre>
@article{<a href="plclub.html#Pierce98:ACReview">Pierce98:ACReview</a>,
  author = {Benjamin C. Pierce},
  title = {Review of {A Theory of Objects}, by {A}badi and
                  {C}ardelli},
  year = {1997},
  volume = 40,
  number = 5,
  pages = {297--298},
  journal = {The Computer Journal},
  source = {Tom Melham},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/ac-review.ps">http://www.cis.upenn.edu/~bcpierce/papers/ac-review.ps</a>}
}
</pre>

<a name="GhelliPierce95-OLD"></a><pre>
@article{<a href="plclub.html#GhelliPierce95-OLD">GhelliPierce95-OLD</a>,
  author = {Giorgio Ghelli and Benjamin Pierce},
  title = {Bounded Existentials and Minimal Typing},
  year = {1998},
  volume = 193,
  pages = {75--96},
  journal = {Theoretical Computer Science},
  plclub = {Yes},
  bcp = {Yes},
  note = {Circulated in manuscript form in 1992}
}
</pre>

<a name="GhelliPierce95"></a><pre>
@misc{<a href="plclub.html#GhelliPierce95">GhelliPierce95</a>,
  author = {Giorgio Ghelli and Benjamin Pierce},
  title = {Bounded Existentials and Minimal Typing},
  year = {1992},
  note = {Circulated in manuscript form. Full version in 
                  {\em Theoretical Computer Science}, 193(1--2):75--96, February 1998.},
  plclub = {Yes},
  bcp = {Yes},
  keys = {subtyping},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/exists.ps">http://www.cis.upenn.edu/~bcpierce/papers/exists.ps</a>}
}
</pre>

<a name="BalasubramaniamPierce98-TR"></a><pre>
@techreport{<a href="plclub.html#BalasubramaniamPierce98-TR">BalasubramaniamPierce98-TR</a>,
  author = {S. Balasubramaniam and Benjamin C. Pierce},
  title = {File Synchronization},
  institution = {Computer Science Department, Indiana University},
  series = {CSCI},
  number = {507},
  month = apr,
  year = 1998,
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceTurner:LTI"></a><pre>
@inproceedings{<a href="plclub.html#PierceTurner:LTI">PierceTurner:LTI</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Local Type Inference},
  year = 1998,
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), San Diego, California},
  note = {Full version in \bgroup\em ACM Transactions on Programming
                  Languages and Systems (TOPLAS)\egroup, 22(1), January 2000,
                  pp.~1--44},
  plclub = {Yes},
  bcp = {Yes},
  keys = {inference},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti.pdf">http://www.cis.upenn.edu/~bcpierce/papers/lti.pdf</a>},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti-popl.pdf">http://www.cis.upenn.edu/~bcpierce/papers/lti-popl.pdf</a>},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.pdf">http://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.pdf</a>}
}
</pre>

<a name="HofmannPierce:TD"></a><pre>
@inproceedings{<a href="plclub.html#HofmannPierce:TD">HofmannPierce:TD</a>,
  author = {Martin Hofmann and Benjamin C. Pierce},
  title = {Type Destructors},
  booktitle = {Informal proceedings of the Fourth International Workshop
                  on Foundations of Object-Oriented Languages (FOOL)},
  editor = {Didier R\'e{}my},
  month = jan,
  year = {1998},
  note = {Full version in {\em Information and Computation}, 172(1)29--62 (2002)},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/td.ps">http://www.cis.upenn.edu/~bcpierce/papers/td.ps</a>}
}
</pre>

<a name="Pierce:CONCUR-tutorial"></a><pre>
@misc{<a href="plclub.html#Pierce:CONCUR-tutorial">Pierce:CONCUR-tutorial</a>,
  author = {Benjamin C. Pierce},
  title = {Type Systems for Concurrent Calculi},
  month = sep,
  year = {1998},
  note = {Invited tutorial at {\em CONCUR}, Nice, France},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="BunemanPierce99"></a><pre>
@incollection{<a href="plclub.html#BunemanPierce99">BunemanPierce99</a>,
  author = {Peter Buneman and Benjamin Pierce},
  booktitle = {Internet Programming Languages},
  title = {Union Types for Semistructured Data},
  year = {1998},
  month = sep,
  publisher = {Springer-Verlag},
  note = {Proceedings of the International Database Programming
                  Languages Workshop. LNCS 1686},
  plclub = {Yes},
  bcp = {Yes},
  keys = {xduce},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/utssd.ps">http://www.cis.upenn.edu/~bcpierce/papers/utssd.ps</a>}
}
</pre>

<a name="BalasubramaniamPierce98"></a><pre>
@inproceedings{<a href="plclub.html#BalasubramaniamPierce98">BalasubramaniamPierce98</a>,
  author = {S. Balasubramaniam and Benjamin C. Pierce},
  title = {What is a file synchronizer?},
  booktitle = {Fourth Annual ACM/IEEE International Conference on Mobile
                  Computing and Networking (MobiCom '98)},
  month = oct,
  year = 1998,
  note = {Full version available as Indiana University CSCI
                  technical report \#507, April 1998},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/snc-mobicom.ps">http://www.cis.upenn.edu/~bcpierce/papers/snc-mobicom.ps</a>},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/snc.ps">http://www.cis.upenn.edu/~bcpierce/papers/snc.ps</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/snc-slides.ps">http://www.cis.upenn.edu/~bcpierce/papers/snc-slides.ps</a>},
  keys = {unison},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:GlobalComputingFoolTalk"></a><pre>
@misc{<a href="plclub.html#Pierce:GlobalComputingFoolTalk">Pierce:GlobalComputingFoolTalk</a>,
  author = {Benjamin C. Pierce},
  title = {Global Computing: Some Questions for {FOOLs}},
  slides = {<a href="gc-fool-slides.ps">gc-fool-slides.ps</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {concurrencysurveys},
  note = {Invited talk at FOOL workshop},
  year = 2001
}
</pre>

<a name="Pierce:TypeSystemsForConcurrencyTalk"></a><pre>
@misc{<a href="plclub.html#Pierce:TypeSystemsForConcurrencyTalk">Pierce:TypeSystemsForConcurrencyTalk</a>,
  author = {Benjamin C. Pierce},
  title = {Type Systems for Concurrent Calculi},
  slides = {<a href="concur98.ps">concur98.ps</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {concurrencysurveys},
  note = {Invited tutorial at CONCUR},
  year = 1998
}
</pre>

<a name="Pierce:FileSyncTheoryAndPracticeSlides"></a><pre>
@misc{<a href="plclub.html#Pierce:FileSyncTheoryAndPracticeSlides">Pierce:FileSyncTheoryAndPracticeSlides</a>,
  author = {Benjamin C. Pierce},
  title = {File Synchronization: Theory and Practice},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/new-snc-slides.ps">http://www.cis.upenn.edu/~bcpierce/papers/new-snc-slides.ps</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {unison},
  year = 2001
}
</pre>

<a name="Pierce:UnisonAFileSync-Slides"></a><pre>
@misc{<a href="plclub.html#Pierce:UnisonAFileSync-Slides">Pierce:UnisonAFileSync-Slides</a>,
  author = {Benjamin C. Pierce},
  title = {Unison: A file synchronizer and its specification},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/snc-tacs-2001Oct.ps">http://www.cis.upenn.edu/~bcpierce/papers/snc-tacs-2001Oct.ps</a>},
  note = {Invited talk at {\em Theoretical Aspects of Computer Software} 
                  (TACS), Sendai, Japan},
  plclub = {Yes},
  bcp = {Yes},
  keys = {unison},
  year = 2001
}
</pre>

<a name="Pierce:snc"></a><pre>
@misc{<a href="plclub.html#Pierce:snc">Pierce:snc</a>,
  author = {Benjamin C. Pierce and Sundar Balasubramaniam, Trevor Jim
                  and Insup Lee and Insik Shin},
  title = {{\sc Snc}: a file synchronizer},
  year = {1998},
  note = {(Superseded by {\sc Unison}.)},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="IgarashiPierceWadler99"></a><pre>
@inproceedings{<a href="plclub.html#IgarashiPierceWadler99">IgarashiPierceWadler99</a>,
  author = {Atsushi Igarashi and Benjamin Pierce and Philip Wadler},
  title = {Featherweight {J}ava: {A} Minimal Core Calculus for {J}ava
                  and {GJ}},
  month = oct,
  booktitle = {{ACM} {SIGPLAN} {C}onference on {O}bject {O}riented {P}rogramming:
                    {S}ystems, {L}anguages, and {A}pplications ({OOPSLA})},
  year = {1999},
  note = {Full version in ACM Transactions on Programming
                  Languages and Systems (TOPLAS), 23(3), May 2001},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fj-oopsla.ps">http://www.cis.upenn.edu/~bcpierce/papers/fj-oopsla.ps</a>},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fj-toplas.pdf">http://www.cis.upenn.edu/~bcpierce/papers/fj-toplas.pdf</a>}
}
</pre>

<a name="IgarashiPierce99"></a><pre>
@inproceedings{<a href="plclub.html#IgarashiPierce99">IgarashiPierce99</a>,
  author = {Atsushi Igarashi and Benjamin C. Pierce},
  title = {Foundations for Virtual Types},
  month = jun,
  year = 1999,
  booktitle = {European Conference on Object-Oriented Programming (ECOOP), Lisbon, Portugal},
  note = {Also in informal proceedings of the 
                  {\em Workshop on Foundations of Object-Oriented Languages
                  (FOOL)}, January 1999. Full version in {\em Information and
                  Computation}, 175(1): 34--49, May 2002},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/vt.ps">http://www.cis.upenn.edu/~bcpierce/papers/vt.ps</a>}
}
</pre>

<a name="HosoyaPierce99"></a><pre>
@techreport{<a href="plclub.html#HosoyaPierce99">HosoyaPierce99</a>,
  author = {Haruo Hosoya and Benjamin C. Pierce},
  title = {How Good is Local Type Inference?},
  institution = {University of Pennsylvania},
  number = {MS-CIS-99-17},
  month = jun,
  year = 1999,
  plclub = {Yes},
  bcp = {Yes},
  keys = {inference},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/hgilti.ps">http://www.cis.upenn.edu/~bcpierce/papers/hgilti.ps</a>}
}
</pre>

<a name="KobayashiPierceTurner:LinearPi:TOPLAS"></a><pre>
@article{<a href="plclub.html#KobayashiPierceTurner:LinearPi:TOPLAS">KobayashiPierceTurner:LinearPi:TOPLAS</a>,
  author = {Naoki Kobayashi and Benjamin C. Pierce and David N.
                  Turner},
  title = {Linearity and the {Pi-Calculus}},
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {21},
  number = {5},
  pages = {914--947},
  month = sep,
  year = {1999},
  coden = {ATPSDT},
  fullissn = {0164-0925},
  bibdate = {Tue Sep 26 10:12:58 MDT 2000},
  source = {TOPLAS db},
  note = {Summary in POPL 1996.},
  keys = {pict},
  full = {<a href="http://www.acm.org/pubs/articles/journals/toplas/1999-21-5/p914-kobayashi/p914-kobayashi.pdf;
                  http://www.acm.org/pubs/citations/journals/toplas/1999-21-5/p914-kobayashi/">http://www.acm.org/pubs/articles/journals/toplas/1999-21-5/p914-kobayashi/p914-kobayashi.pdf;
                  http://www.acm.org/pubs/citations/journals/toplas/1999-21-5/p914-kobayashi/</a>},
  abstract = {The economy and flexibility of the pi-calculus make it an
                  attractive object of theoretical study and a clean basis
                  for concurrent language design and implementation. However,
                  such generality has a cost: encoding higher-level features
                  like functional computation in pi-calculus throws away
                  potentially useful information. We show how a linear type
                  system can be used to recover important static information
                  about a process's behavior. In particular, we can guarantee
                  that two processes communicating over a linear channel
                  cannot interfere with other communicating processes. After
                  developing standard results such as soundness of typing, we
                  focus on equivalences, adapting the standard notion of
                  barbed bisimulation to the linear setting and showing how
                  reductions on linear channels induce a useful ``partial
                  confluence'' of process behaviors. For an extended example
                  of the theory, we prove the validity of a tail-call
                  optimization for higher-order functions represented as
                  processes.},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="SewellWojciechowskiPierce98"></a><pre>
@inproceedings{<a href="plclub.html#SewellWojciechowskiPierce98">SewellWojciechowskiPierce98</a>,
  author = {Peter Sewell and Pawel Wojciechowski and Benjamin Pierce},
  title = {Location Independence for Mobile Agents},
  booktitle = {Proceedings of {ICCL} '98},
  editor = {H. E. Bal and B. Belkhouche and L. Cardelli},
  volume = {1686},
  series = {lncs},
  publisher = {Springer-Verlag},
  month = sep,
  year = {1999},
  note = {An earlier version with title {\em Location-Independent
                  Communication for Mobile Agents: a Two-Level
                  Architecture\/} appeared as Technical Report 462, Computer
                  Laboratory, University of Cambridge, April 1999},
  plclub = {Yes},
  bcp = {Yes},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/wipl.ps">http://www.cis.upenn.edu/~bcpierce/papers/wipl.ps</a>},
  official = {<a href="http://link.springer.de/link/service/series/0558/bibs/1686/16860001.htm">http://link.springer.de/link/service/series/0558/bibs/1686/16860001.htm</a>},
  keys = {mobileagents}
}
</pre>

<a name="SewellWojciechowskiPierce98:TR"></a><pre>
@techreport{<a href="plclub.html#SewellWojciechowskiPierce98:TR">SewellWojciechowskiPierce98:TR</a>,
  author = {Peter Sewell and Pawe{\l} T. Wojciechowski and Benjamin C.
                  Pierce},
  title = {Location-Independent Communication for Mobile Agents: a
                  Two-Level Architecture},
  institution = {Computer Laboratory, University of Cambridge},
  year = {1999},
  number = {462},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="HarmonyRelationsPoster"></a><pre>
@misc{<a href="plclub.html#HarmonyRelationsPoster">HarmonyRelationsPoster</a>,
  author = {Aaron Bohannon and Jeffrey A. Vaughan and 
                  Benjamin C. Pierce},
  title = {Relational Lenses: {A} language for defining 
                  updateable views},
  year = {2005},
  month = oct,
  note = {Poster presented at Greater Philadelphia DB/IR Day},
  bcp = {Yes},
  keys = {harmony},
  pdf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmony-relations-dbir-poster.pdf">http://www.cis.upenn.edu/~bcpierce/papers/harmony-relations-dbir-poster.pdf</a>}
}
</pre>

<a name="BohannonPierceVaughan"></a><pre>
@inproceedings{<a href="plclub.html#BohannonPierceVaughan">BohannonPierceVaughan</a>,
  author = {Aaron Bohannon and Jeffrey A. Vaughan and 
                  Benjamin C. Pierce},
  title = {Relational Lenses: {A} Language for Updateable Views},
  year = {2006},
  booktitle = {Principles of Database Systems (PODS)},
  note = {Extended version available as University of Pennsylvania
                  technical report MS-CIS-05-27},
  bcp = {Yes},
  plclub = {Yes},
  keys = {harmony},
  pdf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/dblenses-pods.pdf">http://www.cis.upenn.edu/~bcpierce/papers/dblenses-pods.pdf</a>},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/dblenses-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/dblenses-tr.pdf</a>}
}
</pre>

<a name="SahuguetPierceTannen2000"></a><pre>
@misc{<a href="plclub.html#SahuguetPierceTannen2000">SahuguetPierceTannen2000</a>,
  author = {Arnaud Sahuguet and Benjamin Pierce and Val Tannen},
  title = {Chaining, Referral, Subscription, Leasing: New Mechanisms
                  in Distributed Query Optimization},
  month = feb,
  year = {2000},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="SahuguetPierceTannen2000a"></a><pre>
@misc{<a href="plclub.html#SahuguetPierceTannen2000a">SahuguetPierceTannen2000a</a>,
  author = {Arnaud Sahuguet and Benjamin Pierce and Val Tannen},
  title = {Distributed Query Optimization: Can Mobile Agents Help?},
  month = feb,
  year = {2000},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="SewellWojciechowskiPierce98:old"></a><pre>
@inproceedings{<a href="plclub.html#SewellWojciechowskiPierce98:old">SewellWojciechowskiPierce98:old</a>,
  author = {Peter Sewell and Pawel T. Wojciechowski and Benjamin C.
                  Pierce},
  title = {Location Independence for Mobile Agents},
  year = 2000,
  note = {To appear in an edited collection of papers (in Springer
                  LNCS) from the {\em Workshop on Internet Programming
                  Languages}, June 1998, Loyola University},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce:ICFP-invited"></a><pre>
@misc{<a href="plclub.html#Pierce:ICFP-invited">Pierce:ICFP-invited</a>,
  author = {Benjamin C. Pierce},
  title = {Module Systems: A Guide for the Perplexed},
  month = sep,
  year = {2000},
  note = {Invited talk at {\em ICFP}, Montreal},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="IgarashiPierce99:FJI"></a><pre>
@article{<a href="plclub.html#IgarashiPierce99:FJI">IgarashiPierce99:FJI</a>,
  author = {Atsushi Igarashi and Benjamin C. Pierce},
  title = {On Inner Classes},
  journal = {Information and Computation},
  year = 2002,
  volume = 177,
  number = 1,
  pages = {56--89},
  month = aug,
  note = {A special issue with papers from the 7th International Workshop on Foundations of Object-Oriented Languages (FOOL){\rm, informal proceedings}.  An earlier 
                  version appeared in \emph \bgroup Proceedings of the 14th European Conference on Object-Oriented Programming (ECOOP)\egroup, Springer LNCS 1850, pages
                  129--153},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/fji.ps">http://www.cis.upenn.edu/~bcpierce/fji.ps</a>},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/fji-tr.ps">http://www.cis.upenn.edu/~bcpierce/fji-tr.ps</a>}
}
</pre>

<a name="PierceTurner:PictDesign"></a><pre>
@incollection{<a href="plclub.html#PierceTurner:PictDesign">PierceTurner:PictDesign</a>,
  author = {Benjamin C. Pierce and David N. Turner},
  title = {Pict: A Programming Language Based on the Pi-Calculus},
  year = {2000},
  booktitle = {Proof, Language and Interaction: Essays in Honour of Robin
                  Milner},
  editor = {Gordon Plotkin and Colin Stirling and Mads Tofte},
  publisher = {MIT Press},
  pages = {455--494},
  checked = {Yes},
  plclub = {Yes},
  bcp = {Yes},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pict-design.ps">http://www.cis.upenn.edu/~bcpierce/papers/pict-design.ps</a>},
  keys = {pict}
}
</pre>

<a name="GapeyevLevinPierce2000"></a><pre>
@article{<a href="plclub.html#GapeyevLevinPierce2000">GapeyevLevinPierce2000</a>,
  author = {Vladimir Gapeyev and Michael Levin and Benjamin Pierce},
  title = {Recursive Subtyping Revealed},
  journal = {Journal of Functional Programming},
  volume = 12,
  number = 6,
  pages = {511--548},
  checked = {Yes},
  year = {2003},
  plclub = {Yes},
  bcp = {Yes},
  keys = {subtyping},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/rsr.ps">http://www.cis.upenn.edu/~bcpierce/papers/rsr.ps</a>},
  note = {Preliminary version in {\em International Conference on
                  Functional Programming (ICFP)}, 2000.  Also appears as
                  Chapter 21 of {\em Types and Programming Languages}
                  by Benjamin C. Pierce (MIT Press, 2002).}
}
</pre>

<a name="GapeyevLevinPierce2000:ICFP"></a><pre>
@inproceedings{<a href="plclub.html#GapeyevLevinPierce2000:ICFP">GapeyevLevinPierce2000:ICFP</a>,
  author = {Vladimir Gapeyev and Michael Levin and Benjamin Pierce},
  title = {Recursive Subtyping Revealed},
  booktitle = {{ACM} {SIGPLAN} {I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP}), Montreal, Canada},
  year = {2000},
  plclub = {Yes},
  bcp = {Yes},
  note = {To appear in {\em Journal of Functional Programming}}
}
</pre>

<a name="PierceSumii00"></a><pre>
@misc{<a href="plclub.html#PierceSumii00">PierceSumii00</a>,
  author = {Benjamin Pierce and Eijiro Sumii},
  title = {Relating Cryptography and Polymorphism},
  month = jul,
  year = {2000},
  plclub = {Yes},
  bcp = {Yes},
  note = {Some parts superseded by \cite{SumiiPierce01} (Sumii and Pierce, 2001)},
  keys = {security},
  manuscript = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide.ps">http://www.cis.upenn.edu/~bcpierce/papers/infohide.ps</a>}
}
</pre>

<a name="LevinPierce99:OLD1"></a><pre>
@techreport{<a href="plclub.html#LevinPierce99:OLD1">LevinPierce99:OLD1</a>,
  author = {Michael Y. Levin and Benjamin C. Pierce},
  title = {TinkerType: {A} Language for Playing with Formal Systems},
  month = jun,
  year = {2000},
  booktitle = {Logical Frameworks and Metalanguages},
  note = {Invited talk (submitted for journal publication)},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="HosoyaPierce2000"></a><pre>
@inproceedings{<a href="plclub.html#HosoyaPierce2000">HosoyaPierce2000</a>,
  author = {Haruo Hosoya and Benjamin C. Pierce},
  title = {{XDuce}: A Typed {XML} Processing Language (Preliminary
                  Report)},
  booktitle = {International Workshop on the Web and Databases (WebDB)},
  editor = {Dan Suciu and Gottfried Vossen},
  month = may,
  year = {2000},
  note = {Reprinted in {\em The Web and Databases, Selected Papers},
                  Springer LNCS volume 1997, 2001},
  keys = {xduce},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xduce-prelim.ps">http://www.cis.upenn.edu/~bcpierce/papers/xduce-prelim.ps</a>},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="IgarashiPierceWadler01"></a><pre>
@inproceedings{<a href="plclub.html#IgarashiPierceWadler01">IgarashiPierceWadler01</a>,
  author = {Atsushi Igarashi and Benjamin C. Pierce and Philip Wadler},
  title = {A Recipe for Raw Types},
  year = 2001,
  booktitle = {Workshop on Foundations of Object-Oriented Languages
                  (FOOL)},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/rfgj.ps">http://www.cis.upenn.edu/~bcpierce/papers/rfgj.ps</a>}
}
</pre>

<a name="BruceCardelliPierce96"></a><pre>
@article{<a href="plclub.html#BruceCardelliPierce96">BruceCardelliPierce96</a>,
  author = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
  title = {Comparing Object Encodings},
  journal = {Information and Computation},
  year = 1999,
  month = nov,
  volume = 155,
  number = {1/2},
  pages = {108--133},
  note = {Special issue of papers from {\em
                  Theoretical Aspects of Computer Software (TACS 1997)}.
                  An earlier version appeared as an invited
                  lecture in the Third International Workshop on Foundations
                  of Object Oriented Languages (FOOL 3), July 1996},
  plclub = {Yes},
  bcp = {Yes},
  keys = {oop},
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/compobj.ps">http://www.cis.upenn.edu/~bcpierce/papers/compobj.ps</a>}
}
</pre>

<a name="JimPierceVouillon:UnisonSys"></a><pre>
@unpublished{<a href="plclub.html#JimPierceVouillon:UnisonSys">JimPierceVouillon:UnisonSys</a>,
  author = {Trevor Jim and Benjamin C. Pierce and J\'er\^ome Vouillon},
  title = {How to Build a File Synchronizer},
  year = {2003},
  note = {Manuscript},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="SumiiPierce01"></a><pre>
@article{<a href="plclub.html#SumiiPierce01">SumiiPierce01</a>,
  author = {Eijiro Sumii and Benjamin C. Pierce},
  title = {Logical Relations for Encryption},
  journal = {Journal of Computer Security},
  year = {2003},
  volume = {11},
  number = {4},
  pages = {521--554},
  plclub = {Yes},
  bcp = {Yes},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide2.ps">http://www.cis.upenn.edu/~bcpierce/papers/infohide2.ps</a>},
  keys = {security},
  note = {Extended abstract appeared in {\emph{14th IEEE Computer Security Foundations Workshop}}, pp.~256--269, 2001.}
}
</pre>

<a name="HosoyaPierce2001"></a><pre>
@inproceedings{<a href="plclub.html#HosoyaPierce2001">HosoyaPierce2001</a>,
  author = {Haruo Hosoya and Benjamin C. Pierce},
  title = {Regular Expression Pattern Matching},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), London, England},
  year = {2001},
  plclub = {Yes},
  bcp = {Yes},
  checked = {Yes},
  note = {Full version in {\em Journal of
                  Functional Programming}, 13(6), Nov. 2003, pp. 961--1004},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tapat.ps">http://www.cis.upenn.edu/~bcpierce/papers/tapat.ps</a>},
  keys = {xduce}
}
</pre>

<a name="HosoyaVouillonPierce2000"></a><pre>
@article{<a href="plclub.html#HosoyaVouillonPierce2000">HosoyaVouillonPierce2000</a>,
  author = {Haruo Hosoya and J\'er\^ome Vouillon and Benjamin C.
                  Pierce},
  title = {Regular Expression Types for {XML}},
  journal = {ACM Transactions on Programming Languages and Systems
                  (TOPLAS)},
  year = {2005},
  month = jan,
  volume = 27,
  number = 1,
  pages = {46--90},
  note = {Preliminary version in ICFP 2000},
  plclub = {Yes},
  bcp = {Yes},
  checked = {Yes},
  keys = {xduce},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/regsub.ps">http://www.cis.upenn.edu/~bcpierce/papers/regsub.ps</a>},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/regsub-toplas.pdf">http://www.cis.upenn.edu/~bcpierce/papers/regsub-toplas.pdf</a>}
}
</pre>

<a name="HosoyaPierce2002"></a><pre>
@article{<a href="plclub.html#HosoyaPierce2002">HosoyaPierce2002</a>,
  author = {Haruo Hosoya and Benjamin C. Pierce},
  title = {{XDuce}: A Statically Typed {XML} Processing Language},
  journal = {ACM Transactions on Internet Technology},
  year = {2003},
  volume = 3,
  number = 2,
  month = may,
  pages = {117--148},
  checked = {Yes},
  official = {<a href="http://doi.acm.org/10.1145/767193.767195">http://doi.acm.org/10.1145/767193.767195</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {xduce}
}
</pre>

<a name="Pierce-Sumii-01"></a><pre>
@inproceedings{<a href="plclub.html#Pierce-Sumii-01">Pierce-Sumii-01</a>,
  author = {Eijiro Sumii and Benjamin Pierce},
  title = {The Cryptographic {$\lambda$}-Calculus: Syntax, Semantics,
                  Type System and Logical Relation (in Japanese)},
  booktitle = {Informal Proceedings of JSSST Workshop on Programming and 
                  Programming Languages (PPL2001)},
  year = {2001},
  note = {Best paper prize},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="XtaticCompiler"></a><pre>
@misc{<a href="plclub.html#XtaticCompiler">XtaticCompiler</a>,
  author = {Vladimir Gapeyev and Michael Y. Levin and Benjamin C. Pierce and Alan Schmitt},
  title = {The {X}tatic Compiler and Runtime System},
  year = {2005},
  plclub = {Yes},
  bcp = {Yes},
  keys = {xtatic},
  sources = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic.tgz">http://www.cis.upenn.edu/~bcpierce/papers/xtatic.tgz</a>}
}
</pre>

<a name="LevinThesis"></a><pre>
@phdthesis{<a href="plclub.html#LevinThesis">LevinThesis</a>,
  author = {Michael Y. Levin},
  title = {Run, Xtatic, Run: Efficient Implementation of an Object-Oriented
                  Language with Regular Pattern Matching},
  school = {University of Pennsylvania},
  year = {2005},
  bcp = {Yes},
  keys = {xtatic},
  plclub = {Yes},
  pdf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/levin-thesis.pdf">http://www.cis.upenn.edu/~bcpierce/papers/levin-thesis.pdf</a>}
}
</pre>

<a name="GapeyevPierce03"></a><pre>
@inproceedings{<a href="plclub.html#GapeyevPierce03">GapeyevPierce03</a>,
  author = {Vladimir Gapeyev and Benjamin C. Pierce},
  title = {Regular Object Types},
  booktitle = {European Conference on Object-Oriented Programming (ECOOP), Darmstadt, Germany},
  year = {2003},
  note = {A preliminary version was presented at FOOL '03},
  plclub = {Yes},
  bcp = {Yes},
  keys = {xtatic},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/regobj.pdf">http://www.cis.upenn.edu/~bcpierce/papers/regobj.pdf</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/regobj-ecoop-slides.ps">http://www.cis.upenn.edu/~bcpierce/papers/regobj-ecoop-slides.ps</a>}
}
</pre>

<a name="LevinPierce99"></a><pre>
@article{<a href="plclub.html#LevinPierce99">LevinPierce99</a>,
  author = {Michael Y. Levin and Benjamin C. Pierce},
  title = {TinkerType: {A} Language for Playing with Formal Systems},
  journal = {Journal of Functional Programming},
  volume = 13,
  number = 2,
  month = mar,
  year = {2003},
  note = {A preliminary version appeared as an invited
                  paper at the {\em Logical Frameworks and Metalanguages
                  Workshop (LFM)}, June 2000},
  plclub = {Yes},
  bcp = {Yes},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tt-jfp.pdf">http://www.cis.upenn.edu/~bcpierce/papers/tt-jfp.pdf</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tt-slides.ps">http://www.cis.upenn.edu/~bcpierce/papers/tt-slides.ps</a>},
  sources = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tt.tar.gz">http://www.cis.upenn.edu/~bcpierce/papers/tt.tar.gz</a>},
  keys = {modular}
}
</pre>

<a name="PierceVouillon:UnisonSpec"></a><pre>
@unpublished{<a href="plclub.html#PierceVouillon:UnisonSpec">PierceVouillon:UnisonSpec</a>,
  author = {Benjamin C. Pierce and J\'er\^ome Vouillon},
  title = {Unison: A File Synchronizer and its Specification},
  year = {2001},
  note = {Manuscript},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="PierceVouillon:UnisonSpecTR"></a><pre>
@techreport{<a href="plclub.html#PierceVouillon:UnisonSpecTR">PierceVouillon:UnisonSpecTR</a>,
  author = {Benjamin C. Pierce and J\'er\^ome Vouillon},
  title = {What's in {U}nison? {A} Formal
                  Specification and Reference Implementation 
                  of a File Synchronizer},
  year = {2004},
  institution = {Dept. of Computer and Information Science, University of Pennsylvania},
  number = {MS-CIS-03-36},
  plclub = {Yes},
  bcp = {Yes},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/unisonspec.pdf">http://www.cis.upenn.edu/~bcpierce/papers/unisonspec.pdf</a>},
  keys = {unison}
}
</pre>

<a name="Pierce:TypeSystems"></a><pre>
@book{<a href="plclub.html#Pierce:TypeSystems">Pierce:TypeSystems</a>,
  author = {Benjamin C. Pierce},
  title = {Types and Programming Languages},
  publisher = {MIT Press},
  year = 2002,
  plclub = {Yes},
  bcp = {Yes},
  keys = {books},
  homepage = {<a href="http://www.cis.upenn.edu/~bcpierce/tapl">http://www.cis.upenn.edu/~bcpierce/tapl</a>},
  errata = {<a href="http://www.cis.upenn.edu/~bcpierce/tapl/errata.txt">http://www.cis.upenn.edu/~bcpierce/tapl/errata.txt</a>}
}
</pre>

<a name="ATTAPL"></a><pre>
@book{<a href="plclub.html#ATTAPL">ATTAPL</a>,
  editor = {Benjamin C. Pierce},
  title = {Advanced Topics in Types and Programming Languages},
  publisher = {MIT Press},
  year = 2005,
  plclub = {Yes},
  bcp = {Yes},
  keys = {books},
  homepage = {<a href="http://www.cis.upenn.edu/~bcpierce/attapl">http://www.cis.upenn.edu/~bcpierce/attapl</a>}
}
</pre>

<a name="ISSS2002"></a><pre>
@proceedings{<a href="plclub.html#ISSS2002">ISSS2002</a>,
  title = {Software Security -- Theories and Systems},
  editor = {M. Okada and B. Pierce and A. Scedrov and H. Tokuda 
                  and A. Yonezawa},
  series = {Lecture Notes in Computer Science},
  number = {2609},
  publisher = {Springer-Verlag},
  optaddress = {Berlin},
  year = {2003},
  note = {Revised papers from the Mext-NSF-JSPS {\em International 
                  Symposium on Software Security}, Tokyo, Japan, 
                  November 8-10, 2002},
  isbn = {3-540-00708-3},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="TACS2001"></a><pre>
@proceedings{<a href="plclub.html#TACS2001">TACS2001</a>,
  title = {Theoretical Aspects of
                  Computer Software (TACS), 4th International Symposium},
  editor = {Naoki Kobayashi and Benjamin C. Pierce},
  series = {Lecture Notes in Computer Science},
  number = {2215},
  publisher = {Springer-Verlag},
  optaddress = {Berlin},
  year = {2001},
  location = {Sendai, Japan, October 29-31, 2001},
  isbn = {3-540-42736-8},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="nwaysync"></a><pre>
@inproceedings{<a href="plclub.html#nwaysync">nwaysync</a>,
  booktitle = {International Symposium on Distributed Computing (DISC)},
  editor = {Shlomi Dolev},
  author = {Michael B. Greenwald and Sanjeev Khanna and 
                  Keshav Kunal and Benjamin C. Pierce and Alan Schmitt},
  title = {Agreeing to Agree: {C}onflict Resolution for
                  Optimistically Replicated Data},
  keys = {unison},
  plclub = {Yes},
  bcp = {Yes},
  year = 2006,
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/nway-disc.pdf">http://www.cis.upenn.edu/~bcpierce/papers/nway-disc.pdf</a>},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/nway-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/nway-tr.pdf</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/nway-disc-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/nway-disc-slides.pdf</a>}
}
</pre>

<a name="diff3"></a><pre>
@inproceedings{<a href="plclub.html#diff3">diff3</a>,
  author = {Sanjeev Khanna and Keshav Kunal and Benjamin C. Pierce},
  title = {A Formal Investigation of Diff3},
  year = 2007,
  month = dec,
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf">http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {unison},
  booktitle = {Foundations of Software Technology and Theoretical Computer Science (FSTTCS)},
  editor = {Arvind and Prasad}
}
</pre>

<a name="Focal2005-long"></a><pre>
@article{<a href="plclub.html#Focal2005-long">Focal2005-long</a>,
  author = {J. Nathan Foster and Michael B. Greenwald and Jonathan T. Moore 
                  and Benjamin C. Pierce and Alan Schmitt},
  title = {Combinators for bidirectional tree transformations: 
                  {A} linguistic approach to the view-update problem},
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {29},
  number = {3},
  pages = {17},
  month = may,
  year = {2007},
  publisher = {ACM Press},
  address = {New York, NY, USA},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl.pdf">http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl.pdf</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl-slides.pdf</a>},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lenses-toplas-final.pdf">http://www.cis.upenn.edu/~bcpierce/papers/lenses-toplas-final.pdf</a>},
  fullappendix = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lenses-toplas-electronic-appendix.pdf">http://www.cis.upenn.edu/~bcpierce/papers/lenses-toplas-electronic-appendix.pdf</a>},
  doi = {<a href="http://portal.acm.org/citation.cfm?doid=1232420.1232424">http://portal.acm.org/citation.cfm?doid=1232420.1232424</a>},
  note = {Preliminary version presented at 
                  the {\em Workshop on Programming Language Technologies for 
                  XML (PLAN-X)}, 2004; extended abstract presented at 
                  {\em Principles of Programming Languages (POPL)}, 2005},
  bcp = {Yes},
  plclub = {Yes},
  keys = {harmony}
}
</pre>

<a name="Pierce:NEPLS2004"></a><pre>
@misc{<a href="plclub.html#Pierce:NEPLS2004">Pierce:NEPLS2004</a>,
  author = {Benjamin C. Pierce},
  title = {Combinators for Bi-Directional Tree Transformations: 
                  {A} Linguistic Approach to the View Update Problem},
  month = oct,
  year = 2004,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/newlenses-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/newlenses-slides.pdf</a>},
  note = {Invited talk at {\em New England Programming Languages Symposium}},
  plclub = {Yes},
  bcp = {Yes},
  keys = {harmony}
}
</pre>

<a name="Pierce:LinksTalk2005"></a><pre>
@misc{<a href="plclub.html#Pierce:LinksTalk2005">Pierce:LinksTalk2005</a>,
  author = {Benjamin C. Pierce},
  title = {Fancy Types for XML: Friend or Foe?},
  month = apr,
  year = 2005,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/linkstalk-200504.pdf">http://www.cis.upenn.edu/~bcpierce/papers/linkstalk-200504.pdf</a>},
  note = {Talk at {\em LINKS} workshop, April 2005},
  plclub = {Yes},
  bcp = {Yes},
  keys = {xtatic}
}
</pre>

<a name="Pierce:HarmonyTalkTGC"></a><pre>
@misc{<a href="plclub.html#Pierce:HarmonyTalkTGC">Pierce:HarmonyTalkTGC</a>,
  author = {Benjamin C. Pierce},
  title = {Harmony: {T}he Art of Reconciliation},
  month = apr,
  year = 2005,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmony-tgc-talk-2005.pdf">http://www.cis.upenn.edu/~bcpierce/papers/harmony-tgc-talk-2005.pdf</a>},
  note = {Invited talk at {\em Trusted Global Computing} conference, 
                  April 2005},
  plclub = {Yes},
  bcp = {Yes},
  keys = {unison}
}
</pre>

<a name="Pierce:HarmonyTalk2003"></a><pre>
@misc{<a href="plclub.html#Pierce:HarmonyTalk2003">Pierce:HarmonyTalk2003</a>,
  author = {Benjamin C. Pierce},
  title = {Harmony: A Synchronization Framework for Tree-Structured Data},
  month = sep,
  year = 2003,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmonyslides-2003aug.pdf">http://www.cis.upenn.edu/~bcpierce/papers/harmonyslides-2003aug.pdf</a>},
  note = {Slides from a talk presented in several places
                  (Cambridge, Edinburgh, 
                  Philadelphia, Princeton) in Fall 2003},
  plclub = {Yes},
  bcp = {Yes},
  keys = {unison}
}
</pre>

<a name="Pierce:ETAPSTalk2006"></a><pre>
@misc{<a href="plclub.html#Pierce:ETAPSTalk2006">Pierce:ETAPSTalk2006</a>,
  author = {Benjamin C. Pierce},
  title = {The Weird World of Bi-Directional Programming},
  month = mar,
  year = 2006,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lenses-etapsslides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/lenses-etapsslides.pdf</a>},
  note = {ETAPS invited talk},
  plclub = {Yes},
  bcp = {Yes},
  keys = {harmony}
}
</pre>

<a name="PierceFSTTCS07"></a><pre>
@misc{<a href="plclub.html#PierceFSTTCS07">PierceFSTTCS07</a>,
  author = {Benjamin C. Pierce},
  title = {Adventures in Bi-Directional Programming},
  month = dec,
  year = 2007,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/boomerang-fsttcs.pdf">http://www.cis.upenn.edu/~bcpierce/papers/boomerang-fsttcs.pdf</a>},
  note = {FSTTCS invited talk},
  plclub = {Yes},
  bcp = {Yes},
  keys = {harmony}
}
</pre>

<a name="Pierce:MFPSTalk2008"></a><pre>
@misc{<a href="plclub.html#Pierce:MFPSTalk2008">Pierce:MFPSTalk2008</a>,
  author = {Benjamin C. Pierce},
  title = {Types Considered Harmful},
  month = may,
  year = 2008,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmful-mfps.pdf">http://www.cis.upenn.edu/~bcpierce/papers/harmful-mfps.pdf</a>},
  note = {Invited talk at {\em Mathematical Foundations 
                  of Programming Semantics (MFPS)}},
  plclub = {Yes},
  bcp = {Yes},
  keys = {typessurveys,contracts}
}
</pre>

<a name="Pierce:Onward2010"></a><pre>
@misc{<a href="plclub.html#Pierce:Onward2010">Pierce:Onward2010</a>,
  author = {Benjamin C. Pierce},
  title = {creativity: sensitivity and surprise},
  month = oct,
  year = 2010,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/cgi-bin/photos/Onward.pdf">http://www.cis.upenn.edu/~bcpierce/cgi-bin/photos/Onward.pdf</a>},
  note = {Keynote talk at {\em SPLASH / Onward!}},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc}
}
</pre>

<a name="Pierce:EPFLTalk2002"></a><pre>
@misc{<a href="plclub.html#Pierce:EPFLTalk2002">Pierce:EPFLTalk2002</a>,
  author = {Benjamin C. Pierce},
  title = {Synchronize globally, compute locally},
  month = jul,
  year = 2002,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmonyslides-epfl.ps">http://www.cis.upenn.edu/~bcpierce/papers/harmonyslides-epfl.ps</a>},
  note = {Keynote address at {\em Research Day on Global Computing}, 
                  EFPL, Lausanne},
  plclub = {Yes},
  bcp = {Yes},
  keys = {unison}
}
</pre>

<a name="HocusFocusTR2003-old"></a><pre>
@techreport{<a href="plclub.html#HocusFocusTR2003-old">HocusFocusTR2003-old</a>,
  author = {Michael B. Greenwald and Jonathan T. Moore and Benjamin C. Pierce
                  and Alan Schmitt},
  title = {A Language for Bi-Directional Tree Transformations},
  year = 2003,
  type = {Technical Report},
  number = {MS-CIS-03-08},
  institution = {               University of Pennsylvania},
  plclub = {Yes},
  bcp = {Yes},
  note = {Revised April 2004}
}
</pre>

<a name="HarmonyOverview"></a><pre>
@techreport{<a href="plclub.html#HarmonyOverview">HarmonyOverview</a>,
  author = {Benjamin C. Pierce and Alan Schmitt and Michael B. Greenwald},
  title = {Bringing {H}armony to Optimism:
                  {A} Synchronization Framework for Heterogeneous 
                  Tree-Structured Data},
  year = 2003,
  type = {Technical Report},
  number = {MS-CIS-03-42},
  institution = {University of Pennsylvania},
  plclub = {Yes},
  bcp = {Yes},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmony-sync-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/harmony-sync-tr.pdf</a>},
  keys = {unison},
  note = {Superseded by MS-CIS-05-02}
}
</pre>

<a name="SYNCTR2005"></a><pre>
@techreport{<a href="plclub.html#SYNCTR2005">SYNCTR2005</a>,
  author = {J. Nathan Foster and Michael B. Greenwald and Christian Kirkegaard
                  and Benjamin C. Pierce and Alan Schmitt},
  title = {Schema-Directed Data Synchronization},
  month = mar,
  year = 2005,
  type = {Technical Report},
  number = {MS-CIS-05-02},
  institution = {University of Pennsylvania},
  note = {Supersedes MS-CIS-03-42},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/sync-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/sync-tr.pdf</a>},
  bcp = {Yes},
  keys = {unison}
}
</pre>

<a name="SYNC2005"></a><pre>
@article{<a href="plclub.html#SYNC2005">SYNC2005</a>,
  author = {J. Nathan Foster and Michael B. Greenwald and Christian Kirkegaard
                  and Benjamin C. Pierce and Alan Schmitt},
  title = {Exploiting Schemas in Data Synchronization},
  journal = {Journal of Computer and System Sciences},
  volume = {73},
  number = {4},
  pages = {669--689},
  year = 2007,
  note = {Extended abstract in 
                  {\em Database Programming Languages (DBPL)} 2005},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/sync-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/sync-tr.pdf</a>},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/sync-dbpl.pdf">http://www.cis.upenn.edu/~bcpierce/papers/sync-dbpl.pdf</a>},
  slides = {<a href="http://www.cis.upenn.edu/~jnfoster/papers/schema-sync-slides.pdf">http://www.cis.upenn.edu/~jnfoster/papers/schema-sync-slides.pdf</a>},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/sync-jcss.pdf">http://www.cis.upenn.edu/~bcpierce/papers/sync-jcss.pdf</a>},
  keys = {harmony},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="HocusFocus2003"></a><pre>
@unpublished{<a href="plclub.html#HocusFocus2003">HocusFocus2003</a>,
  author = {Michael B. Greenwald and Jonathan T. Moore 
                  and Benjamin C. Pierce and Alan Schmitt},
  title = {A Language for Bi-Directional Tree Transformations},
  year = 2003,
  institution = {Department of Computer and Information Science, University of Pennsylvania},
  note = {Manuscript; available at \url{http://www.cis.upenn.edu/~bcpierce/papers/lenses.pdf}},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="SumiiPierce2004"></a><pre>
@inproceedings{<a href="plclub.html#SumiiPierce2004">SumiiPierce2004</a>,
  author = {Eijiro Sumii and Benjamin C. Pierce},
  title = {A Bisimulation for Dynamic Sealing},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Venice, Italy},
  year = {2004},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide3.pdf">http://www.cis.upenn.edu/~bcpierce/papers/infohide3.pdf</a>},
  note = {Full version in {\em Theoretical Computer Science} 375 (2007), 169--192}
}
</pre>

<a name="SumiiPierce2005"></a><pre>
@inproceedings{<a href="plclub.html#SumiiPierce2005">SumiiPierce2005</a>,
  author = {Eijiro Sumii and Benjamin C. Pierce},
  title = {A Bisimulation for Type Abstraction and Recursion},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Long Beach, California},
  year = {2005},
  keys = {security},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide5-popl.pdf">http://www.cis.upenn.edu/~bcpierce/papers/infohide5-popl.pdf</a>},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide5-jacm.pdf">http://www.cis.upenn.edu/~bcpierce/papers/infohide5-jacm.pdf</a>},
  plclub = {Yes},
  bcp = {Yes},
  note = {Full version in {\em J. ACM}, 54 (5), 2007}
}
</pre>

<a name="XtaticRuntime"></a><pre>
@inproceedings{<a href="plclub.html#XtaticRuntime">XtaticRuntime</a>,
  title = {{XML} Goes Native: {R}un-time Representations for {Xtatic}},
  author = {Vladimir Gapeyev and Michael Y. Levin
                  and Benjamin C. Pierce and Alan Schmitt},
  year = 2005,
  month = apr,
  booktitle = {14th International Conference on Compiler Construction},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-runtime-CC.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-runtime-CC.pdf</a>},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-runtime-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-runtime-TR.pdf</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {xtatic}
}
</pre>

<a name="XTProgr"></a><pre>
@inproceedings{<a href="plclub.html#XTProgr">XTProgr</a>,
  title = {Statically Typed Document Transformation: {A}n {Xtatic} Experience},
  author = {Vladimir Gapeyev and Fran\c{c}ois Garillot and Benjamin C. Pierce},
  year = 2006,
  month = jan,
  booktitle = {Workshop on Programming Language Technologies for XML (PLAN-X), informal proceedings},
  pdf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtprogr-planx.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtprogr-planx.pdf</a>},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtprogr-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtprogr-tr.pdf</a>},
  keys = {xtatic},
  bcp = {Yes},
  plclub = {Yes},
  note = {Available from the Xtatic web site}
}
</pre>

<a name="XtaticExperience"></a><pre>
@inproceedings{<a href="plclub.html#XtaticExperience">XtaticExperience</a>,
  title = {The {Xtatic} Experience},
  author = {Vladimir Gapeyev and Michael Y. Levin 
                  and Benjamin C. Pierce and Alan Schmitt},
  booktitle = {Workshop on Programming Language Technologies for XML (PLAN-X)},
  plclub = {Yes},
  bcp = {Yes},
  month = jan,
  year = 2005,
  note = {University of Pennsylvania 
                  Technical Report MS-CIS-04-24, Oct 2004},
  keys = {xtatic},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-experience-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-experience-TR.pdf</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-experience-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-experience-slides.pdf</a>}
}
</pre>

<a name="GapeyevPierce2004"></a><pre>
@techreport{<a href="plclub.html#GapeyevPierce2004">GapeyevPierce2004</a>,
  title = {Paths into Patterns},
  author = {Vladimir Gapeyev and Benjamin C. Pierce},
  year = 2004,
  month = oct,
  type = {Technical Report},
  number = {MS-CIS-04-25},
  institution = {University of Pennsylvania},
  plclub = {Yes},
  bcp = {Yes},
  keys = {xtatic},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-pathambig-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-pathambig-TR.pdf</a>}
}
</pre>

<a name="LevinPierce05"></a><pre>
@inproceedings{<a href="plclub.html#LevinPierce05">LevinPierce05</a>,
  title = {Type-based Optimization for Regular Patterns},
  author = {Michael Y. Levin and Benjamin C. Pierce},
  booktitle = {Database Programming Languages (DBPL)},
  year = 2005,
  month = aug,
  bcp = {Yes},
  plclub = {Yes},
  keys = {xtatic},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tb-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/tb-TR.pdf</a>}
}
</pre>

<a name="ICFP05"></a><pre>
@proceedings{<a href="plclub.html#ICFP05">ICFP05</a>,
  title = {International Conference on Functional Programming (ICFP)},
  editor = {Benjamin C. Pierce},
  publisher = {ACM Press},
  year = {2005},
  location = {Tallinn, Estonia, September 2005},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="POPL09"></a><pre>
@proceedings{<a href="plclub.html#POPL09">POPL09</a>,
  title = {Principles of Programming Languages (POPL)},
  editor = {Benjamin C. Pierce},
  publisher = {ACM Press},
  year = {2009},
  location = {Savannah, Georgia, January 2009},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Foster:FTL"></a><pre>
@inproceedings{<a href="plclub.html#Foster:FTL">Foster:FTL</a>,
  author = {J. Nathan Foster and Benjamin C. Pierce and Alan Schmitt},
  title = {A Logic Your Typechecker Can Count On: {U}nordered Tree Types in Practice},
  booktitle = {Workshop on Programming Language Technologies for XML (PLAN-X), informal proceedings},
  year = {2007},
  month = jan,
  bcp = {Yes},
  keys = {harmony},
  plclub = {Yes},
  conf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/dtts.pdf">http://www.cis.upenn.edu/~bcpierce/papers/dtts.pdf</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/dtts-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/dtts-slides.pdf</a>}
}
</pre>

<a name="Kennedy06"></a><pre>
@misc{<a href="plclub.html#Kennedy06">Kennedy06</a>,
  author = {Andrew J. Kennedy and Benjamin C. Pierce},
  title = {On Decidability of Nominal Subtyping with Variance},
  year = {2006},
  month = sep,
  bcp = {Yes},
  keys = {oop,subtyping},
  plclub = {Yes},
  note = {FOOL-WOOD '07},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/variance.pdf">http://www.cis.upenn.edu/~bcpierce/papers/variance.pdf</a>}
}
</pre>

<a name="Aydemir08"></a><pre>
@inproceedings{<a href="plclub.html#Aydemir08">Aydemir08</a>,
  author = {Brian Aydemir and Arthur Chargu\'{e}raud and Benjamin C. Pierce and Randy Pollack and Stephanie Weirich},
  title = {Engineering formal metatheory},
  pages = {3--15},
  publisher = {ACM},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), San Francisco, California},
  year = {2008},
  month = jan,
  bcp = {Yes},
  keys = {verification},
  plclub = {Yes},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/binders.pdf">http://www.cis.upenn.edu/~bcpierce/papers/binders.pdf</a>}
}
</pre>

<a name="Greenberg10"></a><pre>
@inproceedings{<a href="plclub.html#Greenberg10">Greenberg10</a>,
  author = {Michael Greenberg and Benjamin C. Pierce and Stephanie Weirich},
  title = {Contracts Made Manifest},
  year = {2010},
  publisher = {ACM},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Madrid, Spain},
  month = jan,
  bcp = {Yes},
  keys = {contracts},
  plclub = {Yes},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/contracts-popl.pdf">http://www.cis.upenn.edu/~bcpierce/papers/contracts-popl.pdf</a>}
}
</pre>

<a name="Pierce08LambdaTA"></a><pre>
@misc{<a href="plclub.html#Pierce08LambdaTA">Pierce08LambdaTA</a>,
  author = {Benjamin C. Pierce},
  title = {Using a Proof Assistant to Teach Programming Language Foundations, or, 
                  {L}ambda, the Ultimate {TA}},
  year = {2008},
  month = apr,
  bcp = {Yes},
  keys = {verification},
  plclub = {Yes},
  note = {White paper},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/plcurriculum.pdf">http://www.cis.upenn.edu/~bcpierce/papers/plcurriculum.pdf</a>}
}
</pre>

<a name="QuotientLenses08"></a><pre>
@inproceedings{<a href="plclub.html#QuotientLenses08">QuotientLenses08</a>,
  author = {J. Nathan Foster and Alexandre Pilkiewicz and Benjamin
                  C. Pierce},
  title = {Quotient Lenses},
  booktitle = {{ACM} {SIGPLAN} {I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP}), Victoria, Canada},
  year = {2008},
  month = sep,
  bcp = {Yes},
  keys = {harmony},
  plclub = {Yes},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/quotient-lenses.pdf">http://www.cis.upenn.edu/~bcpierce/papers/quotient-lenses.pdf</a>}
}
</pre>

<a name="Boomerang07"></a><pre>
@inproceedings{<a href="plclub.html#Boomerang07">Boomerang07</a>,
  author = {Aaron Bohannon and J. Nathan Foster and Benjamin C. Pierce and Alexandre Pilkiewicz and Alan Schmitt},
  title = {Boomerang: Resourceful Lenses for String Data},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), San Francisco, California},
  year = {2008},
  month = jan,
  bcp = {Yes},
  keys = {harmony},
  plclub = {Yes},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/boomerang.pdf">http://www.cis.upenn.edu/~bcpierce/papers/boomerang.pdf</a>},
  tr = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/boomerang-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/boomerang-tr.pdf</a>}
}
</pre>

<a name="updatable-security-views"></a><pre>
@inproceedings{<a href="plclub.html#updatable-security-views">updatable-security-views</a>,
  author = {J. Nathan Foster and Benjamin C. Pierce and Steve Zdancewic},
  title = {Updatable Security Views},
  booktitle = {IEEE Computer Security Foundations Symposium (CSF), Port Jefferson, NY},
  month = jul,
  year = 2009,
  bcp = {yes},
  plclub = {yes},
  conf = {<a href="http://www.cis.upenn.edu/~jnfoster/papers/updatable-security-views.pdf">http://www.cis.upenn.edu/~jnfoster/papers/updatable-security-views.pdf</a>}
}
</pre>

<a name="Pierce:POPL09ChairsReport"></a><pre>
@misc{<a href="plclub.html#Pierce:POPL09ChairsReport">Pierce:POPL09ChairsReport</a>,
  author = {Benjamin C. Pierce},
  title = {POPL 2009 PC Chair's Report},
  month = jan,
  year = {2009},
  plclub = {Yes},
  bcp = {Yes},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/popl09-chairs-reports.pdf">http://www.cis.upenn.edu/~bcpierce/papers/popl09-chairs-reports.pdf</a>}
}
</pre>

<a name="Pierce:SFold"></a><pre>
@book{<a href="plclub.html#Pierce:SFold">Pierce:SFold</a>,
  author = {Benjamin C. Pierce and Arthur Azevedo de Amorim 
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu 
                  and Vilhelm Sj\"{o}berg and Brent Yorgey},
  title = {Software Foundations},
  year = {2017},
  publisher = {Electronic textbook},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification,books},
  note = {Version 5.0.  \URL{http://www.cis.upenn.edu/~bcpierce/sf}},
  ebook = {<a href="http://www.cis.upenn.edu/~bcpierce/sf">http://www.cis.upenn.edu/~bcpierce/sf</a>},
  japanese = {<a href="http://proofcafe.org/sf">http://proofcafe.org/sf</a>}
}
</pre>

<a name="Pierce:SF1"></a><pre>
@book{<a href="plclub.html#Pierce:SF1">Pierce:SF1</a>,
  author = {Benjamin C. Pierce and Arthur Azevedo de Amorim 
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu 
                  and Vilhelm Sj\"{o}berg and Brent Yorgey},
  title = {Logical Foundations},
  series = {Software Foundations series, volume 1},
  month = may,
  year = {2018},
  publisher = {Electronic textbook},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification,books},
  note = {Version 5.5.  \URL{http://www.cis.upenn.edu/~bcpierce/sf}},
  ebook = {<a href="http://www.cis.upenn.edu/~bcpierce/sf">http://www.cis.upenn.edu/~bcpierce/sf</a>},
  japanese = {<a href="http://proofcafe.org/sf">http://proofcafe.org/sf</a>}
}
</pre>

<a name="Pierce:SF2"></a><pre>
@book{<a href="plclub.html#Pierce:SF2">Pierce:SF2</a>,
  author = {Benjamin C. Pierce and Arthur Azevedo de Amorim 
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu 
                  and Vilhelm Sj\"{o}berg and Andrew Tolmach
                  and Brent Yorgey},
  title = {Programming Language Foundations},
  series = {Software Foundations series, volume 2},
  month = may,
  year = {2018},
  publisher = {Electronic textbook},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification,books},
  note = {Version 5.5.  \URL{http://www.cis.upenn.edu/~bcpierce/sf}},
  ebook = {<a href="http://www.cis.upenn.edu/~bcpierce/sf">http://www.cis.upenn.edu/~bcpierce/sf</a>},
  japanese = {<a href="http://proofcafe.org/sf">http://proofcafe.org/sf</a>}
}
</pre>

<a name="Pierce:SF4"></a><pre>
@book{<a href="plclub.html#Pierce:SF4">Pierce:SF4</a>,
  author = {Leonidas Lampropoulos and Benjamin C. Pierce},
  title = {{QuickChick}: Property-Based Testing in Coq},
  series = {Software Foundations series, volume 4},
  month = aug,
  year = {2018},
  publisher = {Electronic textbook},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification,books},
  note = {Version 1.0.  \URL{http://www.cis.upenn.edu/~bcpierce/sf}},
  ebook = {<a href="http://www.cis.upenn.edu/~bcpierce/sf">http://www.cis.upenn.edu/~bcpierce/sf</a>}
}
</pre>

<a name="Spiders"></a><pre>
@misc{<a href="plclub.html#Spiders">Spiders</a>,
  author = {Benjamin C. Pierce and Alessandro Romanel and Daniel Wagner},
  title = {The {Spider Calculus}: Computing in Active Graphs},
  year = {2010},
  plclub = {Yes},
  bcp = {Yes},
  keys = {mobileagents},
  manuscript = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/spider_calculus.pdf">http://www.cis.upenn.edu/~bcpierce/papers/spider_calculus.pdf</a>},
  note = {Manuscript, available from \url{http://www.cis.upenn.edu/~bcpierce/papers/spider_calculus.pdf}}
}
</pre>

<a name="DPCS2010"></a><pre>
@inproceedings{<a href="plclub.html#DPCS2010">DPCS2010</a>,
  author = {Jason Reed and Adam J. Aviv and Daniel
                  Wagner and Andreas Haeberlen and Benjamin C. Pierce and 
                  Jonathan M. Smith},
  title = {Differential Privacy for Collaborative Security},
  booktitle = {European Workshop on System Security (EUROSEC)},
  year = {2010},
  month = apr,
  plclub = {Yes},
  bcp = {Yes},
  keys = {security},
  manuscript = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/eurosec2010.pdf">http://www.cis.upenn.edu/~bcpierce/papers/eurosec2010.pdf</a>}
}
</pre>

<a name="HofmannPierceWagner10:POPL"></a><pre>
@inproceedings{<a href="plclub.html#HofmannPierceWagner10:POPL">HofmannPierceWagner10:POPL</a>,
  author = {Martin Hofmann and Benjamin C. Pierce and Daniel Wagner},
  title = {Symmetric Lenses},
  year = {2011},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Austin, Texas},
  month = jan,
  bcp = {yes},
  plclub = {yes},
  keys = {harmony},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/symmetric.pdf">http://www.cis.upenn.edu/~bcpierce/papers/symmetric.pdf</a>},
  full = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/symmetric-full.pdf">http://www.cis.upenn.edu/~bcpierce/papers/symmetric-full.pdf</a>}
}
</pre>

<a name="HofmannPierceWagner13"></a><pre>
@article{<a href="plclub.html#HofmannPierceWagner13">HofmannPierceWagner13</a>,
  author = {Martin Hofmann and Benjamin C. Pierce and Daniel Wagner},
  title = {Symmetric Lenses},
  year = {2015},
  journal = {Journal of the ACM},
  note = {To appear; extended abstract in POPL 2011},
  bcp = {yes},
  plclub = {yes},
  keys = {harmony},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/symmetric.pdf">http://www.cis.upenn.edu/~bcpierce/papers/symmetric.pdf</a>}
}
</pre>

<a name="HofmannPierceWagner12"></a><pre>
@inproceedings{<a href="plclub.html#HofmannPierceWagner12">HofmannPierceWagner12</a>,
  author = {Martin Hofmann and Benjamin C. Pierce and Daniel Wagner},
  title = {Edit Lenses},
  year = {2012},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Philadelphia, Pennsylvania},
  month = jan,
  bcp = {yes},
  plclub = {yes},
  keys = {harmony},
  short = {<a href="http://dmwit.com/papers/201107EL.pdf">http://dmwit.com/papers/201107EL.pdf</a>},
  slides = {<a href="http://dmwit.com/papers/201107EL_slides.pdf">http://dmwit.com/papers/201107EL_slides.pdf</a>}
}
</pre>

<a name="Matching10"></a><pre>
@inproceedings{<a href="plclub.html#Matching10">Matching10</a>,
  author = {Davi M. J. Barbosa and Julien Cretin and Nate Foster
                  and Michael Greenberg and Benjamin C. Pierce},
  title = {Matching Lenses: Alignment and View Update},
  year = {2010},
  month = sep,
  booktitle = {{ACM} {SIGPLAN} {I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP}), Baltimore, Maryland},
  bcp = {yes},
  plclub = {yes},
  keys = {harmony},
  tr = {<a href="http://repository.upenn.edu/cis_reports/915/">http://repository.upenn.edu/cis_reports/915/</a>},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/alignment.pdf">http://www.cis.upenn.edu/~bcpierce/papers/alignment.pdf</a>}
}
</pre>

<a name="ReedPierce10"></a><pre>
@inproceedings{<a href="plclub.html#ReedPierce10">ReedPierce10</a>,
  author = {Jason Reed and Benjamin C. Pierce},
  title = {Distance Makes the Types Grow Stronger: 
                  {A} Calculus for Differential Privacy},
  booktitle = {{ACM} {SIGPLAN} {I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP}), Baltimore, Maryland},
  year = {2010},
  month = sep,
  bcp = {yes},
  plclub = {yes},
  keys = {security},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/dp.pdf">http://www.cis.upenn.edu/~bcpierce/papers/dp.pdf</a>},
  long = {<a href="http://privacy.cis.upenn.edu/papers/metric-pres-tr.pdf">http://privacy.cis.upenn.edu/papers/metric-pres-tr.pdf</a>}
}
</pre>

<a name="BohannonPierce10"></a><pre>
@inproceedings{<a href="plclub.html#BohannonPierce10">BohannonPierce10</a>,
  author = {Aaron Bohannon and Benjamin C. Pierce},
  title = {Featherweight {F}irefox:
                  {F}ormalizing the Core of a Web Browser},
  booktitle = {Usenix Conference on Web Application Development (WebApps)},
  year = {2010},
  month = jun,
  bcp = {yes},
  plclub = {yes},
  keys = {security},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/webapps_2010_bohannon_final.pdf">http://www.cis.upenn.edu/~bcpierce/papers/webapps_2010_bohannon_final.pdf</a>}
}
</pre>

<a name="Bohannon&09"></a><pre>
@inproceedings{<a href="plclub.html#Bohannon&amp;09">Bohannon&09</a>,
  author = {Bohannon, Aaron and Pierce, Benjamin C. and Sj\"{o}berg, Vilhelm and Weirich, Stephanie and Zdancewic, Steve},
  title = {Reactive Noninterference},
  booktitle = {CCS '09: Proceedings of the 16th ACM conference on Computer and communications security},
  year = {2009},
  isbn = {978-1-60558-894-0},
  pages = {79--90},
  location = {Chicago, Illinois, USA},
  doi = {<a href="http://doi.acm.org/10.1145/1653662.1653673">http://doi.acm.org/10.1145/1653662.1653673</a>},
  publisher = {ACM},
  address = {New York, NY, USA},
  bcp = {yes},
  plclub = {yes},
  keys = {security}
}
</pre>

<a name="D'Antoni:2013:SAU:2505351.2505353"></a><pre>
@inproceedings{<a href="plclub.html#D'Antoni:2013:SAU:2505351.2505353">D'Antoni:2013:SAU:2505351.2505353</a>,
  author = {D'Antoni, Loris and Gaboardi, Marco and Gallego Arias, Emilio Jes\'{u}s and Haeberlen, Andreas and Pierce, Benjamin},
  title = {Sensitivity analysis using type-based constraints},
  booktitle = {Proceedings of the 1st annual workshop on Functional programming concepts in domain-specific languages},
  series = {FPCDSL '13},
  year = {2013},
  isbn = {978-1-4503-2380-2},
  location = {Boston, Massachusetts, USA},
  pages = {43--50},
  numpages = {8},
  url = {<a href="http://doi.acm.org/10.1145/2505351.2505353">http://doi.acm.org/10.1145/2505351.2505353</a>},
  doi = {10.1145/2505351.2505353},
  acmid = {2505353},
  publisher = {ACM},
  address = {New York, NY, USA},
  plclub = {Yes},
  bcp = {Yes},
  keys = {inference}
}
</pre>

<a name="JAR-POPLMark"></a><pre>
@article{<a href="plclub.html#JAR-POPLMark">JAR-POPLMark</a>,
  author = {Benjamin C. Pierce and
                  Stephanie Weirich, editors},
  title = {Special Issue on the POPLMark Challenge},
  journal = {J. Autom. Reasoning},
  volume = {49},
  number = {3},
  year = {2012},
  ee = {<a href="http://dx.doi.org/10.1007/s10817-012-9254-5">http://dx.doi.org/10.1007/s10817-012-9254-5</a>},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  bcp = {yes},
  plclub = {yes}
}
</pre>

<a name="Haeberlen&11"></a><pre>
@inproceedings{<a href="plclub.html#Haeberlen&amp;11">Haeberlen&11</a>,
  author = {Andreas Haeberlen and Benjamin C. Pierce and 
                  Arjun Narayan},
  title = {Differential Privacy Under Fire},
  booktitle = {Proceedings of the 20th USENIX Security Symposium},
  location = {San Francisco, CA},
  month = aug,
  year = {2011},
  bcp = {yes},
  plclub = {yes},
  keys = {security},
  pdf = {<a href="http://www.cis.upenn.edu/~ahae/papers/fuzz-sec2011.pdf">http://www.cis.upenn.edu/~ahae/papers/fuzz-sec2011.pdf</a>}
}
</pre>

<a name="DBLP:conf/esop/BeloGIP11"></a><pre>
@inproceedings{<a href="plclub.html#DBLP:conf/esop/BeloGIP11">DBLP:conf/esop/BeloGIP11</a>,
  author = {Jo{\~a}o Filipe Belo and
                  Michael Greenberg and
                  Atsushi Igarashi and
                  Benjamin C. Pierce},
  title = {Polymorphic Contracts},
  booktitle = {European Symposium on Programming (ESOP), Saarbr{\"u}cken, Germany},
  year = {2011},
  pages = {18-37},
  ee = {<a href="http://dx.doi.org/10.1007/978-3-642-19718-5_2">http://dx.doi.org/10.1007/978-3-642-19718-5_2</a>},
  bcp = {Yes},
  plclub = {Yes},
  keys = {contracts},
  crossref = {<a href="#DBLP:conf/esop/2011">DBLP:conf/esop/2011</a>},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}
</pre>

<a name="DBLP:conf/esop/2011"></a><pre>
@proceedings{<a href="plclub.html#DBLP:conf/esop/2011">DBLP:conf/esop/2011</a>,
  editor = {Gilles Barthe},
  title = {Programming Languages and Systems - 20th European Symposium
                  on Programming, ESOP 2011, Held as Part of the Joint European
                  Conferences on Theory and Practice of Software, ETAPS 2011,
                  Saarbr{\"u}cken, Germany, March 26-April 3, 2011. 
                  Proceedings},
  booktitle = {ESOP},
  publisher = {Springer},
  series = {Lecture Notes in Computer Science},
  volume = {6602},
  year = {2011},
  isbn = {978-3-642-19717-8},
  ee = {<a href="http://dx.doi.org/10.1007/978-3-642-19718-5">http://dx.doi.org/10.1007/978-3-642-19718-5</a>},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}
</pre>

<a name="Pierce:PLMW-talk"></a><pre>
@misc{<a href="plclub.html#Pierce:PLMW-talk">Pierce:PLMW-talk</a>,
  author = {Benjamin C. Pierce},
  title = {Types},
  month = jan,
  year = 2012,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/PLMW-2012.pdf">http://www.cis.upenn.edu/~bcpierce/papers/PLMW-2012.pdf</a>},
  note = {Invited talk at {\em Programming Languages
                  Mentoring Workshop}},
  keys = {typessurveys},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="CRASH-PLPV-2012.pdf"></a><pre>
@misc{<a href="plclub.html#CRASH-PLPV-2012.pdf">CRASH-PLPV-2012.pdf</a>,
  author = {Benjamin C. Pierce},
  title = {Verification Challenges of Pervasive Information Flow},
  month = jan,
  year = 2012,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/CRASH-PLPV-2012.pdf">http://www.cis.upenn.edu/~bcpierce/papers/CRASH-PLPV-2012.pdf</a>},
  note = {Invited talk at {\em Programming Languages
                  Meets Program Verification} workshop (PLPV)},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="TypesALaMilner"></a><pre>
@misc{<a href="plclub.html#TypesALaMilner">TypesALaMilner</a>,
  author = {Benjamin C. Pierce},
  title = {Types {\` a} la {M}ilner},
  month = apr,
  year = 2012,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/TypesALaMilner.pdf">http://www.cis.upenn.edu/~bcpierce/papers/TypesALaMilner.pdf</a>},
  note = {Invited talk at {\em Milner Symposium}},
  keys = {typessurveys},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="TypesALaMilner-ETE"></a><pre>
@misc{<a href="plclub.html#TypesALaMilner-ETE">TypesALaMilner-ETE</a>,
  author = {Benjamin C. Pierce},
  title = {Types {\` a} la {M}ilner},
  month = apr,
  year = 2012,
  video = {<a href="http://youtu.be/carP8i6YSZs">http://youtu.be/carP8i6YSZs</a>},
  note = {Talk at {\em Philly Emerging Technologies Conference}},
  keys = {typessurveys},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Pierce-PODS12"></a><pre>
@misc{<a href="plclub.html#Pierce-PODS12">Pierce-PODS12</a>,
  author = {Benjamin C. Pierce},
  title = {Linguistic Foundations for Bidirectional Transformations},
  month = may,
  year = 2012,
  note = {Invited tutorial at {\em Principles of Database Systems (PODS)}},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/PODStutorial2012.pdf">http://www.cis.upenn.edu/~bcpierce/papers/PODStutorial2012.pdf</a>},
  keys = {harmony},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="DFuzz"></a><pre>
@inproceedings{<a href="plclub.html#DFuzz">DFuzz</a>,
  author = {Marco Gaboardi and Andreas Haeberlen and Justin Hsu and 
                  Arjun Narayan and Benjamin C. Pierce},
  title = {Linear Dependent Types for Differential Privacy},
  year = {2013},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Rome, Italy},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/dfuzz2013.pdf">http://www.cis.upenn.edu/~bcpierce/papers/dfuzz2013.pdf</a>},
  month = jan,
  bcp = {yes},
  plclub = {yes},
  keys = {security}
}
</pre>

<a name="DIMACS-2012"></a><pre>
@misc{<a href="plclub.html#DIMACS-2012">DIMACS-2012</a>,
  author = {Benjamin C. Pierce},
  title = {Differential Privacy in the Programming Languages Community},
  month = oct,
  year = 2012,
  video = {<a href="http://www.youtube.com/watch/ci2aueqZ6CU">http://www.youtube.com/watch/ci2aueqZ6CU</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/DIMACS-DP-PL.pdf">http://www.cis.upenn.edu/~bcpierce/papers/DIMACS-DP-PL.pdf</a>},
  note = {Invited tutorial at {\em DIMACS Workshop on Recent Work 
                  on Differential Privacy across Computer Science}},
  keys = {security},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="GenLabels"></a><pre>
@inproceedings{<a href="plclub.html#GenLabels">GenLabels</a>,
  title = {A Theory of Information-Flow Labels},
  author = {Beno\^it Montagu and
    Benjamin C. Pierce and
    Randy Pollack},
  month = jun,
  year = {2013},
  location = {New Orleans, Louisiana, USA},
  booktitle = {Proceedings of the 2013 IEEE Computer Security Foundations Symposium},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/csf2013.pdf">http://www.cis.upenn.edu/~bcpierce/papers/csf2013.pdf</a>},
  coq = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/label_algebras.tar.gz">http://www.cis.upenn.edu/~bcpierce/papers/label_algebras.tar.gz</a>},
  plclub = {Yes},
  keys = {security},
  bcp = {Yes}
}
</pre>

<a name="Exceptional"></a><pre>
@inproceedings{<a href="plclub.html#Exceptional">Exceptional</a>,
  author = {C\u{a}t\u{a}lin Hri\c{t}cu and
            Michael Greenberg and
            Ben Karel and
            Benjamin C. Pierce and
            Greg Morrisett},
  title = {All Your {IFCException} Are Belong To Us},
  booktitle = {34th IEEE Symposium on Security and Privacy (Oakland)},
  year = {2013},
  month = may,
  plclub = {Yes},
  bcp = {Yes},
  keys = {security},
  short = {<a href="http://www.crash-safe.org/node/23">http://www.crash-safe.org/node/23</a>}
}
</pre>

<a name="TestingNI:ICFP"></a><pre>
@inproceedings{<a href="plclub.html#TestingNI:ICFP">TestingNI:ICFP</a>,
  author = {C\u{a}t\u{a}lin Hri\c{t}cu and
                  John Hughes and
                  Benjamin C. Pierce and
                  Antal Spector-Zabusky and
                  Dimitrios Vytiniotis and
                  Arthur Azevedo de Amorim and
                  Leonidas Lampropoulos},
  title = {Testing Noninterference, Quickly},
  booktitle = {18th ACM SIGPLAN International
                  Conference on Functional Programming (ICFP)},
  shortbooktitle = {ICFP},
  year = {2013},
  month = sep,
  url = {<a href="http://www.crash-safe.org/node/24">http://www.crash-safe.org/node/24</a>},
  bcp = {yes},
  plclub = {yes},
  keys = {verification,security},
  note = {Full version in Journal of Functional Programming, special issue for ICFP 2013, 26:e4 (62 pages), April 2016. Technical Report available as arXiv:1409.0393.}
}
</pre>

<a name="ieee_hst2013:SAFE"></a><pre>
@inproceedings{<a href="plclub.html#ieee_hst2013:SAFE">ieee_hst2013:SAFE</a>,
  author = {Silviu Chiricescu and Andr\'{e} DeHon and
                  Delphine Demange and Suraj Iyer and Aleksey Kliger and Greg Morrisett
                  and Benjamin C. Pierce and Howard Reubenstein and Jonathan M. Smith
                  and Gregory T. Sullivan and Arun Thomas and Jesse Tov and Christopher M. White
                  and David Wittenberg},
  title = {SAFE: A Clean-Slate Architecture for Secure Systems},
  booktitle = {Proceedings of the {IEEE} International Conference on 
                  Technologies for Homeland Security},
  year = {2013},
  month = nov,
  bcp = {yes},
  plclub = {yes},
  keys = {security}
}
</pre>

<a name="pump_hasp2014"></a><pre>
@inproceedings{<a href="plclub.html#pump_hasp2014">pump_hasp2014</a>,
  author = {Udit Dhawan and Nikos Vasilakis and Raphael Rubin
                  and Silviu Chiricescu and Jonathan M. Smith 
and Thomas F. Knight and Benjamin C. Pierce and Andr\'e DeHon},
  title = {{PUMP -- A Programmable Unit for Metadata Processing}},
  booktitle = {Proceedings of the 3rd International Workshop on Hardware and Architectural Support for Security and Privacy},
  series = {HASP '14},
  year = {2014},
  isbn = {},
  location = {Minneapolis, USA},
  pages = {},
  articleno = {},
  numpages = {8},
  url = {<a href="http://www.crash-safe.org/node/32">http://www.crash-safe.org/node/32</a>},
  doi = {},
  acmid = {},
  publisher = {ACM},
  address = {New York, NY, USA},
  bcp = {yes},
  plclub = {yes},
  keys = {security}
}
</pre>

<a name="interlocks_ahns2012"></a><pre>
@inproceedings{<a href="plclub.html#interlocks_ahns2012">interlocks_ahns2012</a>,
  author = {
  Udit Dhawan and
  Albert Kwon and
  Edin Kadric and
  C\u{a}t\u{a}lin Hri\c{t}cu and
  Benjamin C. Pierce and
  Jonathan M. Smith and
  Gregory Malecha and
  Greg Morrisett and
  Thomas F. {Knight, Jr.} and
  Andrew Sutherland and
  Tom Hawkins and 
  Amanda Zyxnfryx and
  David Wittenberg and
  Peter Trei and
  Sumit Ray and
  Greg Sullivan and
  Andr\'e DeHon
  },
  title = {Hardware Support for Safety Interlocks and Introspection},
  url = {<a href="http://www.crash-safe.org/sites/default/files/interlocks_ahns2012.pdf">http://www.crash-safe.org/sites/default/files/interlocks_ahns2012.pdf</a>},
  month = sep,
  year = 2012,
  booktitle = {SASO Workshop on Adaptive Host and  Network Security},
  bcp = {yes},
  plclub = {yes},
  keys = {harmony}
}
</pre>

<a name="HofmannPierceWagner13a"></a><pre>
@inproceedings{<a href="plclub.html#HofmannPierceWagner13a">HofmannPierceWagner13a</a>,
  author = {Martin Hofmann and Benjamin C. Pierce and Daniel Wagner},
  title = {Edit languages for information trees},
  year = {2013},
  booktitle = {Second International Workshop on Bidirectional Transformations (BX)},
  month = apr,
  bcp = {yes},
  plclub = {yes},
  keys = {harmony}
}
</pre>

<a name="Pierce:CSFTalk2013"></a><pre>
@misc{<a href="plclub.html#Pierce:CSFTalk2013">Pierce:CSFTalk2013</a>,
  author = {Benjamin C. Pierce},
  title = {The {SAFE} Machine: {A}n Architecture for 
                  Pervasive Information Flow},
  month = jun,
  year = 2013,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/csf-2013-pierce.pdf">http://www.cis.upenn.edu/~bcpierce/papers/csf-2013-pierce.pdf</a>},
  note = {Invited talk at {\em Computer Security 
                  Foundations Symposium (CSF)}},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="Pierce:SPLASHTalk2016"></a><pre>
@misc{<a href="plclub.html#Pierce:SPLASHTalk2016">Pierce:SPLASHTalk2016</a>,
  author = {Benjamin C. Pierce},
  title = {The Science of Deep Specification},
  month = nov,
  year = 2016,
  note = {Invited keynote at {\em SPLASH / OOPSLA}},
  plclub = {Yes},
  bcp = {Yes},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/deepspec-splash2016.pdf">http://www.cis.upenn.edu/~bcpierce/papers/deepspec-splash2016.pdf</a>},
  video = {https://www.youtube.com/watch?v=IPNdsnRWBkk&t=5s},
  keys = {verification}
}
</pre>

<a name="Pierce:ETAPSTalk2018"></a><pre>
@misc{<a href="plclub.html#Pierce:ETAPSTalk2018">Pierce:ETAPSTalk2018</a>,
  author = {Benjamin C. Pierce},
  title = {The Science of Deep Specification},
  month = apr,
  year = 2018,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pierce-etaps2018.pdf">http://www.cis.upenn.edu/~bcpierce/papers/pierce-etaps2018.pdf</a>},
  note = {Invited keynote at {\em ETAPS / POST}},
  plclub = {Yes},
  bcp = {Yes},
  video = {https://www.etaps.org/index.php/2018/invited-speakers},
  keys = {verification}
}
</pre>

<a name="Epsilon2014"></a><pre>
@inproceedings{<a href="plclub.html#Epsilon2014">Epsilon2014</a>,
  title = {Differential Privacy: An Economic Method for Choosing
                  Epsilon},
  author = {Justin Hsu and Marco Gaboardi and
                  Andreas Haeberlen and Sanjeev Khanna and 
                  Arjun Narayan and Benjamin C. Pierce and Aaron Roth},
  booktitle = {Computer Security 
                  Foundations Symposium (CSF)},
  year = 2014,
  url = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/epsilon-csf.pdf">http://www.cis.upenn.edu/~bcpierce/papers/epsilon-csf.pdf</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="PicoCoq2013:POPL"></a><pre>
@inproceedings{<a href="plclub.html#PicoCoq2013:POPL">PicoCoq2013:POPL</a>,
  title = {A Verified Information-Flow Architecture},
  author = {
    Arthur {Azevedo de Amorim} and
    Nathan Collins and
    Andr\'e DeHon and
    Delphine Demange and
    C\u{a}t\u{a}lin Hri\c{t}cu and
    David Pichardie and
    Benjamin C. Pierce and
    Randy Pollack and
    Andrew Tolmach
  },
  booktitle = {Proceedings of the 41st Symposium on Principles of Programming Languages},
  series = {POPL},
  month = jan,
  year = 2014,
  url = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/verified-ifc.pdf">http://www.cis.upenn.edu/~bcpierce/papers/verified-ifc.pdf</a>},
  full = {<a href="http://arxiv.org/abs/1509.06503">http://arxiv.org/abs/1509.06503</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security},
  note = {Full version in Journal of Computer Security, Special Issue on Verified Information Flow Security, Dec 2016}
}
</pre>

<a name="SAFEPLOS11:PreliminaryDesign"></a><pre>
@inproceedings{<a href="plclub.html#SAFEPLOS11:PreliminaryDesign">SAFEPLOS11:PreliminaryDesign</a>,
  author = {
  Andr\'{e} DeHon and
  Ben Karel and
  Thomas F. {Knight, Jr.} and
  Gregory Malecha and
  Beno\^{i}t Montagu and
  Robin Morisset and
  Greg Morrisett and
  Benjamin C. Pierce and
  Randy Pollack and
  Sumit Ray and
  Olin Shivers and
  Jonathan M. Smith and
  Gregory Sullivan
  },
  title = {Preliminary Design of the {SAFE} Platform},
  month = oct,
  year = 2011,
  url = {<a href="http://www.crash-safe.org/sites/default/files/plos11-final_0.pdf">http://www.crash-safe.org/sites/default/files/plos11-final_0.pdf</a>},
  booktitle = {6th Workshop on Programming
  Languages and Operating Systems},
  series = {PLOS},
  shortbooktitle = {PLOS},
  location = {Cascais, Portugal},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="Pierce:PiPTalk2014"></a><pre>
@misc{<a href="plclub.html#Pierce:PiPTalk2014">Pierce:PiPTalk2014</a>,
  author = {Benjamin C. Pierce},
  title = {Principles, Meet Practice: An Early Retrospective on SAFE},
  month = jan,
  year = 2014,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/safe-PiP-140126.pdf">http://www.cis.upenn.edu/~bcpierce/papers/safe-PiP-140126.pdf</a>},
  note = {Talk at {\em Principles in Practice Workshop (PiP)}},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="Pierce:HCSSTalk2014"></a><pre>
@misc{<a href="plclub.html#Pierce:HCSSTalk2014">Pierce:HCSSTalk2014</a>,
  author = {Benjamin C. Pierce},
  title = {Programmable Hardware Support for Ubiquitous Micro-Policy
  Enforcement},
  month = may,
  year = 2014,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/hcss2014-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/hcss2014-slides.pdf</a>},
  note = {Talk at {\em High-Confidence Software Systems}},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="Pierce:LukeInterview"></a><pre>
@misc{<a href="plclub.html#Pierce:LukeInterview">Pierce:LukeInterview</a>,
  author = {Benjamin C. Pierce},
  title = {{Interview with Luke Muehlhauser on Clean-Slate Security Architectures for Machine Intelligence Research Institute blog}},
  month = may,
  year = 2014,
  transcript = {<a href="http://intelligence.org/2014/05/11/benjamin-pierce/">http://intelligence.org/2014/05/11/benjamin-pierce/</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="pump_oakland2015"></a><pre>
@inproceedings{<a href="plclub.html#pump_oakland2015">pump_oakland2015</a>,
  author = {Arthur {Azevedo de Amorim} and
                  Maxime D\'en\`es and
                  Nick Giannarakis and
                  C\u{a}t\u{a}lin Hri\c{t}cu and
                  Benjamin C. Pierce and
                  Antal Spector-Zabusky and
                  Andrew Tolmach},
  title = {Micro-Policies: Formally Verified, Tag-Based Security Monitors},
  booktitle = {36th IEEE Symposium on Security and Privacy (Oakland S\&P)},
  year = {2015},
  month = may,
  short = {<a href="http://prosecco.gforge.inria.fr/personal/hritcu/publications/micro-policies.pdf">http://prosecco.gforge.inria.fr/personal/hritcu/publications/micro-policies.pdf</a>},
  fullurl = {https://www.cis.upenn.edu/~aarthur/micro-policies-full.pdf},
  slides = {<a href="http://www.seas.upenn.edu/~aarthur/micro-policies-slides.pdf">http://www.seas.upenn.edu/~aarthur/micro-policies-slides.pdf</a>},
  publisher = {IEEE},
  acceptance = {55/420=0.13},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="WagnerThesis"></a><pre>
@phdthesis{<a href="plclub.html#WagnerThesis">WagnerThesis</a>,
  author = {Daniel Wagner},
  title = {Symmetric Edit Lenses:
                 A New Foundation for Bidirectional Languages},
  school = {University of Pennsylvania},
  year = {2014},
  bcp = {Yes},
  keys = {harmony},
  plclub = {Yes},
  pdf = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/wagner-thesis.pdf">http://www.cis.upenn.edu/~bcpierce/papers/wagner-thesis.pdf</a>}
}
</pre>

<a name="DBLP:journals/entcs/BrookesPPS13"></a><pre>
@article{<a href="plclub.html#DBLP:journals/entcs/BrookesPPS13">DBLP:journals/entcs/BrookesPPS13</a>,
  author = {Stephen Brookes and
               Benjamin C. Pierce and
               Gordon D. Plotkin and
               Dana S. Scott},
  title = {Dedication to John Reynolds},
  journal = {Electr. Notes Theor. Comput. Sci.},
  volume = {298},
  pages = {3--5},
  year = {2013},
  url = {<a href="http://dx.doi.org/10.1016/j.entcs.2013.09.004">http://dx.doi.org/10.1016/j.entcs.2013.09.004</a>},
  doi = {10.1016/j.entcs.2013.09.004},
  timestamp = {Fri, 03 Jan 2014 15:10:40 +0100},
  biburl = {<a href="http://dblp.uni-trier.de/rec/bib/journals/entcs/BrookesPPS13">http://dblp.uni-trier.de/rec/bib/journals/entcs/BrookesPPS13</a>},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  plclub = {Yes},
  bcp = {Yes},
  note = {Special Issue: Proceedings of the 29th Conference on Mathematical Foundations of Programming Semantics (MFPS)}
}
</pre>

<a name="Denes:VSL2014"></a><pre>
@inproceedings{<a href="plclub.html#Denes:VSL2014">Denes:VSL2014</a>,
  author = {Maxime D\'en\`es and Catalin Hritcu and Leonidas Lampropoulos and Zoe Paraskevopoulou and Benjamin C. Pierce},
  title = {{QuickChick}: {P}roperty-Based Testing for {C}oq (abstract)},
  booktitle = {VSL},
  url = {<a href="http://www.easychair.org/smart-program/VSL2014/index.html">http://www.easychair.org/smart-program/VSL2014/index.html</a>},
  year = 2014,
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification}
}
</pre>

<a name="Paraskevopoulou:ITP2015"></a><pre>
@inproceedings{<a href="plclub.html#Paraskevopoulou:ITP2015">Paraskevopoulou:ITP2015</a>,
  author = {Zoe Paraskevopoulou and
                  C\u{a}t\u{a}lin Hri\c{t}cu and
                  Maxime D\'en\`es and
                  Leonidas Lampropoulos and
                  Benjamin C. Pierce},
  title = {Foundational Property-Based Testing},
  booktitle = {International Conference 
                  on Interactive Theorem Proving (ITP)},
  year = 2015,
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification}
}
</pre>

<a name="pump:asplos2015"></a><pre>
@misc{<a href="plclub.html#pump:asplos2015">pump:asplos2015</a>,
  author = {Udit Dhawan and
          C\u{a}t\u{a}lin Hri\c{t}cu and
          Rafi Rubin and
          Nikos Vasilakis and
          Silviu Chiricescu and
          Jonathan M. Smith and
          Thomas F. {Knight, Jr.} and
          Benjamin C. Pierce and
          Andr\'{e} DeHon},
  title = {Architectural Support for Software-Defined Metadata Processing},
  howpublished = <a href="#asplos">asplos</a>,
  year = {2015},
  url = {<a href="http://ic.ese.upenn.edu/abstracts/sdmp_asplos2015.html">http://ic.ese.upenn.edu/abstracts/sdmp_asplos2015.html</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="Pierce:MicroPoliciesTalk2014"></a><pre>
@misc{<a href="plclub.html#Pierce:MicroPoliciesTalk2014">Pierce:MicroPoliciesTalk2014</a>,
  author = {Benjamin C. Pierce},
  title = {Micro-Policies: A Framework for Tag-Based Security Monitors},
  month = dec,
  year = 2014,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/upolicies-201412.pdf">http://www.cis.upenn.edu/~bcpierce/papers/upolicies-201412.pdf</a>},
  note = {Distinguished Lecture at University of Minnesota},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="beyond-good-and-evil"></a><pre>
@inproceedings{<a href="plclub.html#beyond-good-and-evil">beyond-good-and-evil</a>,
  author = {Yannis Juglaret and
           C\u{a}t\u{a}lin Hri\c{t}cu and
           Arthur {Azevedo de Amorim} and
           Boris Eng and
           Benjamin C. Pierce},
  title = {Beyond Good and Evil: Formalizing the Security Guarantees
                 of Compartmentalizing Compilation},
  booktitle = {29th IEEE Symposium on Computer Security Foundations (CSF)},
  shortbooktitle = {CSF},
  year = {2016},
  month = jul,
  publisher = {IEEE Computer Society Press},
  url = {<a href="http://arxiv.org/abs/1602.04503">http://arxiv.org/abs/1602.04503</a>},
  acceptance = {31/87=0.36},
  note = {arXiv:1602.04503},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="Murawski:2016:2893582"></a><pre>
@article{<a href="plclub.html#Murawski:2016:2893582">Murawski:2016:2893582</a>,
  title = {Programming language techniques for differential privacy},
  author = {Barthe, Gilles and
                Gaboardi, Marco and
                Hsu, Justin and
                Pierce, Benjamin C},
  pages = {34--53},
  editor = {Murawski, Andrzej},
  journal = {ACM SIGLOG News},
  month = jan,
  year = {2016},
  volume = {3},
  number = {1},
  publisher = {ACM},
  address = {New York, NY, USA},
  url = {<a href="http://siglog.hosting.acm.org/wp-content/uploads/2016/01/siglog_news_7.pdf">http://siglog.hosting.acm.org/wp-content/uploads/2016/01/siglog_news_7.pdf</a>},
  bcp = {Yes},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="Pierce:DeepSpecHCSS2016"></a><pre>
@misc{<a href="plclub.html#Pierce:DeepSpecHCSS2016">Pierce:DeepSpecHCSS2016</a>,
  author = {Benjamin C. Pierce},
  title = {The Science of Deep Specification},
  month = may,
  year = 2016,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/deepspec-hcss2016-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/deepspec-hcss2016-slides.pdf</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification},
  note = {High-Confidence Software Systems (HCSS)}
}
</pre>

<a name="WinogradCort2017"></a><pre>
@article{<a href="plclub.html#WinogradCort2017">WinogradCort2017</a>,
  author = {Daniel Winograd{-}Cort and
               Andreas Haeberlen and
               Aaron Roth and
               Benjamin C. Pierce},
  title = {A framework for adaptive differential privacy},
  journal = {{PACMPL}},
  volume = {1},
  number = {{ICFP}},
  pages = {10:1--10:29},
  year = {2017},
  url = {<a href="http://doi.acm.org/10.1145/3110254">http://doi.acm.org/10.1145/3110254</a>},
  doi = {10.1145/3110254},
  timestamp = {Tue, 12 Sep 2017 16:16:51 +0200},
  biburl = {https://dblp.org/rec/bib/journals/pacmpl/Winograd-CortHR17},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="beginners-luck"></a><pre>
@incollection{<a href="plclub.html#beginners-luck">beginners-luck</a>,
  author = {Leonidas Lampropoulos and
                  Diane Gallois-Wong and
                  C\u{a}t\u{a}lin Hri\c{t}cu and
                  John Hughes and
                  Benjamin C. Pierce and
                  {Li-yao} Xia},
  title = {Beginner's {Luck}: {A} Language for Random Generators},
  booktitle = {Foundations of Programming and Software systems: Probabilistic Programming},
  editor = {Gilles Barthe and Joost-Pieter Katoen and Alexandra Silva},
  year = {2019},
  url = {https://arxiv.org/abs/1607.05443},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification},
  note = {To appear.  An earlier version appeared in ACM SIGPLAN Symposium on Principles of Programming
                  Languages (POPL), Jan 2017}
}
</pre>

<a name="beginners-luck:popl"></a><pre>
@inproceedings{<a href="plclub.html#beginners-luck:popl">beginners-luck:popl</a>,
  author = {Leonidas Lampropoulos and
                  Diane Gallois-Wong and
                  C\u{a}t\u{a}lin Hri\c{t}cu and
                  John Hughes and
                  Benjamin C. Pierce and
                  {Li-yao} Xia},
  title = {Beginner's {Luck}: A Language for Random Generators},
  booktitle = {44th ACM SIGPLAN Symposium on Principles of Programming
                  Languages (POPL)},
  year = {2017},
  month = jan,
  url = {https://arxiv.org/abs/1607.05443},
  acceptance = {64/279=0.23},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification}
}
</pre>

<a name="Pierce:PLMWTalk2017"></a><pre>
@misc{<a href="plclub.html#Pierce:PLMWTalk2017">Pierce:PLMWTalk2017</a>,
  author = {Benjamin C. Pierce},
  title = {The Curse of Knowledge},
  month = jan,
  year = 2017,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/plmw2017-curse-of-knowledge.pdf">http://www.cis.upenn.edu/~bcpierce/papers/plmw2017-curse-of-knowledge.pdf</a>},
  note = {Talk at Programming Languages Mentoring Workshop (PLMW)},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc}
}
</pre>

<a name="Pierce:PLMWTalk2018"></a><pre>
@misc{<a href="plclub.html#Pierce:PLMWTalk2018">Pierce:PLMWTalk2018</a>,
  author = {Benjamin C. Pierce},
  title = {The Curse of Knowledge},
  month = jan,
  year = 2018,
  note = {Talk at Programming Languages Mentoring Workshop (PLMW)},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc}
}
</pre>

<a name="AzevedoDeAmorim17"></a><pre>
@misc{<a href="plclub.html#AzevedoDeAmorim17">AzevedoDeAmorim17</a>,
  author = {Arthur {Azevedo de Amorim} and
                  C\u{a}t\u{a}lin Hri\c{t}cu and
                  Benjamin C. Pierce},
  title = {The Meaning of Memory Safety},
  howpublished = {arXiv:1705.07354},
  url = {https://arxiv.org/abs/1705.07354},
  year = {2017},
  month = may,
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification}
}
</pre>

<a name="AzevedoDeAmorim17old"></a><pre>
@inproceedings{<a href="plclub.html#AzevedoDeAmorim17old">AzevedoDeAmorim17old</a>,
  author = {Arthur Azevedo de Amorim and
                  C\u{a}t\u{a}lin Hri\c{t}cu and
                  Benjamin C. Pierce},
  title = {The Meaning of Memory Safety},
  booktitle = {ACM Conference on Computer and Communications Security (CCS)},
  year = 2017,
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification},
  note = {Under submission}
}
</pre>

<a name="Pierce:ReleaseInterview"></a><pre>
@misc{<a href="plclub.html#Pierce:ReleaseInterview">Pierce:ReleaseInterview</a>,
  author = {Benjamin C. Pierce},
  title = {{Interview with Tijs van der Storm on The Science of Deep Specification for release.nl magazine}},
  month = nov,
  year = 2016,
  transcript = {<a href="http://release.nl/293/video.html?video=775966">http://release.nl/293/video.html?video=775966</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security,verification}
}
</pre>

<a name="Pierce:OmegaTauInterview"></a><pre>
@misc{<a href="plclub.html#Pierce:OmegaTauInterview">Pierce:OmegaTauInterview</a>,
  author = {Benjamin C. Pierce},
  title = {{Interview with Markus V\"olter on The Science of Deep Specification for Omega Tau podcast}},
  month = nov,
  year = 2016,
  transcript = {<a href="http://omegataupodcast.net/243-formal-specification-and-proof/">http://omegataupodcast.net/243-formal-specification-and-proof/</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security,verification}
}
</pre>

<a name="Pierce:NSFtalk2017"></a><pre>
@misc{<a href="plclub.html#Pierce:NSFtalk2017">Pierce:NSFtalk2017</a>,
  author = {Benjamin C. Pierce},
  title = {The Science of Deep Specification},
  month = sep,
  year = 2017,
  note = {WATCH lecture at NSF},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification}
}
</pre>

<a name="Pierce:DeepWeb-dsw2018"></a><pre>
@misc{<a href="plclub.html#Pierce:DeepWeb-dsw2018">Pierce:DeepWeb-dsw2018</a>,
  author = {Benjamin C. Pierce},
  title = {Specifying the {DeepSpec Web Server}},
  month = jun,
  year = 2018,
  note = {Talk at {\it DeepSpec} workshop},
  plclub = {Yes},
  bcp = {Yes},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/DeepWeb-dsw2018.pdf">http://www.cis.upenn.edu/~bcpierce/papers/DeepWeb-dsw2018.pdf</a>},
  keys = {verification}
}
</pre>

<a name="Pierce:DeepWeb-dsw2019"></a><pre>
@misc{<a href="plclub.html#Pierce:DeepWeb-dsw2019">Pierce:DeepWeb-dsw2019</a>,
  author = {Benjamin C. Pierce},
  title = {The Science of Deep Specification},
  month = jun,
  year = 2019,
  note = {Opening talk at {\it DeepSpec} workshop},
  plclub = {Yes},
  bcp = {Yes},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/DeepSpec-workshop-2019-Intro.pdf">http://www.cis.upenn.edu/~bcpierce/papers/DeepSpec-workshop-2019-Intro.pdf</a>},
  keys = {verification}
}
</pre>

<a name="DBLP:journals/corr/ChongGDMPSSZ16"></a><pre>
@article{<a href="plclub.html#DBLP:journals/corr/ChongGDMPSSZ16">DBLP:journals/corr/ChongGDMPSSZ16</a>,
  author = {Stephen Chong and
                  Joshua Guttman and
                  Anupam Datta and
                  Andrew C. Myers and
                  Benjamin Pierce and
                  Patrick Schaumont and
                  Tim Sherwood and
                  Nickolai Zeldovich},
  title = {Report on the {NSF} Workshop on Formal Methods for Security},
  journal = {CoRR},
  volume = {abs/1608.00678},
  year = {2016},
  url = {<a href="http://arxiv.org/abs/1608.00678">http://arxiv.org/abs/1608.00678</a>},
  timestamp = {Mon, 24 Oct 2016 15:22:59 +0200},
  biburl = {<a href="http://dblp.uni-trier.de/rec/bib/journals/corr/ChongGDMPSSZ16">http://dblp.uni-trier.de/rec/bib/journals/corr/ChongGDMPSSZ16</a>},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="DBLP:journals/corr/ChongGDMPSSZ16:again"></a><pre>
@article{<a href="plclub.html#DBLP:journals/corr/ChongGDMPSSZ16:again">DBLP:journals/corr/ChongGDMPSSZ16:again</a>,
  author = {Stephen Chong and
               Joshua Guttman and
               Anupam Datta and
               Andrew C. Myers and
               Benjamin Pierce and
               Patrick Schaumont and
               Tim Sherwood and
               Nickolai Zeldovich},
  title = {Report on the {NSF} Workshop on Formal Methods for Security},
  journal = {CoRR},
  volume = {abs/1608.00678},
  year = {2016},
  url = {<a href="http://arxiv.org/abs/1608.00678">http://arxiv.org/abs/1608.00678</a>},
  timestamp = {Mon, 24 Oct 2016 15:22:59 +0200},
  biburl = {<a href="http://dblp.uni-trier.de/rec/bib/journals/corr/ChongGDMPSSZ16">http://dblp.uni-trier.de/rec/bib/journals/corr/ChongGDMPSSZ16</a>},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  plclub = {Yes},
  bcp = {Yes}
}
</pre>

<a name="Miltner&18"></a><pre>
@article{<a href="plclub.html#Miltner&amp;18">Miltner&18</a>,
  author = {Anders Miltner and
               Kathleen Fisher and
               Benjamin C. Pierce and
               David Walker and
               Steve Zdancewic},
  title = {Synthesizing bijective lenses},
  journal = {{PACMPL}},
  volume = {2},
  number = {{POPL}},
  pages = {1:1--1:30},
  year = {2018},
  url = {<a href="http://doi.acm.org/10.1145/3158089">http://doi.acm.org/10.1145/3158089</a>},
  doi = {10.1145/3158089},
  timestamp = {Fri, 05 Jan 2018 12:57:30 +0100},
  biburl = {https://dblp.org/rec/bib/journals/pacmpl/MiltnerFPWZ18},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  plclub = {Yes},
  bcp = {Yes},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/synth-bij-lenses.pdf">http://www.cis.upenn.edu/~bcpierce/papers/synth-bij-lenses.pdf</a>},
  keys = {harmony}
}
</pre>

<a name="Lampropoulos&18"></a><pre>
@article{<a href="plclub.html#Lampropoulos&amp;18">Lampropoulos&18</a>,
  author = {Leonidas Lampropoulos and
               Zoe Paraskevopoulou and
               Benjamin C. Pierce},
  title = {Generating good generators for inductive relations},
  journal = {{PACMPL}},
  volume = {2},
  number = {{POPL}},
  pages = {45:1--45:30},
  year = {2018},
  url = {<a href="http://doi.acm.org/10.1145/3158133">http://doi.acm.org/10.1145/3158133</a>},
  doi = {10.1145/3158133},
  timestamp = {Fri, 05 Jan 2018 12:57:30 +0100},
  biburl = {https://dblp.org/rec/bib/journals/pacmpl/LampropoulosPP18},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  plclub = {Yes},
  bcp = {Yes},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/generating-good.pdf">http://www.cis.upenn.edu/~bcpierce/papers/generating-good.pdf</a>},
  keys = {verification}
}
</pre>

<a name="Pierce:ClimateCommitteReport"></a><pre>
@misc{<a href="plclub.html#Pierce:ClimateCommitteReport">Pierce:ClimateCommitteReport</a>,
  author = {Michael W. Hicks and Crista Lopes and Benjamin C. Pierce},
  title = {Engaging with Climate Change: 
                  Some Possible Steps for SIGPLAN 
                  (Preliminary Report of the SIGPLAN Climate Committee, Version 1.2)},
  month = jun,
  year = 2018,
  url = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/sigplan-climate-report.pdf">http://www.cis.upenn.edu/~bcpierce/papers/sigplan-climate-report.pdf</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc,climate}
}
</pre>

<a name="Pierce:ClimateCommitteReportAtPLDI18"></a><pre>
@misc{<a href="plclub.html#Pierce:ClimateCommitteReportAtPLDI18">Pierce:ClimateCommitteReportAtPLDI18</a>,
  author = {Michael W. Hicks and Crista Lopes and Jens Palsberg 
                  and Benjamin C. Pierce},
  title = {{SIGPLAN} and Climate Change: {A} report from {SIGPLAN}'s 
                  ad hoc committee on climate change},
  month = jun,
  year = 2018,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/PLDI2018-townhall-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/PLDI2018-townhall-slides.pdf</a>},
  keynote = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/PLDI2018-townhall-slides.key">http://www.cis.upenn.edu/~bcpierce/papers/PLDI2018-townhall-slides.key</a>},
  video = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/PLDI2018-townhall.mov">http://www.cis.upenn.edu/~bcpierce/papers/PLDI2018-townhall.mov</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc,climate}
}
</pre>

<a name="Pierce:ClimateCommitteReportAtICFP18"></a><pre>
@misc{<a href="plclub.html#Pierce:ClimateCommitteReportAtICFP18">Pierce:ClimateCommitteReportAtICFP18</a>,
  author = {Michael W. Hicks and Crista Lopes and Jens Palsberg 
                  and Benjamin C. Pierce},
  title = {{SIGPLAN} and Climate Change: {A} report from the {SIGPLAN}
                  committee on climate change},
  month = sep,
  year = 2018,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/ICFP2018-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/ICFP2018-slides.pdf</a>},
  keynote = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/ICFP2018-slides.key">http://www.cis.upenn.edu/~bcpierce/papers/ICFP2018-slides.key</a>},
  video = {XXXXX},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc,climate}
}
</pre>

<a name="CarbonOFfsetReport"></a><pre>
@misc{<a href="plclub.html#CarbonOFfsetReport">CarbonOFfsetReport</a>,
  author = {Richard Kim and Benjamin C. Pierce},
  title = {Carbon Offsets: An Overview for Scientific Societies},
  month = jun,
  year = 2018,
  url = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/carbon-offsets.pdf">http://www.cis.upenn.edu/~bcpierce/papers/carbon-offsets.pdf</a>},
  note = {Version 1.2},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc,climate}
}
</pre>

<a name="DBLP:conf/eurosp/SchoepeBPS16"></a><pre>
@inproceedings{<a href="plclub.html#DBLP:conf/eurosp/SchoepeBPS16">DBLP:conf/eurosp/SchoepeBPS16</a>,
  author = {Daniel Schoepe and
               Musard Balliu and
               Benjamin C. Pierce and
               Andrei Sabelfeld},
  title = {Explicit Secrecy: {A} Policy for Taint Tracking},
  booktitle = {{IEEE} European Symposium on Security and Privacy, EuroS{\&}P
               2016, Saarbr{\"{u}}cken, Germany, March 21-24, 2016},
  pages = {15--30},
  year = {2016},
  crossref = {<a href="#DBLP:conf/eurosp/2016">DBLP:conf/eurosp/2016</a>},
  url = {https://doi.org/10.1109/EuroSP.2016.14},
  doi = {10.1109/EuroSP.2016.14},
  timestamp = {Wed, 24 May 2017 08:27:42 +0200},
  biburl = {<a href="http://dblp.org/rec/bib/conf/eurosp/SchoepeBPS16">http://dblp.org/rec/bib/conf/eurosp/SchoepeBPS16</a>},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="DBLP:conf/eurosp/2016"></a><pre>
@proceedings{<a href="plclub.html#DBLP:conf/eurosp/2016">DBLP:conf/eurosp/2016</a>,
  title = {{IEEE} European Symposium on Security and Privacy, EuroS{\&}P
               2016, Saarbr{\"{u}}cken, Germany, March 21-24, 2016},
  publisher = {{IEEE}},
  year = {2016},
  url = {<a href="http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=7467055">http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=7467055</a>},
  isbn = {978-1-5090-1751-5},
  timestamp = {Sun, 05 Jun 2016 10:00:11 +0200},
  biburl = {<a href="http://dblp.org/rec/bib/conf/eurosp/2016">http://dblp.org/rec/bib/conf/eurosp/2016</a>},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}
</pre>

<a name="Yang17"></a><pre>
@misc{<a href="plclub.html#Yang17">Yang17</a>,
  author = {Jean Yang},
  title = {People of {P}rogramming {L}anguages: {I}nterview with
                  {B}enjamin {P}ierce},
  month = dec,
  year = 2017,
  url = {<a href="http://www.cs.cmu.edu/~popl-interviews/pierce.html">http://www.cs.cmu.edu/~popl-interviews/pierce.html</a>},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc}
}
</pre>

<a name="abate2018good"></a><pre>
@inproceedings{<a href="plclub.html#abate2018good">abate2018good</a>,
  title = {When good components go bad: Formally secure compilation despite dynamic compromise},
  author = {Abate, Carmine and Azevedo de Amorim, Arthur and Blanco, Roberto and Evans, Ana Nora and Fachini, Guglielmo and Hritcu, Catalin and Laurent, Th{\'e}o and Pierce, Benjamin C and Stronati, Marco and Tolmach, Andrew},
  booktitle = {Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security},
  pages = {1351--1368},
  year = {2018},
  organization = {ACM},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="DBLP:conf/post/AmorimHP18"></a><pre>
@inproceedings{<a href="plclub.html#DBLP:conf/post/AmorimHP18">DBLP:conf/post/AmorimHP18</a>,
  author = {Arthur Azevedo de Amorim and
               Catalin Hritcu and
               Benjamin C. Pierce},
  title = {The Meaning of Memory Safety},
  booktitle = {Principles of Security and Trust - 7th International Conference, {POST}
               2018, Held as Part of the European Joint Conferences on Theory and
               Practice of Software, {ETAPS} 2018, Thessaloniki, Greece, April 14-20,
               2018, Proceedings},
  pages = {79--105},
  year = {2018},
  crossref = {<a href="#DBLP:conf/post/2018">DBLP:conf/post/2018</a>},
  url = {https://doi.org/10.1007/978-3-319-89722-6_4},
  doi = {10.1007/978-3-319-89722-6_4},
  timestamp = {Mon, 16 Apr 2018 13:28:26 +0200},
  biburl = {https://dblp.org/rec/bib/conf/post/AmorimHP18},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  plclub = {Yes},
  bcp = {Yes},
  keys = {security}
}
</pre>

<a name="DBLP:conf/post/2018"></a><pre>
@proceedings{<a href="plclub.html#DBLP:conf/post/2018">DBLP:conf/post/2018</a>,
  editor = {Lujo Bauer and
               Ralf K{\"{u}}sters},
  title = {Principles of Security and Trust - 7th International Conference, {POST}
               2018, Held as Part of the European Joint Conferences on Theory and
               Practice of Software, {ETAPS} 2018, Thessaloniki, Greece, April 14-20,
               2018, Proceedings},
  series = {Lecture Notes in Computer Science},
  volume = {10804},
  publisher = {Springer},
  year = {2018},
  url = {https://doi.org/10.1007/978-3-319-89722-6},
  doi = {10.1007/978-3-319-89722-6},
  isbn = {978-3-319-89721-9},
  timestamp = {Mon, 16 Apr 2018 13:26:44 +0200},
  biburl = {https://dblp.org/rec/bib/conf/post/2018},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
</pre>

<a name="Pierce:MartinHofmannMemorial"></a><pre>
@misc{<a href="plclub.html#Pierce:MartinHofmannMemorial">Pierce:MartinHofmannMemorial</a>,
  author = {Benjamin C. Pierce},
  title = {In Memoriam {M}artin {H}ofmann},
  month = jul,
  year = 2018,
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/MartinHofmannMemorial.pdf">http://www.cis.upenn.edu/~bcpierce/papers/MartinHofmannMemorial.pdf</a>},
  keynote = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/MartinHofmannMemorial.key">http://www.cis.upenn.edu/~bcpierce/papers/MartinHofmannMemorial.key</a>},
  video = {https://www.youtube.com/watch?v=WpWt40l_uDk},
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc},
  note = {The Apple Keynote version includes the music from the
                  presentation, plus the full text in the presenter notes}
}
</pre>

<a name="MainaAtAl18"></a><pre>
@article{<a href="plclub.html#MainaAtAl18">MainaAtAl18</a>,
  author = {Solomon Maina and Anders Miltner and Kathleen Fisher
                  and Benjamin C. Pierce and David Walker and 
                  Steve Zdancewic},
  title = {Synthesizing Quotient Lenses},
  journal = {Proceedings of the ACM on Programming Languages
                  (PACMPL ICFP)},
  month = sep,
  year = 2018,
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/icfp18-synthesizing-quotient-lenses.pdf">http://www.cis.upenn.edu/~bcpierce/papers/icfp18-synthesizing-quotient-lenses.pdf</a>},
  keys = {harmony}
}
</pre>

<a name="CPP-2019"></a><pre>
@inproceedings{<a href="plclub.html#CPP-2019">CPP-2019</a>,
  author = {Nicolas Koh and
                  Yao Li and
                  Yishuai Li and
                  Li-yao Xia and
                  Lennart Beringer and
                  Wolf Honore and
                  William Mansky and
                  Benjamin C. Pierce and
                  Steve Zdancewic},
  title = {From {C} to Interaction Trees: {S}pecifying, Verifying, 
                  and Testing a Networked Server},
  booktitle = {8th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  month = jan,
  year = 2019,
  plclub = {Yes},
  bcp = {Yes},
  keys = {misc},
  short = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/deepweb-cpp-2019.pdf">http://www.cis.upenn.edu/~bcpierce/papers/deepweb-cpp-2019.pdf</a>}
}
</pre>

<a name="lampropoulos19fuzzchick"></a><pre>
@misc{<a href="plclub.html#lampropoulos19fuzzchick">lampropoulos19fuzzchick</a>,
  author = {Leonidas Lampropoulos and Michael Hicks and
                  Benjamin C. Pierce},
  title = {Coverage Guided, Property Based Testing},
  year = 2019,
  month = apr,
  short = {<a href="https://www.cs.umd.edu/~mwh/papers/lampropoulos19fuzzchick.html">https://www.cs.umd.edu/~mwh/papers/lampropoulos19fuzzchick.html</a>},
  slides = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fuzzchick-hcss2019.pdf">http://www.cis.upenn.edu/~bcpierce/papers/fuzzchick-hcss2019.pdf</a>},
  note = {To appear in PACMPL / OOPSLA 2019},
  bcp = {Yes},
  plclub = {Yes},
  keys = {verification}
}
</pre>

<a name="miltner19:symmetric"></a><pre>
@misc{<a href="plclub.html#miltner19:symmetric">miltner19:symmetric</a>,
  author = {Anders Miltner and Solomon Maina and Kathleen Fisher
                  and Benjamin C. Pierce and David Walker and Steve Zdancewic},
  title = {Synthesizing Symmetric Lenses},
  year = 2019,
  month = sep,
  note = {Accepted for publication in PACMPL / ICFP 2019},
  bcp = {Yes},
  plclub = {Yes},
  keys = {harmony}
}
</pre>

<a name="zhang19:fuzzi"></a><pre>
@misc{<a href="plclub.html#zhang19:fuzzi">zhang19:fuzzi</a>,
  author = {Hengchu Zhang and Edo Roth and Andreas Haeberlen and Benjamin C. Pierce and Aaron Roth},
  title = {Fuzzi: A Three-Level Logic for Differential Privacy},
  year = 2019,
  month = sep,
  note = {Accepted for publication in PACMPL / ICFP 2019},
  bcp = {Yes},
  plclub = {Yes},
  keys = {privacy}
}
</pre>

<a name="HosoyaPierceTurner98"></a><pre>
@unpublished{<a href="plclub.html#HosoyaPierceTurner98">HosoyaPierceTurner98</a>,
  author = {Haruo Hosoya and Benjamin C. Pierce and David N. Turner},
  title = {Datatypes and Subtyping},
  note = {Manuscript},
  plclub = {Yes},
  bcp = {Yes},
  keys = {subtyping},
  year = 1998,
  ps = {<a href="http://www.cis.upenn.edu/~bcpierce/ds.ps">http://www.cis.upenn.edu/~bcpierce/ds.ps</a>}
}
</pre>

<a name="paykin_tyde2016"></a><pre>
@inproceedings{<a href="plclub.html#paykin_tyde2016">paykin_tyde2016</a>,
  author = {Paykin, Jennifer and Spector-Zabusky, Antal and Foner, Kenneth},
  title = {Choose Your Own Derivative (Extended Abstract)},
  booktitle = {Proceedings of the 1st International Workshop on Type-Driven Development},
  series = {TyDe 2016},
  year = {2016},
  location = {Nara, Japan},
  pages = {58--59},
  numpages = {2},
  doi = {10.1145/2976022.2976024},
  fullurl = {<a href="http://www.seas.upenn.edu/~jpaykin/papers/psf_choose_2016.pdf">http://www.seas.upenn.edu/~jpaykin/papers/psf_choose_2016.pdf</a>},
  plclub = {Yes}
}
</pre>

<a name="BGHS16"></a><pre>
@inproceedings{<a href="plclub.html#BGHS16">BGHS16</a>,
  title = {Coupling proofs are probabilistic product programs},
  author = {Barthe, Gilles and
                  Gr{\'e}goire, Benjamin and
                  Hsu, Justin and
                  Strub, {P}ierre-{Y}ves},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of
                  {P}rogramming {L}anguages ({POPL}), Paris, France},
  year = 2017,
  url = {<a href="http://arxiv.org/abs/1607.03455">http://arxiv.org/abs/1607.03455</a>},
  plclub = {yes}
}
</pre>

<a name="ACGHK16"></a><pre>
@inproceedings{<a href="plclub.html#ACGHK16">ACGHK16</a>,
  title = {A semantic account of metric preservation},
  author = {de Amorim, Arthur Azevedo and
                  Cherigui, Ikram and
                  Gaboardi, Marco and
                  Hsu, Justin and
                  Katsumata, {Shin-ya}},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of
                  {P}rogramming {L}anguages ({POPL}), Paris, France},
  year = 2017,
  url = {<a href="http://justinh.su/files/papers/metric-sem.pdf">http://justinh.su/files/papers/metric-sem.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="HKM-verif16"></a><pre>
@inproceedings{<a href="plclub.html#HKM-verif16">HKM-verif16</a>,
  title = {Computer-aided verification in mechanism design},
  author = {Barthe, Gilles and
                  Gaboardi, Marco and
                  Gallego Arias, Emilio Jes{\'u}s and
                  Hsu, Justin and
                  Roth, Aaron and
                  Strub, Pierre-Yves},
  booktitle = {Conference on Web and Internet Economics (WINE), Montr{\'e}al, Qu{\'e}bec},
  year = 2016,
  url = {<a href="http://arxiv.org/abs/1502.04052">http://arxiv.org/abs/1502.04052</a>},
  plclub = {yes}
}
</pre>

<a name="BGGHS16c"></a><pre>
@inproceedings{<a href="plclub.html#BGGHS16c">BGGHS16c</a>,
  title = {Advanced probabilistic couplings for differential privacy},
  author = {Barthe, Gilles and
                  Fong, No{\'e}mie and
                  Gaboardi, Marco and
                  Gr{\'e}goire, Benjamin and
                  Hsu, Justin and
                  Strub, {P}ierre-{Y}ves},
  booktitle = {{ACM} {SIGSAC} Conference on Computer and Communications Security ({CCS}), Vienna, Austria},
  year = 2016,
  url = {https://arxiv.org/abs/1606.07143},
  plclub = {yes}
}
</pre>

<a name="privinfer"></a><pre>
@inproceedings{<a href="plclub.html#privinfer">privinfer</a>,
  title = {Differentially private {B}ayesian programming},
  author = {Barthe, Gilles and
                  Farina, Gian Pietro and
                  Gaboardi, Marco and
                  Gallego Arias, Emilio Jes{\'u}s and
                  Gordon, Andy and
                  Hsu, Justin and
                  Strub, Pierre-Yves},
  booktitle = {{ACM} {SIGSAC} Conference on Computer and Communications Security ({CCS}), Vienna, Austria},
  year = {2016},
  url = {https://arxiv.org/abs/1605.00283},
  plclub = {yes}
}
</pre>

<a name="BEFFH16"></a><pre>
@inproceedings{<a href="plclub.html#BEFFH16">BEFFH16</a>,
  title = {Synthesizing probabilistic invariants via {D}oob's decomposition},
  author = {Barthe, Gilles and
                  Espitau, Thomas and
                  Ferrer Fioriti, Luis Mar{\'i}a and
                  Hsu, Justin},
  booktitle = {International Conference on Computer Aided Verification (CAV), Toronto, Ontario},
  pages = {43--61},
  volume = {9779},
  series = {Lecture Notes in Computer Science},
  year = 2016,
  publisher = {Springer-Verlag},
  url = {https://arxiv.org/abs/1605.02765},
  plclub = {yes}
}
</pre>

<a name="BGGHS16b"></a><pre>
@inproceedings{<a href="plclub.html#BGGHS16b">BGGHS16b</a>,
  title = {A program logic for union bounds},
  author = {Barthe, Gilles and
                  Gaboardi, Marco and
                  Gr{\'e}goire, Benjamin and
                  Hsu, Justin and
                  Strub, {P}ierre-{Y}ves},
  booktitle = {International Colloquium on Automata, Languages and
                  Programming (ICALP), Rome, Italy},
  pages = {107:1--107:15},
  volume = {55},
  series = {Leibniz International Proceedings in Informatics},
  year = 2016,
  publisher = {Schloss Dagstuhl--Leibniz Center for Informatics},
  url = {<a href="http://arxiv.org/abs/1602.05681">http://arxiv.org/abs/1602.05681</a>},
  plclub = {yes}
}
</pre>

<a name="BGGHS16"></a><pre>
@inproceedings{<a href="plclub.html#BGGHS16">BGGHS16</a>,
  title = {Proving differential privacy via probabilistic couplings},
  author = {Barthe, Gilles and
                  Gaboardi, Marco and
                  Gr{\'e}goire, Benjamin and
                  Hsu, Justin and
                  Strub, {P}ierre-{Y}ves},
  booktitle = {{IEEE} {S}ymposium on {L}ogic in {C}omputer {S}cience ({LICS}), New York, New York},
  year = 2016,
  url = {<a href="http://arxiv.org/abs/1601.05047">http://arxiv.org/abs/1601.05047</a>},
  slides = {<a href="http://justinh.su/files/slides/approx-couplings.pdf">http://justinh.su/files/slides/approx-couplings.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="BEGHSS15"></a><pre>
@inproceedings{<a href="plclub.html#BEGHSS15">BEGHSS15</a>,
  title = {Relational reasoning via probabilistic coupling},
  author = {Barthe, Gilles and
                  Espitau, Thomas and
                  Gr{\'e}goire, Benjamin and
                  Hsu, Justin and
                  Stefanesco, L{\'e}o and
                  Strub, {P}ierre-{Y}ves},
  booktitle = {International Conference on Logic for Programming,
                  Artificial Intelligence and Reasoning (LPAR), Suva, Fiji},
  pages = {387--401},
  volume = {9450},
  series = {Lecture Notes in Computer Science},
  year = 2015,
  publisher = {Springer-Verlag},
  url = {<a href="http://arxiv.org/abs/1509.03476">http://arxiv.org/abs/1509.03476</a>},
  slides = {<a href="http://justinh.su/files/slides/couplings.pdf">http://justinh.su/files/slides/couplings.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="GHaccuracy"></a><pre>
@inproceedings{<a href="plclub.html#GHaccuracy">GHaccuracy</a>,
  author = {Marco Gaboardi and
                  Justin Hsu},
  title = {A {Theory AB} toolbox},
  year = {2015},
  booktitle = {Summit on Advances in Programming Languages ({SNAPL}), Asilomar, California},
  pages = {129--139},
  volume = {32},
  series = {Leibniz International Proceedings in Informatics},
  publisher = {Schloss Dagstuhl--Leibniz Center for Informatics},
  url = {<a href="http://justinh.su/files/papers/theory-ab.pdf">http://justinh.su/files/papers/theory-ab.pdf</a>},
  slides = {<a href="http://justinh.su/files/slides/theory-ab.pdf">http://justinh.su/files/slides/theory-ab.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="BGGHRS15"></a><pre>
@inproceedings{<a href="plclub.html#BGGHRS15">BGGHRS15</a>,
  title = {Higher-order approximate relational refinement types for
                  mechanism design and differential privacy},
  author = {Barthe, Gilles and
                  Gaboardi, Marco and
                  Gallego Arias, Emilio Jes{\'u}s and
                  Hsu, Justin and
                  Roth, Aaron and
                  Strub, Pierre-Yves},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of
                  {P}rogramming {L}anguages ({POPL}), Mumbai, India},
  pages = {55--68},
  year = {2015},
  url = {<a href="http://arxiv.org/abs/1407.6845">http://arxiv.org/abs/1407.6845</a>},
  slides = {<a href="http://justinh.su/files/slides/hoare2.pdf">http://justinh.su/files/slides/hoare2.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="HsuTaxes"></a><pre>
@inproceedings{<a href="plclub.html#HsuTaxes">HsuTaxes</a>,
  author = {Justin Hsu},
  title = {Death, taxes, and formal verification (Abstract)},
  year = {2015},
  booktitle = {Summit on Advances in Programming Languages ({SNAPL}), Asilomar, California},
  slides = {<a href="http://justinh.su/files/slides/taxes.pdf">http://justinh.su/files/slides/taxes.pdf</a>},
  url = {<a href="http://justinh.su/files/papers/taxes.pdf">http://justinh.su/files/papers/taxes.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="AGGH14"></a><pre>
@inproceedings{<a href="plclub.html#AGGH14">AGGH14</a>,
  author = {de Amorim, Arthur Azevedo and
                  Gaboardi, Marco and
                  Gallego Arias, Emilio Jes{\'u}s and
                  Hsu, Justin},
  title = {Really natural linear indexed type-checking},
  booktitle = {Symposium on Implementation and Application of Functional
                  Programming Languages (IFL), Boston, Massachusetts},
  pages = {5:1--5:12},
  year = {2014},
  publisher = {ACM Press},
  url = {<a href="http://arxiv.org/abs/1503.04522">http://arxiv.org/abs/1503.04522</a>},
  slides = {<a href="http://justinh.su/files/slides/dfuzz-tc.pdf">http://justinh.su/files/slides/dfuzz-tc.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="BGGHKS14"></a><pre>
@inproceedings{<a href="plclub.html#BGGHKS14">BGGHKS14</a>,
  author = {Barthe, Gilles and
                  Gaboardi, Marco and
                  Gallego Arias, Emilio Jes{\'u}s and
                  Hsu, Justin and
                  Kunz, C\'esar and
                  Strub, Pierre-Yves},
  title = {Proving differential privacy in {H}oare logic},
  booktitle = {{IEEE} {C}omputer {S}ecurity {F}oundations {S}ymposium
                  ({CSF}), Vienna, Austria},
  pages = {411--424},
  year = {2014},
  url = {<a href="http://arxiv.org/abs/1407.2988">http://arxiv.org/abs/1407.2988</a>},
  plclub = {yes}
}
</pre>

<a name="HGH14"></a><pre>
@inproceedings{<a href="plclub.html#HGH14">HGH14</a>,
  author = {Hsu, Justin and
                  Gaboardi, Marco and
                  Haeberlen, Andreas and
                  Khanna, Sanjeev and
                  Narayan, Arjun and
                  Pierce, Benjamin C. and
                  Roth, Aaron},
  title = {Differential privacy: An economic method for choosing epsilon},
  booktitle = {{IEEE} {C}omputer {S}ecurity {F}oundations {S}ymposium
                  ({CSF}), Vienna, Austria},
  pages = {398--410},
  year = 2014,
  url = {<a href="http://arxiv.org/abs/1402.3329">http://arxiv.org/abs/1402.3329</a>},
  slides = {<a href="http://justinh.su/files/slides/epsilon.pdf">http://justinh.su/files/slides/epsilon.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="WHE13"></a><pre>
@inproceedings{<a href="plclub.html#WHE13">WHE13</a>,
  title = {{S}ystem {FC} with explicit kind equality},
  author = {Weirich, Stephanie and
                  Hsu, Justin and
                  Eisenberg, Richard A.},
  booktitle = {{ACM} {SIGPLAN} {I}nternational {C}onference on
                  {F}unctional {P}rogramming ({ICFP}), Boston, Massachusetts},
  pages = {275--286},
  year = {2013},
  url = {<a href="http://www.cis.upenn.edu/~justhsu/docs/nokinds.pdf">http://www.cis.upenn.edu/~justhsu/docs/nokinds.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="GHHNP13"></a><pre>
@inproceedings{<a href="plclub.html#GHHNP13">GHHNP13</a>,
  title = {Linear dependent types for differential privacy},
  author = {Gaboardi, Marco and
                  Haeberlen, Andreas and
                  Hsu, Justin and
                  Narayan, Arjun and
                  Pierce, Benjamin C.},
  booktitle = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of
                  {P}rogramming {L}anguages ({POPL}), Rome, Italy},
  pages = {357--370},
  url = {<a href="http://dl.acm.org/citation.cfm?id=2429113">http://dl.acm.org/citation.cfm?id=2429113</a>},
  year = {2013},
  plclub = {yes}
}
</pre>

<a name="GGHHP13"></a><pre>
@inproceedings{<a href="plclub.html#GGHHP13">GGHHP13</a>,
  title = {Automatic sensitivity analysis using linear dependent types},
  author = {Gaboardi, Marco and
                  Gallego Arias, Emilio Jes{\'u}s and
                  Haeberlen, Andreas and
                  Hsu, Justin and
                  Pierce, Benjamin C.},
  url = {<a href="http://fopara2013.cs.unibo.it/paper_8.pdf">http://fopara2013.cs.unibo.it/paper_8.pdf</a>},
  booktitle = {International Workshop on Foundational and Practical
                  Aspects of Resource Analysis (FOPARA){, informal proceedings}},
  year = {2013},
  plclub = {yes}
}
</pre>

<a name="weirich:dep-roles"></a><pre>
@article{<a href="plclub.html#weirich:dep-roles">weirich:dep-roles</a>,
  author = {Stephanie Weirich and Pritam Choudhury and Antoine Voizard and Richard Eisenberg},
  title = {A Role for Dependent Types in {Haskell}},
  journal = {Proc. ACM Program. Lang.},
  year = 2019,
  issue_date = {August 2019},
  number = {ICFP},
  publisher = {ACM},
  address = {New York, NY, USA},
  url = {papers/icfp19.pdf},
  doi = {10.1145/3341705},
  plclub = {yes}
}
</pre>

<a name="Breitner:2018:set"></a><pre>
@article{<a href="plclub.html#Breitner:2018:set">Breitner:2018:set</a>,
  author = {Breitner, Joachim and Spector-Zabusky, Antal and Li, Yao and Rizkallah, Christine and Wiegley, John and Weirich, Stephanie},
  title = {Ready, Set, Verify! {Applying} Hs-to-coq to Real-world {Haskell} Code ({Experience} Report)},
  journal = {Proc. ACM Program. Lang.},
  issue_date = {September 2018},
  volume = {2},
  number = {ICFP},
  month = jul,
  year = {2018},
  issn = {2475-1421},
  pages = {89:1--89:16},
  articleno = {89},
  numpages = {16},
  url = {<a href="http://doi.acm.org/10.1145/3236784">http://doi.acm.org/10.1145/3236784</a>},
  doi = {10.1145/3236784},
  acmid = {3236784},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {Coq, Haskell, verification},
  plclub = {yes}
}
</pre>

<a name="coqpl18"></a><pre>
@misc{<a href="plclub.html#coqpl18">coqpl18</a>,
  author = {Stephanie Weirich, Antoine Voizard, Anastasiya Kravchuk-Kirilyuk},
  title = {Locally Nameless at Scale},
  howpublished = {The Fourth International Workshop on Coq for Programming Languages},
  month = jan,
  year = 2018,
  pdf = {papers/coqpl2018.pdf},
  plclub = {yes}
}
</pre>

<a name="antalsz:hs-to-coq"></a><pre>
@inproceedings{<a href="plclub.html#antalsz:hs-to-coq">antalsz:hs-to-coq</a>,
  author = {Antal Spector-Zabusky and Joachim Breitner and Christine Rizkallah and Stephanie Weirich
},
  title = {Total {Haskell} is Reasonable {Coq}},
  booktitle = {Proceedings of 7th ACM SIGPLAN International Conference on Certified
Programs and Proofs (CPP'18)},
  year = 2018,
  publisher = {ACM},
  note = {New York, NY, USA},
  plclub = {yes},
  doi = {10.1145/3167092},
  pdf = {https://arxiv.org/abs/1711.09286}
}
</pre>

<a name="weirich:systemd"></a><pre>
@article{<a href="plclub.html#weirich:systemd">weirich:systemd</a>,
  author = {Weirich, Stephanie and Voizard, Antoine and de Amorim, Pedro Henrique Avezedo and Eisenberg, Richard A.},
  title = {A Specification for Dependent Types in {Haskell}},
  journal = {Proc. ACM Program. Lang.},
  issue_date = {September 2017},
  volume = {1},
  number = {ICFP},
  month = aug,
  year = {2017},
  issn = {2475-1421},
  pages = {31:1--31:29},
  articleno = {31},
  numpages = {29},
  url = {<a href="http://doi.acm.org/10.1145/3110275">http://doi.acm.org/10.1145/3110275</a>},
  doi = {10.1145/3110275},
  acmid = {3110275},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {Dependent Types, Haskell},
  plclub = {yes}
}
</pre>

<a name="breitner2016"></a><pre>
@article{<a href="plclub.html#breitner2016">breitner2016</a>,
  title = {Safe zero-cost coercions for {Haskell}},
  doi = {10.1017/S0956796816000150},
  publisher = {Cambridge University Press},
  address = {Cambridge, UK},
  author = {Joachim Breitner and Richard A. Eisenberg and Simon Peyton Jones and
Stephanie Weirich},
  volume = {26},
  year = {2016},
  month = {007},
  day = {28},
  plclub = {yes},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/coercible-JFP.pdf">http://www.seas.upenn.edu/~sweirich/papers/coercible-JFP.pdf</a>},
  abstract = {AbstractGenerative type abstractions – present in Haskell, OCaml, and other languages – are useful concepts to help prevent programmer errors. They serve to create new types that are distinct at compile time but share a run-time representation with some base type. We present a new mechanism that allows for zero-cost conversions between generative type abstractions and their representations, even when such types are deeply nested. We prove type safety in the presence of these conversions and have implemented our work in GHC.},
  url = {https://www.cambridge.org/core/article/safe-zero-cost-coercions-for-haskell/FFB002A34C6B40EF150B5F357AA865DC},
  journal = {Journal of Functional Programming}
}
</pre>

<a name="keuchel:infragen"></a><pre>
@inproceedings{<a href="plclub.html#keuchel:infragen">keuchel:infragen</a>,
  author = {Steven Keuchel and Stephanie Weirich and Thomas Tom Schrijvers},
  title = {InfraGen: Binder Boilerplate at Scale},
  booktitle = {European Symposium on Programming (ESOP)},
  month = apr,
  pages = {419-445},
  plclub = {Yes},
  year = 2016
}
</pre>

<a name="type-app"></a><pre>
@inproceedings{<a href="plclub.html#type-app">type-app</a>,
  author = {Richard A. Eisenberg and Stephanie Weirich and Hamidhasan G. Ahmed},
  title = {Visible Type Application},
  booktitle = {European Symposium on Programming (ESOP)},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/esop2016-typeapp.pdf">http://www.seas.upenn.edu/~sweirich/papers/esop2016-typeapp.pdf</a>},
  month = apr,
  pages = {229-254},
  plclub = {Yes},
  year = 2016
}
</pre>

<a name="pj:reflection-types"></a><pre>
@incollection{<a href="plclub.html#pj:reflection-types">pj:reflection-types</a>,
  author = {Simon {Peyton Jones} and Stephanie Weirich and Richard A. Eisenberg and
             Dimitrios Vytiniotis},
  title = {A Reflection on Types},
  booktitle = {WadlerFest 2016: A list of successes that can change the world},
  editor = {Sam Lindley and Conor McBride and Phil Trinder and Don Sannella},
  year = 2016,
  publisher = {Springer},
  pages = {292-317},
  series = {LNCS},
  plclub = {Yes},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/wadlerfest2016.pdf">http://www.seas.upenn.edu/~sweirich/papers/wadlerfest2016.pdf</a>}
}
</pre>

<a name="rsgen"></a><pre>
@inproceedings{<a href="plclub.html#rsgen">rsgen</a>,
  author = {Wenrui Meng and Junkil Park and Oleg Sokolsky and
                  Stephanie Weirich and Insup Lee},
  title = {Verified ROS-Based Deployment of Platform-Independent Control Systems},
  booktitle = {Seventh {NASA} Formal Methods Symposium},
  address = {Pasadena, CA},
  mon = apr,
  pages = {248-262},
  plclub = {Yes},
  pdf = {<a href="http://repository.upenn.edu/cis_papers/794/">http://repository.upenn.edu/cis_papers/794/</a>},
  year = 2015
}
</pre>

<a name="sjoberg:congruence"></a><pre>
@inproceedings{<a href="plclub.html#sjoberg:congruence">sjoberg:congruence</a>,
  author = {Vilhelm Sj\"oberg and Stephanie Weirich},
  title = {Programming up to Congruence},
  booktitle = {POPL 2015: 42nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  month = jan,
  year = 2015,
  address = {Mumbai, India},
  plclub = {yes},
  pages = {369--382},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/popl15-congruence.pdf">http://www.seas.upenn.edu/~sweirich/papers/popl15-congruence.pdf</a>}
}
</pre>

<a name="breitner:safe-coercions"></a><pre>
@inproceedings{<a href="plclub.html#breitner:safe-coercions">breitner:safe-coercions</a>,
  author = {Joachim Breitner and Richard A. Eisenberg and Simon {Peyton Jones} and Stephanie Weirich},
  title = {Safe Zero-Cost Coercions for {Haskell}},
  booktitle = {The 19th ACM SIGPLAN International Conference on Functional Programming},
  year = 2014,
  pages = {189--202},
  series = {ICFP '14},
  month = sep,
  plclub = {yes},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/coercible.pdf">http://www.seas.upenn.edu/~sweirich/papers/coercible.pdf</a>}
}
</pre>

<a name="eisenberg:closed-tf"></a><pre>
@inproceedings{<a href="plclub.html#eisenberg:closed-tf">eisenberg:closed-tf</a>,
  author = {Richard A. Eisenberg and Dimitrios Vytiniotis and Simon {Peyton Jones} and Stephanie Weirich},
  title = {Closed type families with overlapping equations},
  booktitle = {POPL 2014: 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  year = 2014,
  month = jan,
  pages = {671--683},
  address = {San Diego, CA, USA},
  plclub = {yes},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/popl14-axioms.pdf">http://www.seas.upenn.edu/~sweirich/papers/popl14-axioms.pdf</a>},
  extended = {<a href="http://www.seas.upenn.edu/~sweirich/papers/popl14-axioms-extended.pdf">http://www.seas.upenn.edu/~sweirich/papers/popl14-axioms-extended.pdf</a>}
}
</pre>

<a name="casinghino:combining-proofs-programs"></a><pre>
@inproceedings{<a href="plclub.html#casinghino:combining-proofs-programs">casinghino:combining-proofs-programs</a>,
  author = {Chris Casinghino and Vilhelm Sj\"oberg and Stephanie Weirich},
  title = {Combining Proofs and Programs in a Dependently Typed Language},
  booktitle = {POPL 2014: 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  year = 2014,
  address = {San Diego, CA, USA},
  pages = {33--45},
  plclub = {yes},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/popl14-trellys.pdf">http://www.seas.upenn.edu/~sweirich/papers/popl14-trellys.pdf</a>},
  extended = {<a href="http://www.seas.upenn.edu/~sweirich/papers/popl14-trellys-long.pdf">http://www.seas.upenn.edu/~sweirich/papers/popl14-trellys-long.pdf</a>}
}
</pre>

<a name="eisenberg:closed-tf-extended"></a><pre>
@techreport{<a href="plclub.html#eisenberg:closed-tf-extended">eisenberg:closed-tf-extended</a>,
  author = {Richard A. Eisenberg and Dimitrios Vytiniotis and Simon {Peyton Jones} and Stephanie Weirich},
  title = {Closed type families with overlapping equations (Extended version)},
  year = 2013,
  month = nov,
  plclub = {yes},
  pdf = {<a href="http://repository.upenn.edu/cis_reports/990/">http://repository.upenn.edu/cis_reports/990/</a>},
  institution = {University of Pennsylvania},
  number = {MS-CIS-13-10}
}
</pre>

<a name="weirich:dwk"></a><pre>
@inproceedings{<a href="plclub.html#weirich:dwk">weirich:dwk</a>,
  author = {Stephanie Weirich and Justin Hsu and Richard A. Eisenberg},
  title = {System {FC} with explicit kind equality},
  booktitle = {Proceedings of The 18th ACM SIGPLAN International Conference on Functional Programming},
  year = 2013,
  series = {ICFP '13},
  address = {Boston, MA},
  pages = {275--286},
  plclub = {yes},
  month = sep,
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf">http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf</a>}
}
</pre>

<a name="pii13preface"></a><pre>
@misc{<a href="plclub.html#pii13preface">pii13preface</a>,
  author = {Zhengjiang Hu and Shin-Cheng Mu and Stephanie Weirich},
  title = {Advanced programming techniques for construction of robust, generic and evolutionary programs},
  journal = {Progress in Informatics},
  number = 10,
  year = 2013,
  month = mar,
  pages = {1--2},
  plclub = {yes},
  url = {<a href="http://www.nii.ac.jp/pi/">http://www.nii.ac.jp/pi/</a>}
}
</pre>

<a name="pii13kimmel"></a><pre>
@article{<a href="plclub.html#pii13kimmel">pii13kimmel</a>,
  author = {
Garrin Kimmel and Aaron Stump and Harley D. Eades and Peng Fu and Tim Sheard and Stephanie
Weirich and Chris Casinghino and Vilhelm Sj\"{o}berg and Nathin Collins and Ki Yunh Anh},
  title = {Equational reasoning about programs with general recursion and call-by-value
semantics},
  journal = {Progress in Informatics},
  number = 10,
  year = 2013,
  month = mar,
  pages = { 19--48},
  plclub = {yes},
  url = {<a href="http://www.nii.ac.jp/pi/">http://www.nii.ac.jp/pi/</a>}
}
</pre>

<a name="sparcs"></a><pre>
@inproceedings{<a href="plclub.html#sparcs">sparcs</a>,
  author = {Pajic, Miroslav and Bezzo, Nicola and Weimer, James and Alur, Rajeev and Mangharam, Rahul and Michael, Nathan and Pappas, George J. and Sokolsky, Oleg and Tabuada, Paulo and Weirich, Stephanie and Lee, Insup},
  title = {Towards synthesis of platform-aware attack-resilient control systems: extended abstract},
  booktitle = {HiCoNS '13: Proceedings of the 2nd ACM international conference on High confidence networked systems},
  year = {2013},
  isbn = {978-1-4503-1961-4},
  pages = {75--76},
  location = {Philadelphia, Pennsylvania, USA},
  address = {New York, NY, USA},
  plclub = {yes}
}
</pre>

<a name="DBLP:journals/jar/PierceW12"></a><pre>
@misc{<a href="plclub.html#DBLP:journals/jar/PierceW12">DBLP:journals/jar/PierceW12</a>,
  author = {Benjamin C. Pierce and
               Stephanie Weirich},
  title = {Preface},
  journal = {J. Autom. Reasoning},
  volume = {49},
  number = {3},
  year = {2012},
  pages = {301-302},
  ee = {<a href="http://dx.doi.org/10.1007/s10817-012-9254-5">http://dx.doi.org/10.1007/s10817-012-9254-5</a>},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  plclub = {yes}
}
</pre>

<a name="plmw12"></a><pre>
@misc{<a href="plclub.html#plmw12">plmw12</a>,
  author = {Kathleen Fisher and Ronald Garcia and Stephanie Weirich},
  title = {Nourishing the future of the field: the programming language mentoring workshop 2012},
  booktitle = {ACM SIGPLAN Notices - Supplemental issue},
  journal = {SIGPLAN Not.},
  month = {April},
  year = 2012,
  volume = 47,
  number = {4a},
  issue_date = {April 2012},
  issue_description = {Supplemental issue},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi = {10.1145/2442776.2448985},
  pages = {14--15},
  plclub = {yes}
}
</pre>

<a name="DBLP:journals/jfp/AcarCW12"></a><pre>
@misc{<a href="plclub.html#DBLP:journals/jfp/AcarCW12">DBLP:journals/jfp/AcarCW12</a>,
  author = {Umut A. Acar and
               James Cheney and
               Stephanie Weirich},
  title = {Editorial - Special issue dedicated to {ICFP 2010}},
  journal = {J. Funct. Program.},
  volume = {22},
  number = {4-5},
  year = {2012},
  pages = {379-381},
  ee = {<a href="http://dx.doi.org/10.1017/S0956796812000287">http://dx.doi.org/10.1017/S0956796812000287</a>},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  plclub = {yes}
}
</pre>

<a name="greenberg:jfp"></a><pre>
@article{<a href="plclub.html#greenberg:jfp">greenberg:jfp</a>,
  author = {Michael Greenberg and
               Benjamin C. Pierce and
               Stephanie Weirich},
  title = {Contracts made manifest},
  journal = {Journal of Functional Programming},
  volume = {22},
  number = {3},
  month = {May},
  year = {2012},
  pages = {225-274},
  ee = {<a href="http://dx.doi.org/10.1017/S0956796812000135">http://dx.doi.org/10.1017/S0956796812000135</a>},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  plclub = {yes}
}
</pre>

<a name="weirich:icfp14"></a><pre>
@misc{<a href="plclub.html#weirich:icfp14">weirich:icfp14</a>,
  author = {Stephanie Weirich},
  title = {Depending on Types},
  year = 2014,
  note = {Invited keynote given at ICFP 2014},
  plclub = {yes}
}
</pre>

<a name="weirich:flops12"></a><pre>
@misc{<a href="plclub.html#weirich:flops12">weirich:flops12</a>,
  author = {Stephanie Weirich},
  title = {Dependently typed programming in GHC},
  note = {Invited keynote given at FLOPS 2012},
  slides = {<a href="http://www.seas.upenn.edu/~sweirich/talks/flops2012.pdf">http://www.seas.upenn.edu/~sweirich/talks/flops2012.pdf</a>},
  month = {May},
  year = 2012,
  plclub = {yes}
}
</pre>

<a name="weirich:tlca11"></a><pre>
@misc{<a href="plclub.html#weirich:tlca11">weirich:tlca11</a>,
  author = {Stephanie Weirich},
  title = {Combining Proofs and Programs},
  note = {Joint invited speaker for Rewriting Techniques and Applications (RTA 2011) and Typed Lambda Calculi and Applications (TLCA 2011)},
  slides = {<a href="http://www.seas.upenn.edu/~sweirich/talks/tlca-2011.pdf">http://www.seas.upenn.edu/~sweirich/talks/tlca-2011.pdf</a>},
  month = jun,
  year = 2011,
  plclub = {yes}
}
</pre>

<a name="ccasin:msfp12"></a><pre>
@inproceedings{<a href="plclub.html#ccasin:msfp12">ccasin:msfp12</a>,
  author = {Chris Casinghino and Vilhelm Sj\"{o}berg and Stephanie Weirich},
  title = {Step-Indexed Normalization for a Language with General Recursion},
  booktitle = {Fourth workshop on Mathematically Structured Functional Programming (MSFP '12)},
  year = 2012,
  pages = {25--39},
  pdf = {papers/msfp12log.pdf},
  plclub = {yes}
}
</pre>

<a name="sjoberg:msfp12"></a><pre>
@inproceedings{<a href="plclub.html#sjoberg:msfp12">sjoberg:msfp12</a>,
  author = {Vilhelm Sj\"oberg and Chris Casinghino and Ki Yung Ahn and
            Nathan Collins and Harley D. Eades III and Peng Fu
            and Garrin Kimmell and Tim Sheard and Aaron Stump
            and Stephanie Weirich},
  title = {Irrelevance, Heterogenous Equality, and Call-by-value Dependent Type Systems},
  booktitle = {Fourth workshop on Mathematically Structured Functional Programming (MSFP '12)},
  year = 2012,
  pages = {112--162},
  plclub = {yes},
  pdf = {papers/msfp12prog.pdf}
}
</pre>

<a name="kimmel:plpv"></a><pre>
@inproceedings{<a href="plclub.html#kimmel:plpv">kimmel:plpv</a>,
  author = {Garrin Kimmell and Aaron Stump and Harley D. Eades III and
                 Peng Fu and Tim Sheard and Stephanie Weirich and Chris Casinghino
                 and Vilhelm Sj\"oberg and Nathan Collins and Ki Yung Ahn},
  title = {Equational Reasoning about Programs with General Recursion and Call-by-value Semantics},
  booktitle = {Sixth ACM SIGPLAN Workshop Programming Languages meets Program Verification (PLPV '12)},
  year = 2012,
  plclub = {yes},
  pages = {15--26},
  pdf = {papers/plpv2012genreccbv.pdf}
}
</pre>

<a name="weirich:lifting"></a><pre>
@inproceedings{<a href="plclub.html#weirich:lifting">weirich:lifting</a>,
  author = {Brent A. Yorgey and Stephanie Weirich and
                  Julien Cretin and Simon {Peyton Jones} and
                  Dimitrios Vytiniotis and Jos\'{e} Pedro {Magalha\~{e}s}},
  title = {Giving {Haskell} A Promotion},
  booktitle = {Seventh ACM SIGPLAN Workshop on Types in Language Design and Implementation (TLDI '12)},
  year = 2012,
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/tldi12.pdf">http://www.seas.upenn.edu/~sweirich/papers/tldi12.pdf</a>},
  pages = {53--66},
  plclub = {yes}
}
</pre>

<a name="weirich:binders"></a><pre>
@inproceedings{<a href="plclub.html#weirich:binders">weirich:binders</a>,
  author = {Stephanie Weirich and Brent A. Yorgey and Tim Sheard},
  title = {Binders Unbound},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/icfp11.pdf">http://www.seas.upenn.edu/~sweirich/papers/icfp11.pdf</a>},
  booktitle = {Proceeding of the 16th ACM SIGPLAN International Conference on Functional Programming},
  series = {ICFP '11},
  year = {2011},
  isbn = {978-1-4503-0865-6},
  location = {Tokyo, Japan},
  pages = {333--345},
  numpages = {13},
  acmid = {2034818},
  address = {New York, NY, USA},
  keywords = {generic programming, haskell, name binding, patterns},
  plclub = {yes}
}
</pre>

<a name="stump:position"></a><pre>
@inproceedings{<a href="plclub.html#stump:position">stump:position</a>,
  author = {Tim Sheard and Aaron Stump and Stephanie Weirich},
  title = {Language-Based Verification Will Change The World},
  booktitle = {2010 FSE/SDP Workshop on the Future of Software Engineering Research},
  year = 2010,
  month = nov,
  plclub = {yes},
  pages = {343--348},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/foser10.pdf">http://www.seas.upenn.edu/~sweirich/papers/foser10.pdf</a>},
  note = {Position paper.}
}
</pre>

<a name="weirich:newtypes"></a><pre>
@inproceedings{<a href="plclub.html#weirich:newtypes">weirich:newtypes</a>,
  author = {Stephanie Weirich and Dimitrios Vytiniotis and Simon {Peyton Jones}
  and Steve Zdancewic},
  title = {Generative Type Abstraction and Type-level Computation},
  booktitle = {POPL 11: 38th {ACM SIGACT-SIGPLAN} Symposium on Principles of Programming Languages, January 26--28, 2011. Austin, TX, USA.},
  year = 2011,
  pages = {227--240},
  month = jan,
  plclub = {yes},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf">http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf</a>},
  abstract = {Modular languages support generative type abstraction,
ensuring that an abstract type is distinct from its
representation, except inside the implementation where the
two are synonymous.  We show that this well-established
feature is in tension with the non-parametric features
of newer type systems, such as indexed type families and GADTs.
In this paper we solve the problem by using kinds to
distinguish between parametric and non-parametric contexts.
The result is directly applicable to Haskell, which is rapidly
developing support for type-level computation, but the same
issues should arise whenever generativity and non-parametric features
are combined.}
}
</pre>

<a name="Haskell09"></a><pre>
@proceedings{<a href="plclub.html#Haskell09">Haskell09</a>,
  title = {Haskell Symposium},
  editor = {Stephanie Weirich},
  publisher = {ACM Press},
  year = {2009},
  month = aug,
  location = {Edinburgh, Scotland, August 2009},
  plclub = {Yes}
}
</pre>

<a name="Weirich:Haskell09ChairsReport"></a><pre>
@misc{<a href="plclub.html#Weirich:Haskell09ChairsReport">Weirich:Haskell09ChairsReport</a>,
  author = {Stephanie Weirich},
  title = {Haskell 2009 PC Chair's Report},
  month = aug,
  year = {2009},
  plclub = {Yes}
}
</pre>

<a name="ICFP10"></a><pre>
@proceedings{<a href="plclub.html#ICFP10">ICFP10</a>,
  title = {International Conference on Functional Programming},
  editor = {Stephanie Weirich},
  publisher = {ACM Press},
  year = {2010},
  month = sep,
  location = {Baltimore, MD, September 2010},
  plclub = {Yes}
}
</pre>

<a name="Weirich:ICFP10ChairsReport"></a><pre>
@misc{<a href="plclub.html#Weirich:ICFP10ChairsReport">Weirich:ICFP10ChairsReport</a>,
  author = {Stephanie Weirich},
  title = {ICFP 2010 PC Chair's Report},
  month = sep,
  year = {2010},
  plclub = {Yes}
}
</pre>

<a name="teqt"></a><pre>
@inproceedings{<a href="plclub.html#teqt">teqt</a>,
  author = {Aaron Stump and Vilhelm Sj\"{o}berg and Stephanie Weirich},
  title = {Termination Casts: A Flexible Approach to Termination with
General Recursion},
  booktitle = {Workshop on Partiality and Recursion in Interactive Theorem Provers},
  year = 2010,
  address = {Edinburgh, Scotland},
  plclub = {yes},
  pages = {76--93},
  month = jul,
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/submitted-PAR-10-Proceedings.pdf">http://www.seas.upenn.edu/~sweirich/papers/submitted-PAR-10-Proceedings.pdf</a>},
  abstract = {
This paper proposes a type-and-effect system that
distinguishes terminating terms and total functions from possibly
diverging terms and partial functions, for a lambda calculus with
general recursion and equality types.  The central idea is to include
a primitive type-form ``Terminates t'', expressing that term t is
terminating; and then allow terms t to be coerced from possibly
diverging to total, using a proof of Terminates t.  We call such
coercions \emph{termination casts}, and show how to implement
terminating recursion using them.  For the meta-theory of the system,
we describe a translation from this system to a logical theory of
termination for general recursive, simply typed functions.  Every
typing judgment of this system is translated to a theorem expressing the
appropriate termination property of the computational part of the
term.}
}
</pre>

<a name="iseq"></a><pre>
@inproceedings{<a href="plclub.html#iseq">iseq</a>,
  author = {Limin Jia and Jianzhou Zhao and Vilhem Sj\"{o}berg and Stephanie Weirich},
  title = {Dependent types and Program Equivalence},
  booktitle = {37th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL)},
  year = 2010,
  address = {Madrid, Spain},
  month = jan,
  plclub = {yes},
  pages = {275--286},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/popl10-lambda-eek.pdf">http://www.seas.upenn.edu/~sweirich/papers/popl10-lambda-eek.pdf</a>},
  project = {<a href="http://www.cis.upenn.edu/~plclub/lambda-eek">http://www.cis.upenn.edu/~plclub/lambda-eek</a>},
  abstract = {The definition of type equivalence is one of the most important design
issues for any typed language. In dependently-typed languages, because
terms appear in types, this definition must rely on a definition of
term equivalence. In that case, decidability of type checking requires
decidability for the term equivalence relation.

Almost all dependently-typed languages require this relation to be
decidable. Some, such as Coq, Epigram or Agda, do so by employing
analyses to force all programs to terminate. Conversely, others, such
as DML, ATS, Omega, or Haskell, allow nonterminating computation, but
do not allow those terms to appear in types. Instead, they identify a
terminating index language and use singleton types to connect indices
to computation. In both cases, decidable type checking comes at a
cost, in terms of complexity and expressiveness.

Conversely, the benefits to be gained by decidable type checking are
modest. Termination analyses allow dependently typed programs to
verify total correctness properties. However, decidable type checking
is not a prerequisite for type safety.  Furthermore, decidability does
not imply tractability. A decidable approximation of program
equivalence may not be useful in practice.

Therefore, we take a different approach: instead of a fixed notion for
term equi valence, we parameterize our type system with an abstract
relation that is not n ecessarily decidable. We then design a novel
set of typing rules that require on ly weak properties of this
abstract relation in the proof of the preservation an d progress
lemmas. This design provides flexibility: we compare valid instantiat
ions of term equivalence which range from beta-equivalence, to
contextual equiva lence, to some exotic equivalences.
}
}
</pre>

<a name="vytiniotis:romega"></a><pre>
@article{<a href="plclub.html#vytiniotis:romega">vytiniotis:romega</a>,
  author = {Dimitrios Vytiniotis and Stephanie Weirich},
  title = {Parametricity, Type Equality and Higher-order Polymorphism},
  journal = {Journal of Functional Programming},
  year = 2010,
  month = mar,
  volume = 20,
  number = 2,
  pages = {175--210},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~sweirich/papers/gparam-jfp2.pdf">http://www.cis.upenn.edu/~sweirich/papers/gparam-jfp2.pdf</a>},
  abstract = {
  Propositions that express type equality are a frequent ingredient of
  modern functional programming---they can encode generic
  functions, dynamic types, and GADTs. Via the Curry-Howard
  correspondence, these propositions are ordinary types
  inhabited by proof terms, computed using runtime type
  representations. In this paper we show that two examples of type
  equality propositions actually do reflect type equality; they are
  only inhabited when their arguments are equal and their proofs are
  unique (up to contextual equivalence.)  We show this result in the
  context of a strongly normalizing language with higher-order
  polymorphism and primitive recursion over runtime type
  representations by proving Reynolds's abstraction theorem. We then
  use this theorem to derive ``free'' theorems about equality types.
}
}
</pre>

<a name="weirich:aritygen-journal"></a><pre>
@incollection{<a href="plclub.html#weirich:aritygen-journal">weirich:aritygen-journal</a>,
  author = {Stephanie Weirich and Chris Casinghino},
  editor = {Jeremy Gibbons},
  booktitle = {Generic and Indexed Programming},
  title = {Generic Programming with Dependent Types},
  publisher = {Springer-Verlag Berlin Heidelberg},
  year = 2012,
  pdf = {<a href="http://www.cis.upenn.edu/~sweirich/papers/ssgip-journal.pdf">http://www.cis.upenn.edu/~sweirich/papers/ssgip-journal.pdf</a>},
  number = 7470,
  series = {Lecture Notes in Computer Science},
  plclub = {yes},
  pages = {217--258}
}
</pre>

<a name="aritygen"></a><pre>
@inproceedings{<a href="plclub.html#aritygen">aritygen</a>,
  author = {Stephanie Weirich and Chris Casinghino},
  title = {Arity-generic type-generic programming},
  booktitle = {{ACM SIGPLAN} Workshop on Programming Languages Meets Program Verification (PLPV)},
  pages = {15--26},
  month = jan,
  plclub = {yes},
  year = 2010,
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/aritygen.pdf">http://www.seas.upenn.edu/~sweirich/papers/aritygen.pdf</a>}
}
</pre>

<a name="aydemir:lngen"></a><pre>
@techreport{<a href="plclub.html#aydemir:lngen">aydemir:lngen</a>,
  title = {LNgen: Tool Support for Locally Nameless Representations},
  author = {Brian Aydemir and Stephanie Weirich},
  institution = {Computer and Information Science, University of Pennsylvania},
  month = jun,
  year = 2010,
  plclub = {yes},
  number = {MS-CIS-10-24},
  pdf = {<a href="http://repository.upenn.edu/cis_reports/933">http://repository.upenn.edu/cis_reports/933</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/MS-CIS-10-24.pdf">http://www.seas.upenn.edu/~sweirich/papers/MS-CIS-10-24.pdf</a>},
  projecturl = {<a href="http://www.cis.upenn.edu/~sweirich/papers/lngen/">http://www.cis.upenn.edu/~sweirich/papers/lngen/</a>}
}
</pre>

<a name="vytiniotis:fph"></a><pre>
@inproceedings{<a href="plclub.html#vytiniotis:fph">vytiniotis:fph</a>,
  author = {Dimitrios Vytiniotis and Stephanie Weirich and Simon Peyton Jones},
  title = {{FPH:} First-class polymorphism for {Haskell}},
  booktitle = {ICFP 2008: The 13th ACM SIGPLAN International Conference on Functional Programming },
  year = 2008,
  address = {Victoria, BC, Canada},
  month = sep,
  plclub = {yes},
  pages = {295--306},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/icfp08.pdf">http://www.seas.upenn.edu/~sweirich/papers/icfp08.pdf</a>},
  abstract = {Languages supporting polymorphism typically have ad-hoc restrictions
on where polymorphic types may occur.  Supporting ``first-class'' polymorphism,
by lifting those restrictions, is obviously desirable, but it is hard
to achieve this without sacrificing type inference.  We present a new
type system for higher-rank and impredicative polymorphism that improves
on earlier proposals: it is an extension of Damas-Milner;
it relies only on System F types; it has a simple, declarative specification;
it is robust to program transformations; and it enjoys a complete and decidable
type inference algorithm.
}
}
</pre>

<a name="vytiniotis07a"></a><pre>
@inproceedings{<a href="plclub.html#vytiniotis07a">vytiniotis07a</a>,
  author = {Dimitrios Vytiniotis and Stephanie Weirich},
  title = {Dependent types: Easy as {PIE}},
  booktitle = {Draft Proceedings of the 8th Symposium on Trends in Functional Programming},
  pages = {XVII-1---XVII-15},
  year = 2007,
  editor = {Marco T. Moraz\'{a}n and Henrik Nilsson},
  month = apr,
  organization = {Dept. of Math and Computer Science, Seton Hall University},
  note = {TR-SHU-CS-2007-04-1},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/tfp07.pdf">http://www.seas.upenn.edu/~sweirich/papers/tfp07.pdf</a>},
  plclub = {yes}
}
</pre>

<a name="vytiniotis:parametricity"></a><pre>
@inproceedings{<a href="plclub.html#vytiniotis:parametricity">vytiniotis:parametricity</a>,
  author = {Dimitrios Vytiniotis and Stephanie Weirich},
  title = {Free theorems and runtime type representations},
  booktitle = {Mathematical Foundations of Programming Semantics (MFPS XXIII)},
  month = apr,
  year = 2007,
  pages = {357--373},
  address = {New Orleans, LA, USA},
  plclub = {yes},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/rtheorems07.pdf">http://www.seas.upenn.edu/~sweirich/papers/rtheorems07.pdf</a>},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/rtheorems07.ps">http://www.seas.upenn.edu/~sweirich/papers/rtheorems07.ps</a>},
  abstract = {
    Reynolds' abstraction theorem, often referred to
  as the parametricity theorem, can be used to derive properties about
  functional programs solely from their types. Unfortunately, in the
  presence of runtime type analysis, the abstraction properties of
  polymorphic programs are no longer valid. However, runtime type
  analysis can be implemented with term-level representations of
  types, as in the  language of Crary et
    al., where case analysis on
  these runtime representations introduces type refinement. In this
  paper, we show that representation-based analysis is consistent with
  type abstraction by extending the abstraction theorem to such a
  language. We also discuss the ``free theorems'' that result.  This
  work provides a foundation for the more general problem of extending
  the abstraction theorem to languages with generalized algebraic
  datatypes.
}
}
</pre>

<a name="aydemir:nominal-coq"></a><pre>
@inproceedings{<a href="plclub.html#aydemir:nominal-coq">aydemir:nominal-coq</a>,
  author = {Brian Aydemir and Aaron Bohannon and Stephanie Weirich},
  title = {Nominal Reasoning Techniques in {Coq}},
  booktitle = {International Workshop on Logical Frameworks and
                  Meta-Languages:Theory and Practice (LFMTP) },
  year = 2006,
  address = {Seattle, WA, USA},
  month = aug,
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/nominal-coq/lfmtp06.pdf">http://www.seas.upenn.edu/~sweirich/papers/nominal-coq/lfmtp06.pdf</a>},
  projecturl = {<a href="http://www.seas.upenn.edu/~sweirich/papers/nominal-coq/">http://www.seas.upenn.edu/~sweirich/papers/nominal-coq/</a>},
  plclub = {yes},
  pages = { 60--69},
  abstract = {
  We explore an axiomatized nominal approach to variable binding in Coq,
  using an untyped lambda-calculus as our test case.  In our nominal
  approach, alpha-equality of lambda terms coincides with Coq's built-in
  equality.  Our axiomatization includes a nominal induction principle and
  functions for calculating free variables and substitution.  These axioms
  are collected in a module signature and proved sound
  using locally nameless terms as the underlying
  representation.  Our experiences so far suggests that it is feasible to
  work from such axiomatized theories in Coq and that the nominal style of
  variable binding corresponds closely with paper proofs.  We are currently
  working on proving the soundness of a primitive recursion combinator
  and developing a method of generating these axioms and their proof of
  soundness from a grammar describing the syntax of terms and binding.
  }
}
</pre>

<a name="weirich:replib"></a><pre>
@inproceedings{<a href="plclub.html#weirich:replib">weirich:replib</a>,
  author = {Stephanie Weirich},
  title = {{RepLib}: {A} library for derivable type classes},
  booktitle = {Haskell Workshop},
  month = sep,
  address = {Portland, OR, USA},
  year = 2006,
  plclub = {yes},
  pages = {1--12},
  pdf = {<a href="http://repository.upenn.edu/cis_papers/362">http://repository.upenn.edu/cis_papers/362</a>},
  projecturl = {<a href="http://www.seas.upenn.edu/~sweirich/RepLib/">http://www.seas.upenn.edu/~sweirich/RepLib/</a>},
  abstract = {
  Some type class instances can be automatically derived from the
  structure of types. As a result, the Haskell language includes the
  "deriving" mechanism to automatic generates such instances for a
  small number of built-in type classes. In this paper, we present
  RepLib, a GHC library that enables a similar mechanism for arbitrary
  type classes. Users of RepLib can define the relationship between
  the structure of a datatype and the associated instance declaration
  by a normal Haskell functions that pattern-matches a representation
  types. Furthermore, operations defined in this manner are
  extensible---instances for specific types not defined by type
  structure may also be incorporated. Finally, this library also
  supports the definition of operations defined by parameterized
  types.
  }
}
</pre>

<a name="washburn:good-advice"></a><pre>
@inproceedings{<a href="plclub.html#washburn:good-advice">washburn:good-advice</a>,
  author = {Geoffrey Washburn and Stephanie Weirich},
  title = {Good Advice for Type-directed Programming:
      {A}spect-oriented Programming and Extensible Generic Functions},
  month = sep,
  plclub = {yes},
  year = 2006,
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/aspect-tdp.pdf">http://www.seas.upenn.edu/~sweirich/papers/aspect-tdp.pdf</a>},
  projecturl = {<a href="http://www.cs.princeton.edu/sip/projects/aspectml/">http://www.cs.princeton.edu/sip/projects/aspectml/</a>},
  booktitle = {Workshop on Generic Programming (WGP)},
  address = {Portland, OR, USA},
  pages = {33--44},
  abstract = {
Type-directed programming is an important idiom for software design.
In type-directed programming the behavior of programs is guided by the
type structure of data.  It makes it possible to implement many sorts
of operations, such as serialization, traversals, and queries, only
once and without needing to continually revise their implementation as
new data types are defined.

Type-directed programming is the basis for recent research into
"scrapping" tedious boilerplate code that arises in functional
programming with algebraic data types.  This research has primarily
focused on writing type-directed functions that are closed to
extension. However, L\"ammel and Peyton Jones recently developed a
technique for writing openly extensible type-directed functions in
Haskell by making clever use of type classes.  Unfortunately, this
technique has a number of limitations.

We present an alternate approach to writing openly extensible
type-directed functions by using the aspect-oriented programming
features provided by the language AspectML.  Our solution not only
avoids the limitations present in L\"ammel and Peyton Jones technique,
but also allows type-directed functions to be extended at any time
with cases for types that were not even known at compile-time.  This
capability is critical to writing programs that make use of dynamic
loading or runtime type generativity.
}
}
</pre>

<a name="vytiniotis:boxy"></a><pre>
@inproceedings{<a href="plclub.html#vytiniotis:boxy">vytiniotis:boxy</a>,
  topic = {language design},
  historical = {The paper shows how type inference can exploit user annotations in order to type check programs
                that require first-class polymorphism. This revision of the boxy types paper offers a new smart-application rule,
                that outperforms the versions of smart-application appearing in earlier drafts.
                Many parts have been rewritten and clarified.},
  title = {Boxy type inference for higher-rank types and impredicativity},
  booktitle = {International Conference on Functional Programming (ICFP)},
  abstract = {
               Languages with rich type systems are beginning to
               employ a blend of type inference and type
               checking, so that the type inference engine is
               guided by programmer-supplied type annotations.  In
               this paper we show, for the first time, how to combine
               the virtues of two well-established ideas:
               unification-based inference, and bidirectional
               propagation of type annotations.  The result is a type
               system that conservatively extends Hindley-Milner, and
               yet supports both higher-rank types and
               impredicativity. },
  author = {Dimitrios Vytiniotis and Stephanie Weirich and Simon L. {Peyton Jones}},
  month = sep,
  year = 2006,
  pdf = {<a href="http://repository.upenn.edu/cis_papers/275/">http://repository.upenn.edu/cis_papers/275/</a>},
  projecturl = {<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html</a>},
  category = {fcp},
  address = {Portland, OR, USA},
  plclub = {yes},
  pages = { 251--262}
}
</pre>

<a name="pj-vytiniotis:wobbly"></a><pre>
@inproceedings{<a href="plclub.html#pj-vytiniotis:wobbly">pj-vytiniotis:wobbly</a>,
  author = {Simon L. {Peyton Jones} and Dimitrios Vytiniotis and Stephanie Weirich and Geoffrey Washburn},
  title = {Simple unification-based type inference for {GADTs}},
  booktitle = {International Conference on Functional Programming (ICFP)},
  historical = {This paper differs from previous versions of the ``wobbly types'' paper in that the ambiguity caused
                by unification is now recorded in the environments and typing judgements instead of the types. The most
                recent addition is the notion of the ``fresh most general unifier'', which eliminates problems arising from
                the directionality of arbitrary most general unifiers, when they are used for GADT type refinement.},
  abstract = {
               Generalized algebraic data types (GADTs), sometimes known as ``guarded
               recursive data types'' or ``first-class phantom
               types'', are a simple but powerful generalization of
               the data types of Haskell and ML.  Recent works have
               given compelling examples of the utility of GADTs,
               although type inference is known to be difficult.  Our
               contribution is to show how to exploit
               programmer-supplied type annotations to make the type
               inference task almost embarrassingly easy.  Our main
               technical innovation is wobbly types, which express in
               a declarative way the uncertainty caused by the
               incremental nature of typical type-inference
               algorithms. },
  month = sep,
  year = 2006,
  plclub = {yes},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/gadt/icfp06-gadt.pdf">http://www.seas.upenn.edu/~sweirich/papers/gadt/icfp06-gadt.pdf</a>},
  category = {gadt},
  address = {Portland, OR, USA},
  pages = {50--61}
}
</pre>

<a name="vytiniotis:gadt-techreport"></a><pre>
@techreport{<a href="plclub.html#vytiniotis:gadt-techreport">vytiniotis:gadt-techreport</a>,
  topic = {language design},
  author = {Dimitrios Vytiniotis and Stephanie Weirich and Simon L. {Peyton~Jones}},
  title = {Simple unification-based type inference for {GADTs}, {Technical Appendix}},
  institution = {University of Pennsylvania},
  year = 2006,
  number = {MS-CIS-05-22},
  month = {April},
  category = {gadt},
  cattype = {report},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~sweirich/gadt/wobbly-techreport.pdf">http://www.cis.upenn.edu/~sweirich/gadt/wobbly-techreport.pdf</a>}
}
</pre>

<a name="peyton-jones:practical"></a><pre>
@article{<a href="plclub.html#peyton-jones:practical">peyton-jones:practical</a>,
  author = {Simon L. {Peyton Jones} and Dimitrios Vytiniotis and Stephanie Weirich and Mark Shields},
  title = {Practical type inference for arbitrary-rank types},
  journal = {Journal of Functional Programming},
  year = 2007,
  plclub = {yes},
  pages = {1--82},
  volume = 17,
  number = 1,
  month = jan,
  projecturl = {<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html</a>},
  pdf = {<a href="http://repository.upenn.edu/cis_papers/315/">http://repository.upenn.edu/cis_papers/315/</a>},
  abstract = {
Haskell's popularity has driven the need for ever more expressive type
system features, most of which threaten the decidability and
practicality of Damas-Milner type inference. One such feature is the
ability to write functions with higher-rank types --- that is,
functions that take polymorphic functions as their arguments.

Complete type inference is known to be undecidable for higher-rank
(impredicative) type systems, but in practice programmers are more
than willing to add type annotations to guide the type inference
engine, and to document their code. However, the choice of just what
annotations are required, and what changes are required in the type
system and its inference algorithm, has been an ongoing topic of
research.

We take as our starting point a lambda-calculus proposed by Odersky
and Laufer. Their system supports arbitrary-rank polymorphism through
the exploitation of type annotations on lambda-bound arguments and
arbitrary sub-terms. Though elegant, and more convenient than some
other proposals, Odersky and Laufer's system requires many
annotations. We show how to use local type inference (invented by
Pierce and Turner) to greatly reduce the annotation burden, to the
point where higher-rank types become eminently usable.

Higher-rank types have a very modest impact on type inference. We
substantiate this claim in a very concrete way, by presenting a
complete type-inference engine, written in Haskell, for a traditional
Damas-Milner type system, and then showing how to extend it for
higher-rank types. We write the type-inference engine using a monadic
framework: it turns out to be a particularly compelling example of
monads in action.

The paper is long, but is strongly tutorial in style.
  }
}
</pre>

<a name="weirich:tdj"></a><pre>
@inproceedings{<a href="plclub.html#weirich:tdj">weirich:tdj</a>,
  plclub = {yes},
  author = {Stephanie Weirich and Liang Huang},
  title = {A Design for Type-Directed {Java}},
  booktitle = {Workshop on Object-Oriented Developments (WOOD)},
  year = 2004,
  month = aug,
  editor = {Viviana Bono},
  series = {ENTCS},
  pages = {117-136},
  annote = {An extended version of this paper is
                  University of Pennsylvania
                  Computer and Information Science Technical Report
                  MS-CIS-04-11.},
  projecturl = {<a href="http://www.seas.upenn.edu/%7Esweirich/tdj/tdj.htm">http://www.seas.upenn.edu/%7Esweirich/tdj/tdj.htm</a>},
  pdf = {<a href="http://repository.upenn.edu/cis_papers/275/">http://repository.upenn.edu/cis_papers/275/</a>},
  ps = {<a href="http://www.cis.upenn.edu/~lhuang3/pubs/tdj-short.ps">http://www.cis.upenn.edu/~lhuang3/pubs/tdj-short.ps</a>},
  abstract = {
  Type-directed programming is an important and widely used
  paradigm in the design of software. With this form of programming,
  an application may analyze type information to determine its
  behavior. By analyzing the structure of data, many operations, such
  as serialization, cloning, adaptors and iterators may be defined
  once, for all types of data. That way, as the program evolves, these
  operations need not be updated---they will automatically adapt to
  new data forms.  Otherwise, each of these operations must be
  individually redefined for each type of data, forcing programmers to
  revisit the same program logic many times during a program's
  lifetime.

  The Java language supports type directed programming with the
  instanceof operator and the Java Reflection API.  These
  mechanisms allow Java programs to depend on the name and structure
  of the run-time classes of objects.  However, the Java mechanisms
  for type-directed programming are difficult to use. They also do not
  integrate well with generics, an important new feature of the Java
  language.

  In this paper, we describe the design of several expressive new
  mechanisms for type-directed programming in Java, and show that
  these mechanisms are sound when included in a language similar to
  Featherweight Java. Basically, these new mechanisms pattern-match
  the name and structure of the type parameters of generic code,
  instead of the run-time classes of objects.  Therefore, they
  naturally integrate with generics and provide strong guarantees
  about program correctness. As these mechanisms are based on pattern
  matching, they naturally and succinctly express many operations that
  depend on type information. Finally, they provide programmers with
  some degree of protection for their abstractions. Whereas
  instanceof and reflection can determine the exact run-time type
  of an object, our mechanisms allow any supertype to be supplied for
  analysis, hiding its precise structure.}
}
</pre>

<a name="weirich:cast-journal"></a><pre>
@article{<a href="plclub.html#weirich:cast-journal">weirich:cast-journal</a>,
  plclub = {yes},
  author = {Stephanie Weirich},
  title = {Type-Safe Cast},
  journal = {Journal of Functional Programming},
  month = nov,
  year = 2004,
  volume = 14,
  number = 6,
  pages = {681-695},
  pdf = {<a href="http://journals.cambridge.org/bin/bladerunner?REQUNIQ=1098990699&amp;REQSESS=1422511&amp;118000REQEVENT=&amp;REQINT1=254715&amp;REQAUTH=0">http://journals.cambridge.org/bin/bladerunner?REQUNIQ=1098990699&REQSESS=1422511&118000REQEVENT=&REQINT1=254715&REQAUTH=0</a>},
  abstract = {   Comparing two types for equality is an essential ingredient for an
  implementation of dynamic types. Once equality has been established,
  it is safe to cast a value from one type to another. In a language
  with run-time type analysis, implementing such a procedure is fairly
  straightforward.  Unfortunately, this naive implementation destructs
  and rebuilds the argument while iterating over its type structure.
  However, by using higher-order polymorphism, a casting function can
  treat its argument parametrically. We demonstrate this solution in
  two frameworks for ad-hoc polymorphism: intensional type analysis
  and Haskell type classes.}
}
</pre>

<a name="weirich:erasure"></a><pre>
@article{<a href="plclub.html#weirich:erasure">weirich:erasure</a>,
  author = {Stephanie Weirich},
  title = {Type-Safe Run-time Polytypic Programming},
  journal = {Journal of Functional Programming},
  year = 2006,
  month = nov,
  pages = {681--710},
  plclub = {yes},
  volume = 16,
  number = 10,
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/erasure/erasure-jfp.pdf">http://www.seas.upenn.edu/~sweirich/papers/erasure/erasure-jfp.pdf</a>},
  abstract = {
  Polytypic programming is a way of defining type-indexed
  operations, such as map, fold and zip, based on type information.
  Run-time polytypic programming allows that type information to
  be dynamically computed---this support is essential in modern
  programming languages that support separate compilation, first-class
  type abstraction, or polymorphic recursion.

  However, in previous work we defined run-time polytypic programming
  with a type-passing semantics. Although it is natural to define
  polytypic programs as operating over first-class types, such a
  semantics suffers from a number of drawbacks. This paper describes
  how to recast that work in a type-erasure semantics, where terms
  represent type information in a safe manner.  The resulting language
  is simple and easy to implement---we present a prototype
  implementation of the necessary machinery as a small Haskell
  library.
  }
}
</pre>

<a name="huang:tdp-tr"></a><pre>
@techreport{<a href="plclub.html#huang:tdp-tr">huang:tdp-tr</a>,
  plclub = {yes},
  author = {Liang Huang and Stephanie Weirich},
  title = {A Design for Type-Directed Programming in {Java} (Extended Version)},
  institution = {University of Pennsylvania, Computer and Information Science},
  year = 2004,
  number = {MS-CIS-04-11},
  month = oct,
  pages = {1--49},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.ps">http://www.seas.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.ps</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.pdf">http://www.seas.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.pdf</a>}
}
</pre>

<a name="weirich:phd"></a><pre>
@phdthesis{<a href="plclub.html#weirich:phd">weirich:phd</a>,
  plclub = {yes},
  author = {Stephanie Weirich},
  title = {Programming With Types},
  school = {Cornell University},
  month = aug,
  year = 2002,
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/thesis/thesis.ps">http://www.seas.upenn.edu/~sweirich/papers/thesis/thesis.ps</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/thesis/thesis.pdf">http://www.seas.upenn.edu/~sweirich/papers/thesis/thesis.pdf</a>},
  abstract = {Run-time type analysis is an increasingly important linguistic
     mechanism in modern programming languages. Language runtime
     systems use it to implement services such as accurate garbage
     collection, serialization, cloning and structural
     equality. Component frameworks rely on it to provide reflection
     mechanisms so they may discover and interact with program
     interfaces dynamically. Run-time type analysis is also crucial
     for large, distributed systems that must be dynamically extended,
     because it allows those systems to check program invariants when
     new code and new forms of data are added. Finally, many generic
     user-level algorithms for iteration, pattern matching, and
     unification can be defined through type analysis mechanisms.

     However, existing frameworks for run-time type analysis were
     designed for simple type systems. They do not scale well to the
     sophisticated type systems of modern and next-generation
     programming languages that include complex constructs such as
     first-class abstract types, recursive types, objects, and type
     parameterization. In addition, facilities to support type
     analysis often require complicated language semantics that allow
     little freedom in their implementation.  This dissertation
     investigates the foundations of run-time type analysis in the
     context of statically-typed, polymorphic programming languages.
     Its goal is to show how such a language may support
     type-analyzing operations in a way that balances expressiveness,
     safety and simplicity.}
}
</pre>

<a name="weirich:hota"></a><pre>
@inproceedings{<a href="plclub.html#weirich:hota">weirich:hota</a>,
  plclub = {yes},
  author = {Stephanie Weirich},
  title = {Higher-Order Intensional Type Analysis},
  booktitle = {11th European Symposium on Programming (ESOP)},
  editor = {Daniel Le M\'{e}tayer},
  pages = {98--114},
  year = 2002,
  month = apr,
  address = {Grenoble, France},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/hota/hota.ps">http://www.seas.upenn.edu/~sweirich/papers/hota/hota.ps</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/hota/hota.pdf">http://www.seas.upenn.edu/~sweirich/papers/hota/hota.pdf</a>},
  abstract = {Intensional type analysis provides the ability to
     analyze abstracted types at run time. In this paper, we extend
     that ability to higher-order and kind-polymorphic type
     constructors. The resulting language is elegant and expressive:
     we show through examples how it extends the repertoire of
     polytypic functions that may be defined.}
}
</pre>

<a name="weirich01"></a><pre>
@inproceedings{<a href="plclub.html#weirich01">weirich01</a>,
  plclub = {yes},
  author = {Stephanie Weirich},
  title = {Encoding Intensional Type Analysis},
  booktitle = {10th European Symposium on Programming (ESOP)},
  year = 2001,
  editor = {D. Sands},
  pages = {92--106},
  address = {Genova, Italy},
  month = apr,
  annote = {2001 Springer-Verlag. Minor corrections in local version.},
  url = {<a href="http://link.springer.de/link/service/series/0558/tocs/t2028.htm">http://link.springer.de/link/service/series/0558/tocs/t2028.htm</a>},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/depabs/depabs.ps">http://www.seas.upenn.edu/~sweirich/papers/depabs/depabs.ps</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/depabs/depabs.pdf">http://www.seas.upenn.edu/~sweirich/papers/depabs/depabs.pdf</a>},
  abstract = {Languages for intensional type analysis permit ad-hoc
     polymorphism, or run-time analysis of types. However, such
     languages require complex, specialized constructs to support this
     operation, which hinder optimization and complicate the
     meta-theory of these languages. In this paper, we observe that
     such specialized operators need not be intrinsic to the language,
     and in fact, their operation may be simulated through standard
     encodings of iteration in the polymorphic lambda
     calculus. Therefore, we may more easily add intensional analysis
     operators to complicated languages via a translation semantics,
     instead of through language extension.}
}
</pre>

<a name="weirich00"></a><pre>
@inproceedings{<a href="plclub.html#weirich00">weirich00</a>,
  plclub = {yes},
  author = {Stephanie Weirich},
  title = {Type-Safe Cast: Functional Pearl},
  booktitle = {Proceedings of the fifth {ACM SIGPLAN} International Conference on Functional Programming (ICFP)},
  year = 2000,
  month = sep,
  address = {Montreal, Canada},
  pages = {58--67},
  abstract = {In a language with non-parametric or ad-hoc
    polymorphism, it is possible to determine the identity of a type
    variable at run time.  With this facility, we can write a function
    to convert a term from one abstract type to another, if the two
    hidden types are identical.  However, the naive implementation of
    this function requires that the term be destructed and rebuilt. In
    this paper, we show how to eliminate this overhead using
    higher-order type abstraction. We demonstrate this solution in two
    frameworks for ad-hoc polymorphism: intensional type analysis and
    type classes.},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/cast/cast.ps">http://www.seas.upenn.edu/~sweirich/papers/cast/cast.ps</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/cast/cast.pdf">http://www.seas.upenn.edu/~sweirich/papers/cast/cast.pdf</a>}
}
</pre>

<a name="HicksW00type-loading-tr"></a><pre>
@techreport{<a href="plclub.html#HicksW00type-loading-tr">HicksW00type-loading-tr</a>,
  plclub = {yes},
  author = {Michael Hicks and Stephanie Weirich},
  title = {A Calculus for Dynamic Loading},
  institution = {University of Pennsylvania},
  year = {2000},
  number = {MS-CIS-00-07},
  month = {April},
  pdf = { http://repository.upenn.edu/cis_reports/169/ },
  abstract = {
We present the load-calculus, used to model dynamic loading, and prove it sound. The calculus extends the polymorphic lambda-calculus with a load primitive that dynamically loads terms that are closed, with respect to values. The calculus is meant to approximate the process of dynamic loading in TAL/Load , a version of Typed Assembly Language extending with dynamic linking. To model the key aspects of TAL, the calculus contains references and facilities for named types. Loadable programs may refer to named types defined by the running program, and may export new types to code loaded later. Our approach follows the framework initially outlined by Glew et. al. This calculus has been implemented in the TALx86 version of Typed Assembly Language, and is used to implement a full-featured dynamic linking library, DLpop.}
}
</pre>

<a name="hicks00"></a><pre>
@incollection{<a href="plclub.html#hicks00">hicks00</a>,
  plclub = {yes},
  author = {Michael Hicks and Stephanie Weirich and Karl Crary},
  title = {Safe and Flexible Dynamic Linking of Native Code},
  booktitle = {Types in Compilation: Third International Workshop, TIC 2000;
               Montreal, Canada, September 21, 2000; Revised Selected Papers},
  editor = {R. Harper},
  publisher = {Springer},
  year = 2001,
  series = {Lecture Notes in Computer Science},
  volume = 2071,
  pages = {147--176},
  annote = {Related technical report: Michael Hicks and Stephanie
     Weirich.  A calculus for dynamic loading.
    University of Pennsylvania Computer and Information Science
     Technical Report,
     MS-CIS-00-07,  April 2000.},
  abstract = {We present the design and implementation of the first
     complete framework for flexible and safe dynamic linking of
     native code. Our approach extends Typed Assembly Language with a
     primitive for loading and typechecking code, which is flexible
     enough to support a variety of linking strategies, but simple
     enough that it does not significantly expand the trusted
     computing base. Using this primitive, along with the ability to
     compute with types, we show that we can program many existing
     dynamic linking approaches. As a concrete demonstration, we have
     used our framework to implement dynamic linking for a type-safe
     dialect of C, closely modeled after the standard linking facility
     for Unix C programs. Aside from the unavoidable cost of
     verification, our implementation performs comparably with the
     standard, untyped approach.},
  url = {<a href="http://link.springer.de/link/service/series/0558/tocs/t2071.htm">http://link.springer.de/link/service/series/0558/tocs/t2071.htm</a>},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/taldynlink/taldynlink.ps.gz">http://www.seas.upenn.edu/~sweirich/papers/taldynlink/taldynlink.ps.gz</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/taldynlink/taldynlink.pdf">http://www.seas.upenn.edu/~sweirich/papers/taldynlink/taldynlink.pdf</a>}
}
</pre>

<a name="crary00"></a><pre>
@inproceedings{<a href="plclub.html#crary00">crary00</a>,
  plclub = {yes},
  author = {Karl Crary and Stephanie Weirich},
  title = {Resource Bound Certification},
  booktitle = {The Twenty-Seventh {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages (POPL)},
  pages = {184--198},
  year = 2000,
  address = {Boston, MA, USA},
  month = jan,
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/res/res.pdf">http://www.seas.upenn.edu/~sweirich/papers/res/res.pdf</a>},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/res/res.ps.gz">http://www.seas.upenn.edu/~sweirich/papers/res/res.ps.gz</a>},
  abstract = {Various code certification systems allow the
    certification and static verification of a variety of important
    safety properties such as memory safety and control-flow
    safety. These systems provide valuable tools for verifying that
    untrusted and potentially malicious code is safe before execution.
    However, one important safety property that is not usually
    included is that programs adhere to specific bounds on resource
    consumption, such as running time.

    We present a decidable type system capable of specifying and
    certifying bounds on resource consumption. Our system makes two
    advances over previous resource bound certification systems, both
    of which are necessary for a practical system: we allow the
    execution time of programs and their subroutines to vary,
    depending on their arguments, and we provide a fully automatic
    compiler generating certified executables from source-level
    programs. The principal device in our approach is a strategy for
    simulating dependent types using sum and inductive kinds. }
}
</pre>

<a name="morrisett:talx86"></a><pre>
@inproceedings{<a href="plclub.html#morrisett:talx86">morrisett:talx86</a>,
  plclub = {yes},
  author = {Greg Morrisett and Karl Crary and Neal Glew and Dan
                  Grossman and Richard Samuels and Frederick Smith and
                  David Walker and Stephanie Weirich and Steve
                  Zdancewic},
  title = {{TALx86}: A Realistic Typed Assembly Language},
  booktitle = {Second {ACM} {SIGPLAN} Workshop on Compiler Support for System Software},
  year = 1999,
  month = may,
  pages = {25--35},
  note = {Published as {INRIA} research report number 0228, March 1999.},
  address = {Atlanta, GA, USA},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/talx86-wcsss.ps">http://www.seas.upenn.edu/~sweirich/papers/talx86-wcsss.ps</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/talx86-wcsss.pdf">http://www.seas.upenn.edu/~sweirich/papers/talx86-wcsss.pdf</a>},
  abstract = {The goal of typed assembly language (TAL) is to provide
     a low-level, statically typed target language that is better
     suited than Java bytecodes for supporting a wide variety of
     source languages and a number of important optimizations. In
     previous work, we formalized idealized versions of TAL and proved
     important safety properties about them. In this paper, we present
     our progress in defining and implementing a realistic typed
     assembly language called TALx86. The TALx86 instructions comprise
     a relatively complete fragment of the Intel IA32 (32-bit 80x86
     flat model) assembly language and are thus executable on
     processors such as the Intel Pentium. The type system for the
     language incorporates a number of advanced features necessary for
     safely compiling large programs to good code.

     To motivate the design of the type system, we demonstrate how
     various high-level language features are compiled to TALx86. For
     this purpose, we present a type-safe C-like language called
     Popcorn.}
}
</pre>

<a name="crary:lx"></a><pre>
@inproceedings{<a href="plclub.html#crary:lx">crary:lx</a>,
  plclub = {yes},
  author = {Karl Crary and Stephanie Weirich},
  title = {Flexible Type Analysis},
  booktitle = {Proceedings of the fourth {ACM SIGPLAN} International Conference on Functional Programming (ICFP) },
  year = 1999,
  month = sep,
  address = {Paris, France},
  pages = {233--248},
  abstract = {Run-time type dispatch enables a variety of advanced
     optimization techniques for polymorphic languages, including
     tag-free garbage collection, unboxed function arguments, and
     flattened data structures.  However, modern type-preserving
     compilers transform types between stages of compilation, making
     type dispatch prohibitively complex at low levels of typed
     compilation. It is crucial therefore for type analysis at these
     low levels to refer to the types of previous
     stages. Unfortunately, no current intermediate language supports
     this facility.

     To fill this gap, we present the language LX, which provides a
     rich language of type constructors supporting type analysis
     (possibly of previous-stage types) as a programming idiom. This
     language is quite flexible, supporting a variety of other
     applications such as analysis of quantified types, analysis with
     incomplete type information, and type classes. We also show that
     LX is compatible with a type-erasure semantics.},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/lx/lxpaper.ps.gz">http://www.seas.upenn.edu/~sweirich/papers/lx/lxpaper.ps.gz</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/lx/lxpaper.pdf">http://www.seas.upenn.edu/~sweirich/papers/lx/lxpaper.pdf</a>}
}
</pre>

<a name="crary:intensional"></a><pre>
@inproceedings{<a href="plclub.html#crary:intensional">crary:intensional</a>,
  plclub = {yes},
  author = {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title = {Intensional Polymorphism in Type Erasure Semantics},
  booktitle = {Proceedings of the third {ACM SIGPLAN} International Conference on Functional Programming (ICFP) },
  year = 1998,
  address = {Baltimore, MD, USA},
  month = sep,
  pages = {301--313},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass.ps">http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass.ps</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass.pdf">http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass.pdf</a>},
  abstract = { Intensional polymorphism, the ability to dispatch to
  different routines based on types at run time, enables a variety of
  advanced implementation techniques for polymorphic languages,
  including tag-free garbage collection, unboxed function arguments,
  polymorphic marshalling, and flattened data structures. To date,
  languages that support intensional polymorphism have required a
  type-passing (as opposed to type-erasure) interpretation where types
  are constructed and passed to polymorphic functions at run
  time. Unfortunately, type-passing suffers from a number of
  drawbacks; it requires duplication of constructs at the term and
  type levels, it prevents abstraction, and it severely complicates
  polymorphic closure conversion. We present a type-theoretic
  framework that supports intensional polymorphism, but avoids many of
  the disadvantages of type passing. In our approach, run-time type
  information is represented by ordinary terms. This avoids the
  duplication problem, allows us to recover abstraction, and avoids
  complications with closure conversion. In addition, our type system
  provides another improvement in expressiveness; it allows unknown
  types to be refined in place thereby avoiding certain
  beta-expansions required by other frameworks.  }
}
</pre>

<a name="flanagan96"></a><pre>
@inproceedings{<a href="plclub.html#flanagan96">flanagan96</a>,
  plclub = {yes},
  author = {Cormac Flanagan and Matthew Flatt and Shriram
             Krishnamurthi and Stephanie Weirich and Matthias
             Felleisen},
  title = {Catching Bugs in the Web of Program Invariants},
  booktitle = {{ACM SIGPLAN} Conference on Programming Language Design and Implementation (PLDI)},
  year = 1996,
  pages = {23--32},
  abstract = {MrSpidey is a user-friendly, interactive static
     debugger for Scheme. A static debugger supplements the standard
     debugger by analyzing the program and pinpointing those program
     operations tha may cause run-time errors suce as dereferencing
     the null pointer or applying non-functions. The program analysis
     of MrSpidey computes value set descriptions for each term in the
     program and constructs a value flow graph connecting the set
     descriptions. Using the set descriptions, MrSpidey can identify
     and highlight potentially erroneous program operations, whose
     cause the programmer can the explore by selectively exposing
     portions of the value flow graph.},
  ps = {<a href="http://www.seas.upenn.edu/~sweirich/papers/pldi96-ffkwf.ps">http://www.seas.upenn.edu/~sweirich/papers/pldi96-ffkwf.ps</a>},
  pdf = {<a href="http://www.seas.upenn.edu/~sweirich/papers/pldi96-ffkwf.pdf">http://www.seas.upenn.edu/~sweirich/papers/pldi96-ffkwf.pdf</a>}
}
</pre>

<a name="PZ19a"></a><pre>
@inproceedings{<a href="plclub.html#PZ19a">PZ19a</a>,
  author = {Jennifer Paykin and Steve Zdancewic},
  title = {{A HoTT Quantum Equational Theory}},
  booktitle = {The 16th International Conference on Quantum Physics and Logic (QPL)},
  year = 2019,
  note = {extended version available on arXiv},
  hsconf = {yes},
  plclub = {yes},
  url = {https://arxiv.org/abs/1904.04371},
  year = 2019,
  abstract = {
This paper presents an equational theory for the QRAM model of quantum computation, formulated as an embedded language inside of homotopy type theory. The embedded language approach is highly expressive, and reflects the style of state-of-the art quantum languages like Quipper and QWIRE. The embedding takes advantage of features of homotopy type theory to encode unitary transformations as higher inductive paths, simplifying the presentation of an equational theory. We prove that this equational theory is sound and complete with respect to established models of quantum computation.
}
}
</pre>

<a name="MM+19"></a><pre>
@article{<a href="plclub.html#MM+19">MM+19</a>,
  author = {Anders Miltner and Solomon Maina and Kathleen Fisher and Benjamin C. Pierce and David Walker and Steve Zdancewic},
  title = {Synthesizing Symmetric Lenses},
  journal = {Proceedings of the ACM on Programming Languages},
  year = 2019,
  number = {ICFP},
  hjournal = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/MM+19.pdf">http://www.cis.upenn.edu/~stevez/MM+19.pdf</a>},
  abstract = {
Lenses are programs that can be run both "front to back" and "back to front," allowing updates to either their source or their target data to be transferred in both directions. Since their introduction by Foster et al., lenses have been extensively studied, extended, and applied. Recent work has also demonstrated how techniques from type-directed program synthesis can be used to efficiently synthesize a simple class of lenses—so-called bijective lenses over string data—given a pair of types (regular expressions) and a small number of examples.


We extend this synthesis algorithm to a much broader class of lenses, called simple symmetric lenses, including all bijective lenses, all of the popular category of "asymmetric" lenses, and a rich subset of the more powerful “symmetric lenses” proposed by Hofmann et al. Intuitively, simple symmetric lenses allow some information to be present on one side but not the other and vice versa. They are of independent theoretical interest, being the largest class of symmetric lenses that do not rely on persistent internal state.

Synthesizing simple symmetric lenses is substantially more challenging than synthesizing bijective lenses: Since some of the information on each side can be “disconnected” from the other side, there will, in general, be many lenses that agree with a given example. To guide the search process, we use stochastic regular expressions and ideas from information theory to estimate the amount of information propagated by a candidate lens, generally preferring lenses that propagate more information, as well as user annotations marking parts of the source and target data structures as either irrelevant or essential.

We describe an implementation of simple symmetric lenses and our synthesis procedure as extensions to the Boomerang language. We evaluate its performance on 48 benchmark examples drawn from Flash Fill, Augeas, the bidirectional programming literature, and electronic file format synchronization tasks. Our implementation can synthesize each of these lenses in under 30 seconds.
}
}
</pre>

<a name="HHNZ19"></a><pre>
@inproceedings{<a href="plclub.html#HHNZ19">HHNZ19</a>,
  author = {Marcella Hastings and Brett Hemenway and Daniel Noble and Steve Zdancewic},
  title = {{SoK: General Purpose Compilers for Secure Multi-Party Computation}},
  booktitle = {{IEEE} 2019 Symposium on Security and Privacy (Oakland)},
  year = 2019,
  hsconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/HHNZ19.pdf">http://www.cis.upenn.edu/~stevez/papers/HHNZ19.pdf</a>},
  abstract = {
Secure multi-party computation (MPC) allows a group of mutually distrustful parties to compute a joint function on their inputs 
without revealing any information beyond the result of the computation. 
This type of computation is extremely powerful and has wide-ranging applications in academia, industry, and government.
Protocols for secure computation have existed for decades, but only recently have general-purpose compilers for executing MPC on arbitrary functions been developed.
These projects rapidly improved the state of the art, and began to make MPC accessible to non-expert users. 
However, the field is changing so rapidly that it is difficult even for experts to keep track of the varied capabilities of modern frameworks.

In this work, we survey general-purpose compilers for secure multi-party computation. 
These tools provide high-level abstractions to describe arbitrary functions and execute secure computation protocols.
We consider eleven systems: EMP-toolkit, Obliv-C, ObliVM, TinyGarble, SCALE-MAMBA (formerly SPDZ), Wysteria, Sharemind, PICCO, ABY, 
Frigate and CBMC-GC.
We evaluate these systems on a range of criteria, including language expressibility, capabilities of the cryptographic back-end, and accessibility to developers. 
We advocate for improved documentation of MPC frameworks, standardization within the community, and make recommendations for future directions in compiler development.
Installing and running these systems can be challenging, and for each system, we also provide a complete virtual environment (Docker container) with all the necessary dependencies 
to run the compiler and our example programs.
}
}
</pre>

<a name="KLL+19"></a><pre>
@inproceedings{<a href="plclub.html#KLL+19">KLL+19</a>,
  author = {Nicolas Koh and Yao Li and Yishuai Li and Li-yao Xia and Lennart Beringer and Wolf Honor\'{e} and William Mansky and Benjamin C. Pierce and Steve Zdancewic},
  title = {{From C to Interaction Trees: Specifying, Verifying, and Testing a Networked Server}},
  booktitle = {Proceedings of the 8th ACM SIGPLAN International Conference on Certified Programs and Proofs (CPP)},
  year = 2019,
  hsconf = {yes},
  plclub = {yes},
  nsfr = {yes},
  month = {Jan},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/KLL+19.pdf">http://www.cis.upenn.edu/~stevez/papers/KLL+19.pdf</a>},
  abstract = {
We present the first formal verification of a networked server implemented
in C.  {\em Interaction trees}, a general structure for representing
reactive computations, are used to tie together disparate verification and
testing tools (Coq, VST, and QuickChick) and to axiomatize the behavior of
the operating system on which the server runs (CertiKOS).  The main theorem
connects a specification of acceptable server behaviors, written in a
straightforward ``one client at a time'' style, with the
CompCert semantics of the C program.  The variability
introduced by low-level buffering of messages and interleaving of multiple
TCP connections is captured using {\em network refinement}, a variant of
observational refinement.
}
}
</pre>

<a name="RPLZ18"></a><pre>
@inproceedings{<a href="plclub.html#RPLZ18">RPLZ18</a>,
  author = {Robert Rand and Jennifer Paykin and Dong-Ho Lee and Steve Zdancewic},
  title = {{REQUIRE}: Reasoning about Reversible Quantum Circuits},
  booktitle = {The 15th International Conference on Quantum Physics and Logic (QPL)},
  year = 2018,
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/RPLZ18.pdf">http://www.cis.upenn.edu/~stevez/papers/RPLZ18.pdf</a>},
  hsconf = {yes},
  plclub = {yes}
}
</pre>

<a name="RGZ18"></a><pre>
@inproceedings{<a href="plclub.html#RGZ18">RGZ18</a>,
  author = {Christine Rizkallah and Dmitri Garbuzov and Steve Zdancewic},
  title = {{A Formal Equational Theory for Call-By-Push-Value}},
  booktitle = {9th International Conference on Interactive Theorem Proving (ITP)},
  year = 2018,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/RGZ18.pdf">http://www.cis.upenn.edu/~stevez/papers/RGZ18.pdf</a>},
  abstract = {
  Establishing that two programs are contextually equivalent is hard, yet
  essential for reasoning about 
  semantics preserving program
  transformations such as compiler optimizations.  
  We adapt Lassen's normal form bisimulations technique to establish the soundness of equational
  theories for both an untyped
  call-by-value $\lambda$-calculus and a variant of Levy's call-by-push-value
  language. We demonstrate that our equational theory significantly simplifies the verification of optimizations.
}
}
</pre>

<a name="MMF+18"></a><pre>
@article{<a href="plclub.html#MMF+18">MMF+18</a>,
  author = {Solomon Maina and Anders Miltner and Kathleen Fisher and Benjamin C. Pierce and David Walker and Steve Zdancewic},
  title = {Synthesizing Quotient Lenses},
  journal = {Proceedings of the ACM on Programming Languages},
  year = 2018,
  volume = {2},
  number = {ICFP},
  plclub = {yes},
  hjournal = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MMF+18.pdf">http://www.cis.upenn.edu/~stevez/papers/MMF+18.pdf</a>},
  abstract = {
{\em Quotient lenses} are bidirectional transformations whose correctness
laws are ``loosened'' by specified equivalence relations, allowing
inessential details in concrete data formats to be suppressed. 
For example, a programmer could use a quotient lens to define 
a transformation that ignores the order of fields in XML data, so
that two XML files with the same fields but in different orders would be
considered the same, allowing a single, simple program to handle them both. 
%
Building on a recently published algorithm for synthesizing plain bijective
lenses from high-level specifications, we show how to synthesize bijective
quotient lenses in three steps. First, we introduce {\em quotient regular
  expressions} (QREs), annotated regular expressions that conveniently mark
inessential aspects of string data formats; each QRE specifies,
simulteneously, a regular language and an equivalence relation on it.
Second, we introduce {\em QRE lenses}, i.e., lenses mapping between QREs.
Our key technical result is a proof that every QRE lens can be transformed
into a functionally equivalent lens that canonizes source and target data just
at the ``edges'' and that uses a bijective lens to map between the respective
canonical elements; no internal canonization occurs in a lens in this normal
form. Third, we leverage this normalization theorem to {\em synthesize} QRE
lenses from a pair of QREs and example input-output pairs, reusing earlier work
on synthesizing plain bijective lenses. We have implemented QREs and QRE lens
synthesis as an extension to the bidirectional programming language Boomerang.
We evaluate the effectiveness of our approach by synthesizing QRE lenses
between various real-world data formats in the Optician benchmark suite.
}
}
</pre>

<a name="MFP+17"></a><pre>
@article{<a href="plclub.html#MFP+17">MFP+17</a>,
  author = {Anders Miltner and Kathleen Fisher and Benjamin C. Pierce and David Walker and Steve Zdancewic},
  title = {{Synthesizing Bijective Lenses}},
  journal = {Proceedings of the ACM on Programming Languages},
  year = 2018,
  volume = 2,
  number = {POPL},
  month = jan,
  plclub = {yes},
  nsfr = {yes},
  hjournal = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MFP+17.pdf">http://www.cis.upenn.edu/~stevez/papers/MFP+17.pdf</a>},
  abstract = {
Bidirectional transformations between different data representations
occur frequently in modern software systems.  They appear as serializers and
deserializers, as parsers and pretty printers, as database views and view
updaters, and as a multitude of different kinds of ad hoc data converters. 
Manually building bidirectional transformations---by writing two separate
functions that are intended to be inverses---is tedious and error prone.
A better approach is to use a domain-specific language in
which both directions can be written as a single expression.  However,
these domain-specific languages can be difficult to program in, requiring
programmers to manage fiddly details while working in a complex type system.

We present an alternative approach.  
Instead of coding transformations manually, we synthesize them from
declarative format descriptions and examples.
Specifically,
we present $\emph{Optician}$, a tool for type-directed synthesis of bijective
string transformers.   The inputs to Optician are a pair of ordinary
regular expressions representing two data formats
and a few concrete examples for disambiguation.  The output is a well-typed
program in Boomerang (a bidirectional language based on the
theory of \emph{lenses}).
The main technical challenge involves navigating the vast program search
space efficiently.  In particular, and unlike most prior work on type-directed 
synthesis, our system operates in the context of a language with a rich equivalence
relation on types (the theory of regular expressions).  Consequently, program
synthesis requires search in two dimensions:  First, our synthesis algorithm must
find a pair of ``syntactically compatible types,'' and second, using the structure
of those types, it must find a type- and example-compliant term.  Our key insight is
that it is possible to
reduce the size of this search space \emph{without losing any computational power}
by defining a new language of lenses designed
specifically for synthesis.  The new language is free from arbitrary function
composition and operates only over types and terms in a new disjunctive normal form.
We prove (1) our new language
is just as powerful as a more natural, compositional, and declarative
language and (2) our synthesis algorithm is sound and complete with respect to the
new language.  We also demonstrate empirically
that our new language changes the synthesis problem from
one that admits intractable solutions to one that admits 
highly efficient solutions, able to synthesize intricate lenses
between complex file formats in seconds.  
We evaluate \emph{Optician} on a benchmark suite of 39 examples
that includes both microbenchmarks and realistic examples derived from
other data management systems including Flash Fill, a tool
for synthesizing string transformations in spreadsheets, and Augeas, a tool
for bidirectional processing of Linux system configuration files.
}
}
</pre>

<a name="PZ17"></a><pre>
@inproceedings{<a href="plclub.html#PZ17">PZ17</a>,
  author = {Jennifer Paykin and Steve Zdancewic},
  title = {{The Linearity Monad}},
  booktitle = {Proceedings of the 10th ACM SIGPLAN International Haskell Symposium},
  year = 2017,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/PZ17.pdf">http://www.cis.upenn.edu/~stevez/papers/PZ17.pdf</a>},
  abstract = {
We introduce a technique for programming with domain-specific
linear languages using the monad that arises from the theory of
linear/non-linear logic. In this work we interpret the linear/nonlinear
model as a simple, effectful linear language embedded inside
an existing non-linear host language. We implement a modular
framework for defining these linear EDSLs in Haskell, allowing
both shallow and deep embeddings. To demonstrate the effectiveness
of the framework and the linearity monad, we implement
languages for file handles, mutable arrays, session types, and quantum
computing.
}
}
</pre>

<a name="RPZ17"></a><pre>
@inproceedings{<a href="plclub.html#RPZ17">RPZ17</a>,
  author = {Robert Rand and Jennifer Paykin and Steve Zdancewic},
  title = {{$\mathcal{Q}$\textsc{wire} Practice: Formal Verification of Quantum Circuits in Coq}},
  booktitle = {The 14th International Conference on Quantum Physics and Logic (QPL)},
  year = 2017,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/RPZ17.pdf">http://www.cis.upenn.edu/~stevez/papers/RPZ17.pdf</a>},
  abstract = {
We describe an embedding of the QWIRE quantum circuit language in the Coq proof assistant. This
allows programmers to write quantum circuits using high-level abstractions and to prove properties of
those circuits using Coq’s theorem proving features. The implementation uses higher-order abstract
syntax to represent variable binding and provides a type-checking algorithm for linear wire types,
ensuring that quantum circuits are well-formed. We formalize a denotational semantics that interprets
QWIRE circuits as superoperators on density matrices, and prove the correctness of some simple
quantum programs.
}
}
</pre>

<a name="ABCP+17"></a><pre>
@article{<a href="plclub.html#ABCP+17">ABCP+17</a>,
  author = {Appel, Andrew W. and Beringer, Lennart and Chlipala, Adam and Pierce, Benjamin C. and Shao, Zhong and Weirich, Stephanie and Zdancewic, Steve},
  title = {Position paper: the science of deep specification},
  volume = {375},
  number = {2104},
  year = {2017},
  doi = {10.1098/rsta.2016.0331},
  publisher = {The Royal Society},
  abstract = {We introduce our efforts within the project "The science of deep specification" to work out the key formal underpinnings of industrial-scale formal specifications of software and hardware components, anticipating a world where large verified systems are routinely built out of smaller verified components that are also used by many other projects. We identify an important class of specification that has already been used in a few experiments that connect strong component-correctness theorems across the work of different teams. To help popularize the unique advantages of that style, we dub it deep specification, and we say that it encompasses specifications that are rich, two-sided, formal and live (terms that we define in the article). Our core team is developing a proof-of-concept system (based on the Coq proof assistant) whose specification and verification work is divided across largely decoupled subteams at our four institutions, encompassing hardware microarchitecture, compilers, operating systems and applications, along with cross-cutting principles and tools for effective specification. We also aim to catalyse interest in the approach, not just by basic researchers but also by users in industry.This article is part of the themed issue "Verified trustworthy software systems".},
  issn = {1364-503X},
  hjournal = {yes},
  plclub = {yes},
  url = {<a href="http://rsta.royalsocietypublishing.org/content/375/2104/20160331">http://rsta.royalsocietypublishing.org/content/375/2104/20160331</a>},
  journal = {Philosophical Transactions of the Royal Society of London A: Mathematical, Physical and Engineering Sciences}
}
</pre>

<a name="MPZD17"></a><pre>
@inproceedings{<a href="plclub.html#MPZD17">MPZD17</a>,
  author = {William Mansky and Yuanfeng Peng and Steve Zdancewic and Joseph Devietti},
  title = {Verifying Dynamic Race Detection},
  booktitle = {The 6th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP 2017)},
  year = 2017,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MPZD17.pdf">http://www.cis.upenn.edu/~stevez/papers/MPZD17.pdf</a>},
  abstract = { 
Writing race-free concurrent code is notoriously difficult, and data races can result in bugs that are difficult to isolate and reproduce. Dynamic race detection can catch data races that cannot (easily) be detected statically. One approach to dynamic race detection is to instrument the potentially racy code with operations that store and compare metadata, where the metadata implements some known race detection algorithm (e.g. vector-clock race detection). In this paper, we describe the process of formally verifying several algorithms for dynamic race detection. We then turn to implementations, laying out an instrumentation pass for race detection in a simple language and presenting a mechanized formal proof of its correctness: all races in a program will be caught by the instrumentation, and all races detected by the instrumentation are possible in the original program.
}
}
</pre>

<a name="PRZ17"></a><pre>
@inproceedings{<a href="plclub.html#PRZ17">PRZ17</a>,
  author = {Jennifer Paykin and Robert Rand and Steve Zdancewic},
  title = {{QWire: A Core Language for  Quantum Circuits}},
  booktitle = {Proc. of the  {ACM} Symposium on Principles of Programming Languages (POPL)},
  year = 2017,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/PRZ17.pdf">http://www.cis.upenn.edu/~stevez/papers/PRZ17.pdf</a>},
  abstract = {
  This paper introduces QWire (``choir''), a language for defining quantum
  circuits and an interface for manipulating them inside of an arbitrary
  classical host language. QWire is minimal---it contains only a
  few primitives---and sound with respect to the physical properties entailed by
  quantum mechanics. At the same time, QWire is expressive and highly modular
  due to its relationship with the host language, mirroring the QRAM model
  of computation that places a quantum computer (controlled by circuits)
  alongside a classical computer (controlled by the host language).

  We present QWire along with its type system and operational semantics, which
  we prove is safe and strongly normalizing whenever the host language is. We
  give circuits a denotational semantics in terms of density matrices. Throughout, we
  investigate examples that demonstrate the expressive power of QWire, including
  extensions to the host language that (1) expose a general analysis framework
  for circuits, and (2) provide dependent types.
}
}
</pre>

<a name="PZ16"></a><pre>
@inproceedings{<a href="plclub.html#PZ16">PZ16</a>,
  author = {Jennifer Paykin and Steve Zdancewic},
  title = {Linear $\lambda\mu$ is CP (more or less)},
  booktitle = {A List of Successes to Change the World (Wadlerfest)},
  year = 2016,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/PZ16.pdf">http://www.cis.upenn.edu/~stevez/papers/PZ16.pdf</a>},
  abstract = {
In this paper we compare Wadler's CP calculus for classical
linear processes to a linear version of Parigot's $\lambda\mu$ calculus
for classical logic. We conclude that linear $\lambda\mu$ is ``more or
less'' CP, in that it equationally corresponds to a polarized
version of CP. The comparison is made by extending a technique
from Melli\`{e}s and Tabareau's tensor logic that correlates negation
with polarization. The polarized CP, which is written CP$^{+-}$
and pronounced ``CP more or less,'' is an interesting bridge in
the landscape of Curry-Howard interpretations of logic.
}
}
</pre>

<a name="FOWZ16"></a><pre>
@inproceedings{<a href="plclub.html#FOWZ16">FOWZ16</a>,
  author = {Jonathan Frankle and Peter-Michael Osera and David Walker and Steve Zdancewic},
  title = {Example-Directed Synthesis: A Type-Theoretic Interpretation},
  booktitle = {Proc. of the  {ACM} Symposium on Principles of Programming Languages (POPL)},
  year = 2016,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/FOWZ16.pdf">http://www.cis.upenn.edu/~stevez/papers/FOWZ16.pdf</a>},
  abstract = {
Input-output examples have emerged as a practical and user-friendly
specification mechanism for program synthesis in many environments.
While example-driven tools have demonstrated tangible impact that has
inspired adoption in industry, their underlying semantics are less well-understood:
what are ``examples'' and how do they 
relate to other kinds of specifications?  This paper 
demonstrates that examples can, in general, be interpreted 
as refinement types.  Seen in this light, program 
synthesis is the task of finding an inhabitant of 
such a type.  This insight provides an immediate 
semantic interpretation for examples.  Moreover,
it enables us to exploit decades of research in type theory as 
well as its correspondence with intuitionistic logic rather 
than designing ad hoc theoretical frameworks for synthesis from scratch.

We put this observation into practice by formalizing synthesis 
as proof search in a sequent calculus with 
intersection and union refinements that we prove
to be sound with respect to a conventional type system.
In addition, we show how to handle negative examples, 
which arise from user feedback or counterexample-guided loops. 
This theory serves as the basis for a prototype 
implementation that extends our core language to 
support ML-style algebraic data types and structurally 
inductive functions.  Users can also specify
synthesis goals using polymorphic refinements and
import monomorphic libraries.
The prototype serves as a vehicle
for empirically evaluating a number of different 
strategies for resolving the nondeterminism of the sequent
 calculus---bottom-up theorem-proving, 
term enumeration with refinement type checking, and 
combinations of both---the results of which classify, explain, and
validate the design choices of existing synthesis systems.
It also provides a platform for measuring the practical
value of a specification language that combines
``examples'' with the more general expressiveness of refinements.
}
}
</pre>

<a name="RZ15"></a><pre>
@inproceedings{<a href="plclub.html#RZ15">RZ15</a>,
  author = {Robert Rand and Steve Zdancewic},
  title = {{VPHL: A Verified Partial-Correctness Logic for Probabilistic Programs}},
  booktitle = {Mathematical Foundations of Program Semantics (MFPS)},
  year = 2015,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/RZ15.pdf">http://www.cis.upenn.edu/~stevez/papers/RZ15.pdf</a>},
  abstract = { We introduce a Hoare-style logic for probabilistic
                  programs, called VPHL, that has been formally
                  verified in the Coq proof assistant. VPHL features
                  propositional, rather than additive, assertions and
                  a simple set of rules for reasoning about these
                  assertions using the standard axioms of probability
                  theory. \VPHL's assertions are \emph{partial
                  correctness assertions}, meaning that their
                  conclusions are dependent upon (deterministic)
                  program termination. The underlying simple
                  probabilistic imperative language, PRIMP, includes
                  a probabilistic toss operator, probabilistic guards
                  and potentially-non-terminating while loops.  }
}
</pre>

<a name="KPZ15"></a><pre>
@inproceedings{<a href="plclub.html#KPZ15">KPZ15</a>,
  author = {Neelakantan R. Krishnaswami and Jennifer Paykin and Steve Zdancewic},
  title = {Curry-Howard for GUIs},
  booktitle = {{POPL Off the Beaten Track (OBT)}},
  year = 2015,
  plclub = {yes},
  hconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/KPZ15.pdf">http://www.cis.upenn.edu/~stevez/papers/KPZ15.pdf</a>}
}
</pre>

<a name="NMZ15"></a><pre>
@inproceedings{<a href="plclub.html#NMZ15">NMZ15</a>,
  author = {Santosh Nagarakatte and
               Milo M. K. Martin and
               Steve Zdancewic},
  title = {Everything You Want to Know About Pointer-Based Checking},
  booktitle = {1st Summit on Advances in Programming Languages, {SNAPL} 2015, May
               3-6, 2015, Asilomar, California, {USA}},
  pages = {190--208},
  year = {2015},
  url = {<a href="http://dx.doi.org/10.4230/LIPIcs.SNAPL.2015.190">http://dx.doi.org/10.4230/LIPIcs.SNAPL.2015.190</a>},
  doi = {10.4230/LIPIcs.SNAPL.2015.190},
  hsconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/NMZ15.pdf">http://www.cis.upenn.edu/~stevez/papers/NMZ15.pdf</a>},
  abstract = {
Lack of memory safety in C/C++ has resulted in numerous security vulnerabilities and serious bugs in large software systems. This paper highlights the challenges in enforcing memory safety for C/C++ programs and progress made as part of the SoftBoundCETS project. We have been exploring memory safety enforcement at various levels - in hardware, in the compiler, and as a hardware-compiler hybrid - in this project. Our research has identified that maintaining metadata with pointers in a disjoint metadata space and performing bounds and use-after-free checking can provide comprehensive memory safety. We describe the rationale behind the design decisions and its ramifications on various dimensions, our experience with the various variants that we explored in this project, and the lessons learned in the process. We also describe and analyze the forthcoming Intel Memory Protection Extensions (MPX) that provides hardware acceleration for disjoint metadata and pointer checking in mainstream hardware, which is expected to be available later this year.
}
}
</pre>

<a name="MGZ15"></a><pre>
@inproceedings{<a href="plclub.html#MGZ15">MGZ15</a>,
  author = {William Mansky and Dmitri Garbuzov and Steve Zdancewic},
  title = {An Axiomatic Specification for Sequential Memory Models},
  booktitle = {Computer Aided Verification - 27th International Conference, {CAV}
               2015},
  year = 2015,
  hsconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MGZ15.pdf">http://www.cis.upenn.edu/~stevez/papers/MGZ15.pdf</a>},
  abstract = {
Formalizations of concurrent memory models often represent memory behavior in terms of sequences of operations, where operations are either reads, writes, or synchronizations. More concrete models of (sequential) memory behavior may include allocation and free operations, but also include details of memory layout or data representation. We present an abstract specification for sequential memory models with allocation and free operations, in the form of a set of axioms that provide enough information to reason about memory without overly constraining the behavior of implementations. We characterize a set of ``well-behaved'' programs that behave uniformly on all instances of the specification. We show that the specification is both feasible---the CompCert memory model implements it---and usable---we can use the axioms to prove the correctness of an optimization that changes the memory behavior of programs in an LLVM-like language.
}
}
</pre>

<a name="KHM+15"></a><pre>
@inproceedings{<a href="plclub.html#KHM+15">KHM+15</a>,
  author = {Jeehoon Kang and Chung-Kil Hur and William Mansky and Dmitri Garbuzov and Steve Zdancewic and Viktor Vafeiadis},
  title = {A Formal {C} Memory Model Supporting Integer-Pointer Casts},
  booktitle = {Proc. 2015 {ACM} SIGPLAN Conference on Programming Languages Design and Implementation (PLDI)},
  year = 2015,
  nsfr = {yes},
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/KHM+15.pdf">http://www.cis.upenn.edu/~stevez/papers/KHM+15.pdf</a>},
  abstract = {
  The ISO C standard does not specify the semantics of many valid programs that
  use non-portable idioms such as integer-pointer casts. Recent efforts at
  formal definitions and verified implementation of the C language inherit this
  feature. By adopting high-level abstract memory models, they validate common
  optimizations. On the other hand, this prevents reasoning about much low-level
  code relying on the behavior of common implementations, where formal
  verification has many applications.

  We present the first formal memory model that allows many common optimizations
  and \emph{fully} supports operations on the representation of pointers. All
  arithmetic operations are well-defined for pointers that have been cast to
  integers. Crucially, our model is also simple to understand and program with. All our results are fully formalized in Coq.
 }
}
</pre>

<a name="OZ15"></a><pre>
@inproceedings{<a href="plclub.html#OZ15">OZ15</a>,
  author = {Peter-Michael Osera and Steve Zdancewic},
  title = {{Type-and-Example-Directed Program Synthesis}},
  booktitle = {Proc. 2015 {ACM} SIGPLAN Conference on Programming Languages Design and Implementation (PLDI)},
  year = 2015,
  nsfr = {yes},
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/OZ15.pdf">http://www.cis.upenn.edu/~stevez/papers/OZ15.pdf</a>},
  abstract = {
    This paper presents an algorithm for synthesizing recursive
functions that process algebraic datatypes. It is founded on
proof-theoretic techniques that exploit both type information and
input--output examples to prune the search space. The algorithm uses
\textit{refinement trees}, a data structure that succinctly
represents constraints on the shape of generated code.  We evaluate
the algorithm by using a prototype implementation to synthesize more
than 40 benchmarks and several non-trivial larger examples.  Our
results demonstrate that the approach meets or outperforms the
state-of-the-art for this domain, in terms of synthesis time or
attainable size of the generated programs.
  }
}
</pre>

<a name="VZ14"></a><pre>
@inproceedings{<a href="plclub.html#VZ14">VZ14</a>,
  author = {Beno\^{i}t Valiron and Steve Zdancewic},
  title = {Finite vector spaces as model of simply-typed lambda-calculi},
  booktitle = {Proceedings of the 11th International Colloquium on Theoretical Aspects of Computing (ICTAC 14)},
  year = 2014,
  plclub = {yes},
  hsconf = {yes},
  nsfr = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/VZ14.pdf">http://www.cis.upenn.edu/~stevez/papers/VZ14.pdf</a>},
  abstract = {
In this paper we use finite vector spaces (finite dimension, over
finite fields) as a non-standard computational model of linear
logic. We first define a simple, finite PCF-like lambda-calculus with
booleans, and then we discuss two finite models, one based on finite
sets and the other on finite vector spaces. The first model is shown
to be fully complete with respect to the operational semantics of the
language. The second model is not complete, but we develop an
algebraic extension of the finite lambda calculus that recovers
completeness. The relationship between the two semantics is described,
and several examples based on Church numerals are presented.
}
}
</pre>

<a name="VZ14a"></a><pre>
@article{<a href="plclub.html#VZ14a">VZ14a</a>,
  title = {Modeling Simply-Typed Lambda Calculi in the Category of Finite Vector Spaces},
  author = {B. Valiron and S. Zdancewic},
  journal = {Scientific Annals of Computer Science},
  volume = 24,
  number = 2,
  organization = {``A.I. Cuza'' University, Ia\c si, Rom\^ania},
  year = 2014,
  pages = {325--368},
  doi = {10.7561/SACS.2014.2.325},
  publisher = {``A.I. Cuza'' University Press, Ia\c si},
  hjournal = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.infoiasi.ro/bin/download/Annals/XXIV2/XXIV2_5.pdf">http://www.infoiasi.ro/bin/download/Annals/XXIV2/XXIV2_5.pdf</a>},
  abstract = { In this paper we use finite vector spaces (finite
                  dimension, over finite fields) as a non-standard
                  computational model of linear logic. We first define
                  a simple, finite PCF-like lambda-calculus with
                  booleans, and then we discuss two finite models, one
                  based on finite sets and the other on finite vector
                  spaces. The first model is shown to be fully
                  complete with respect to the operational semantics
                  of the language, while the second model is not. We
                  then develop an algebraic extension of the finite
                  lambda calculus and study two operational semantics:
                  a call-by-name and a call-by-value. These
                  operational semantics are matched with their
                  corresponding natural denotational semantics based
                  on finite vector spaces. The relationship between
                  the various semantics is analyzed, and several
                  examples based on Church numerals are presented.  }
}
</pre>

<a name="PZ14"></a><pre>
@inproceedings{<a href="plclub.html#PZ14">PZ14</a>,
  author = {Jennifer Paykin and Steve Zdancewic},
  title = {A Linear/Producer/Consumer model of Classical Linear Logic (extended abstract)},
  booktitle = {Third International Workshop on Linearity},
  year = 2014,
  series = {LINEARITY},
  plclub = {yes},
  hconf = {yes},
  nsfr = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/PZ14.pdf">http://www.cis.upenn.edu/~stevez/papers/PZ14.pdf</a>},
  abstract = {
This paper defines a new proof- and category-theoretic framework for
\textit{classical linear logic} that separates reasoning into one linear regime
and two persistent regimes corresponding to ! and ?. The resulting
linear/producer/consumer (LPC) logic puts the three classes of
propositions on the same semantic footing, following Benton's
linear/non-linear formulation of intuitionistic linear logic.
Semantically, LPC corresponds to a system of three categories
connected by adjunctions reflecting the linear/producer/consumer
structure. The paper's metatheoretic results include admissibility
theorems for the cut and duality rules, and a translation of the LPC
logic into category theory. The work also presents several
concrete instances of the LPC model.
}
}
</pre>

<a name="BGMZ14"></a><pre>
@inproceedings{<a href="plclub.html#BGMZ14">BGMZ14</a>,
  author = {Alo\"is Brunel and Marco Gaboardi and Damiano Mazza and Steve
Zdancewic},
  title = {A Core Quantitative Coeffect Calculus},
  booktitle = {Proc. of the 23rd European Symposium on Programming (ESOP)},
  year = 2014,
  volume = 8410,
  pages = {351--370},
  plclub = {yes},
  hsconf = {yes},
  nsfr = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/BGMZ14.pdf">http://www.cis.upenn.edu/~stevez/papers/BGMZ14.pdf</a>},
  abstract = {
Linear logic is well known for its resource-awareness, which has
inspired the design of several resource management mechanisms in
programming language design. Its resource-awareness arises
from the distinction between linear, single-use data and
non-linear, reusable data. The latter is marked by the so-called
exponential modality, which, from the categorical viewpoint, is a
(monoidal) comonad.

Monadic notions of computation are well-established
mechanisms used to express effects in pure functional
languages. Less well-established is the notion of comonadic
computation. However, recent works have shown the usefulness of
comonads to structure context dependent computations. 
In this work, we present a language lrPCF inspired by a
generalized interpretation of the exponential modality. In lrPCF the
exponential modality carries a label---an element of a
semiring $R$---that provides
additional information on how a program uses its context. 
This additional structure is used
to express comonadic type analysis. 
}
}
</pre>

<a name="PZ14tr"></a><pre>
@techreport{<a href="plclub.html#PZ14tr">PZ14tr</a>,
  author = {Jennifer Paykin and Steve Zdancewic},
  title = {A Linear/Producer/Consumer model of Classical Linear Logic},
  institution = {University of Pennsylvania},
  year = 2014,
  plclub = {yes},
  htr = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/PZ14tr.pdf">http://www.cis.upenn.edu/~stevez/papers/PZ14tr.pdf</a>},
  abstract = { 
This paper defines a new proof- and category-theoretic framework for
classical linear logic that separates reasoning into one linear regime
and two persistent regimes corresponding to ! and ?. The resulting
linear/producer/consumer (LPC) logic puts the three classes of
propositions on the same semantic footing, following Benton's
linear/non-linear formulation of intuitionistic linear logic.
Semantically, LPC corresponds to a system of three categories
connected by adjunctions that reflect the linear/producer/consumer
structure. The paper's metatheoretic results include admissibility
theorems for the cut and duality rules, and a translation of the LPC
logic into the category theory. The work also presents several
concrete instances of the LPC model, including one based on finite
vector spaces.
}
}
</pre>

<a name="NMZ14"></a><pre>
@inproceedings{<a href="plclub.html#NMZ14">NMZ14</a>,
  author = {Nagarakatte, Santosh and Martin, Milo M. K. and Zdancewic, Steve},
  title = {WatchdogLite: Hardware-Accelerated Compiler-Based Pointer Checking},
  booktitle = {Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization},
  series = {CGO '14},
  year = 2014,
  pages = {175:175--175:184},
  articleno = 175,
  numpages = 10,
  url = {<a href="http://doi.acm.org/10.1145/2544137.2544147">http://doi.acm.org/10.1145/2544137.2544147</a>},
  doi = {10.1145/2544137.2544147},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/NMZ14.pdf">http://www.cis.upenn.edu/~stevez/papers/NMZ14.pdf</a>},
  hsconf = {yes},
  plclub = {yes},
  publisher = {ACM},
  abstract = {

Lack of memory safety in C is the root cause of a multitude of serious bugs and security vulnerabilities. Numerous software-only and hardware-based schemes have been proposed to enforce memory safety. Among these approaches, pointer-based checking, which maintains per-pointer metadata in a disjoint metadata space, has been recognized as providing comprehensive memory safety. Software approaches for pointer-based checking have high performance overheads. In contrast, hardware approaches introduce a myriad of hardware structures and widgets to mitigate those performance overheads.

This paper proposes WatchdogLite, an ISA extension that provides hardware acceleration for a compiler implementation of pointer-based checking. This division of labor between the compiler and the hardware allows for hardware acceleration while using only preexisting architectural registers. By leveraging the compiler to identify pointers, perform check elimination, and insert the new instructions, this approach attains performance similar to prior hardware-intensive approaches without adding any hardware structures for tracking metadata.
 }
}
</pre>

<a name="DENO+13"></a><pre>
@inproceedings{<a href="plclub.html#DENO+13">DENO+13</a>,
  author = {Christian DeLozier and Richard Eisenberg and Santosh Nagarakatte and Peter-Michael Osera and Milo M. K. Martin and Steve Zdancewic},
  title = {Ironclad {C++}: A Library-Augmented Type-Safe Subset of {C++}},
  booktitle = {Proceedings of the 28th Annual {ACM SIGPLAN} Conference on
               Object-Oriented Programming, Systems, Languages, and Applications,
               (OOPSLA)},
  year = 2013,
  hsconf = {yes},
  plclub = {yes},
  nsfo = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/DENO+13.pdf">http://www.cis.upenn.edu/~stevez/papers/DENO+13.pdf</a>},
  abstract = {
The C++ programming language remains widely used, despite inheriting
many unsafe features from C---features that often lead to failures of
type or memory safety that manifest as buffer overflows,
use-after-free vulnerabilities, or abstraction violations. Malicious
attackers can exploit such violations to compromise application and
system security.

This paper introduces Ironclad C++, an approach to bringing the
benefits of type and memory safety to C++. Ironclad C++ is, in
essence, a library-augmented, type-safe subset of C++. All Ironclad
C++ programs are valid C++ programs that can be compiled using
standard, off-the-shelf C++ compilers. However, not all valid C++
programs are valid Ironclad C++ programs: a syntactic source-code
validator statically prevents the use of unsafe C++ features. To
enforce safety properties that are difficult to check statically,
Ironclad C++ applies dynamic checks via templated ``smart pointer''
classes. 

Using a semi-automatic refactoring tool, we have ported nearly 50K
lines of code to Ironclad C++. These benchmarks incur a performance
overhead of 12\% on average, compared to the original unsafe C++
code.
}
}
</pre>

<a name="NMZ13"></a><pre>
@article{<a href="plclub.html#NMZ13">NMZ13</a>,
  author = {Santosh Nagarakatte and Milo M K Martin and Steve Zdancewic},
  title = {Hardware-enforced Comprehensive Memory Safety},
  journal = {IEEE MICRO's "Top Picks of Architecture Conferences of 2012" Issue (Micro Top Picks'2013)},
  year = {2013},
  month = {May/June},
  pdf = {<a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6487479">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6487479</a>},
  hsconf = {yes},
  plclub = {yes},
  nsfr = {no},
  abstract = {
The lack of memory safety in languages such as C and C++ is a root
                  source of exploitable security vulnerabilities. This
                  article presents Watchdog, a hardware approach that
                  eliminates such vulnerabilities by enforcing
                  comprehensive memory safety. Inspired by prior
                  software-only mechanisms, Watchdog maintains bounds
                  and identifier metadata with pointers, propagates
                  them on pointer operations, and checks them on
                  pointer dereferences. Checking this bounds and
                  identifier metadata provides both precise,
                  byte-granularity buffer-overflow protection and
                  protection from use-after-free errors, even in the
                  presence of reallocations. Watchdog stores pointer
                  metadata in a disjoint shadow space to provide
                  comprehensive protection and ensure compatibility
                  with existing code. To streamline implementation and
                  reduce runtime overhead, Watchdog uses
                  micro-operations to implement metadata access and
                  checking, eliminates metadata copies via a register
                  renaming scheme, and uses a dedicated identifier
                  cache to reduce checking overhead.  
 }
}
</pre>

<a name="DEN+13"></a><pre>
@techreport{<a href="plclub.html#DEN+13">DEN+13</a>,
  author = {Christian DeLozier and Richard Eisenberg and Santosh Nagarakatte and Peter-Michael Osera and Milo M.K. Martin and Steve Zdancewic},
  title = {Ironclad {C++}: A library-Augmented Type-Safe Subset of {C++}},
  institution = {University of Pennsylvania},
  year = 2013,
  number = {MS-CIS-13-05},
  month = mar,
  plclub = {yes},
  htr = {yes},
  nsfo = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/DEN+13.pdf">http://www.cis.upenn.edu/~stevez/papers/DEN+13.pdf</a>}
}
</pre>

<a name="ZNMZ13"></a><pre>
@inproceedings{<a href="plclub.html#ZNMZ13">ZNMZ13</a>,
  author = {Jianzhou Zhao and Santosh Nagarakatte and Milo M. K. Martin and Steve Zdancewic},
  title = {Formal Verification of {SSA}-Based Optimizations for {LLVM}},
  booktitle = {Proc. 2013 {ACM} SIGPLAN Conference on Programming Languages Design and Implementation (PLDI)},
  year = 2013,
  hsconf = {yes},
  plclub = {yes},
  nsfr = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZNMZ13.pdf">http://www.cis.upenn.edu/~stevez/papers/ZNMZ13.pdf</a>},
  abstract = {
Modern compilers, such as LLVM and GCC, use a \emph{static single assignment}
(SSA) intermediate representation (IR) to simplify and enable many advanced
optimizations. However, formally verifying the correctness of SSA-based
optimizations is challenging because SSA properties depend on a function's
entire control-flow graph.   

This paper addresses this challenge by developing a proof technique
for proving SSA-based program invariants and compiler optimizations.
We use this technique in the Coq proof assistant to create
mechanized correctness proofs of several ``micro'' transformations
that form the building blocks for larger SSA optimizations.  To demonstrate
the utility of this approach, we formally verify a variant of LLVM's
\texttt{memtoreg} transformation in \textsc{Vellvm}, a Coq-based formal
semantics of the LLVM IR. The extracted implementation generates code with performance
comparable to that of LLVM's unverified implementation.}
}
</pre>

<a name="ZZ12"></a><pre>
@inproceedings{<a href="plclub.html#ZZ12">ZZ12</a>,
  author = {Jianzhou Zhao and Steve Zdancewic},
  title = {Mechanized Verification of Computing Dominators for Formalizing Compilers},
  booktitle = {The Second International Conference on Certified Programs and Proofs (CPP)},
  series = {Lecture Notes in Computer Science},
  pages = {27--42},
  year = 2012,
  hsconf = {yes},
  plclub = {yes},
  nsfr = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZ12.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZ12.pdf</a>},
  abstract = {
One prerequisite to the formal verification of modern compilers is to formalize
computing dominators, which enable SSA forms, advanced optimizations, and
analysis. This paper provides an abstract specification of dominance
analysis that is sufficient for formalizing modern compilers; it describes a
certified implementation and instance of the specification that is simple to
design and reason about, and also reasonably efficient. The paper also presents
applications of dominance analysis: an SSA-form type checker, verifying
SSA-based optimizations, and constructing dominator trees. This development is a
part of the Vellvm project. All proofs and implementation have been carried
out in Coq.}
}
</pre>

<a name="NMZ12"></a><pre>
@inproceedings{<a href="plclub.html#NMZ12">NMZ12</a>,
  author = {Santosh Nagarakatte and Milo M.~K. Martin and Steve Zdancewic},
  title = {Watchdog: Hardware for Safe and Secure Manual Memory
  Management and Full Memory Safety},
  booktitle = {Proceedings of the 39th International Symposium on Computer Architecture (ISCA)},
  year = 2012,
  month = jun,
  hsconf = {yes},
  plclub = {yes},
  nsfo = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/NMZ12.pdf">http://www.cis.upenn.edu/~stevez/papers/NMZ12.pdf</a>},
  abstract = {
Languages such as C and C++ use unsafe manual memory
    management, allowing simple bugs (\textit{i.e.}, accesses to an object after
    deallocation) to become the root cause of exploitable security
    vulnerabilities.  This paper proposes Watchdog, a hardware-based
    approach for ensuring safe and secure manual memory management.
    Inspired by prior software-only proposals, Watchdog generates a
    unique identifier for each memory allocation, associates these
    identifiers with pointers, and checks to ensure that the
    identifier is still valid on every memory access. This use of
    identifiers and checks enables Watchdog to detect errors even in
    the presence of reallocations.  
    Watchdog stores these pointer identifiers in a disjoint shadow
    space to provide comprehensive protection and ensure compatibility
    with existing code.
    To streamline the implementation
    and reduce runtime overhead: Watchdog (1) uses micro-ops to
    access metadata and perform checks, (2) eliminates metadata
    copies among registers via modified register renaming, and (3)
    uses a dedicated metadata cache to reduce checking overhead.
    Furthermore, this paper extends Watchdog's mechanisms to detect
    bounds errors, thereby providing full hardware-enforced memory
    safety at low overheads.}
}
</pre>

<a name="OSZ12"></a><pre>
@inproceedings{<a href="plclub.html#OSZ12">OSZ12</a>,
  author = {Peter-Michael Osera and Vilhelm Sj\"{o}berg and Steve Zdancewic},
  title = {Dependent Ineroperability},
  booktitle = {The Sixth ACM SIGPLAN Workshop on 
Programming Languages meets Program Verification (PLPV)},
  year = 2012,
  hconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/OSZ12.pdf">http://www.cis.upenn.edu/~stevez/papers/OSZ12.pdf</a>},
  abstract = {
In this paper we study the problem of \textit{interoperability}---combining
constructs from two separate programming languages within one program---in the
case where one of the two languages is dependently typed and the other is simply
typed.  We present a core calculus called SD, which combines dependently-
and simply-typed sub-languages and supports user-defined (dependent) datatypes,
among other standard features. SD has ``boundary terms'' that mediate the
interaction between the two sub-languages.  The operational semantics of SD
demonstrates how the necessary dynamic checks, which must be done when passing a
value from the simply-typed world to the dependently typed world, can be
extracted from the dependent type constructors themselves, modulo user-defined
functions for marshaling values across the boundary.  We establish type-safety
and other meta-theoretic properties of SD, and contrast this approach to
others in the literature.
}
}
</pre>

<a name="ZNMZ12"></a><pre>
@inproceedings{<a href="plclub.html#ZNMZ12">ZNMZ12</a>,
  author = {Jianzhou Zhao and Santosh Nagarakatte and Milo M.~K. Martin and Steve Zdancewic},
  title = {{Formalizing the LLVM Intermediate Representation for Verified
  Program Transformations}},
  booktitle = {Proc. of the  {ACM} Symposium on Principles of Programming Languages (POPL)},
  year = 2012,
  hsconf = {yes},
  plclub = {yes},
  nsfr = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZNMZ12.pdf">http://www.cis.upenn.edu/~stevez/papers/ZNMZ12.pdf</a>},
  abstract = {
This paper presents Vellvm (\textit{verified LLVM}), a framework
for reasoning about programs expressed in LLVM's intermediate
representation and transformations that operate on it.  Vellvm
provides a mechanized formal semantics of LLVM's intermediate
representation, its type system, and properties of its SSA form.
The framework is built using the Coq interactive theorem prover.  
It includes multiple operational semantics and proves relations among
them to facilitate different reasoning styles and proof
techniques.

To validate Vellvm's design, we extract an interpreter from the Coq
formal semantics that can execute programs from LLVM test suite and 
thus be compared against LLVM reference implementations.
To demonstrate Vellvm's practicality, we formalize and verify a
previously proposed transformation that hardens C programs against
spatial memory safety violations.  Vellvm's tools allow us to extract
a new, verified implementation of the transformation pass that plugs
into the real LLVM infrastructure; its performance is competitive with
the non-verified, ad-hoc original.
  }
}
</pre>

<a name="WVPJZ11"></a><pre>
@inproceedings{<a href="plclub.html#WVPJZ11">WVPJZ11</a>,
  author = {Stephanie Weirich and Dimitrios Vytiniotis and Simon {Peyton Jones} and Steve Zdancewic},
  title = {Generative Type Abstraction and Type-level Computation},
  booktitle = {Proc. of the  {ACM} Symposium on Principles of Programming Languages (POPL)},
  year = 2011,
  hsconf = {yes},
  plclub = {yes},
  nsfo = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/WVPJZ11.pdf">http://www.cis.upenn.edu/~stevez/papers/WVPJZ11.pdf</a>},
  abstract = {
Modular languages support \emph{generative type abstraction},
ensuring that an abstract type is distinct from its
representation, except inside the implementation where the
two are synonymous.  We show that this well-established
feature is in tension with the \emph{non-parametric features}
of newer type systems, such as indexed type families and GADTs.
In this paper we solve the problem by using kinds to 
distinguish between parametric and non-parametric contexts.
The result is directly applicable to Haskell, which is rapidly
developing support for type-level computation, but the same
issues should arise whenever generativity and non-parametric features
are combined.
}
}
</pre>

<a name="ZZZ10"></a><pre>
@inproceedings{<a href="plclub.html#ZZZ10">ZZZ10</a>,
  author = {Jianzhou Zhao and Qi Zhang and Steve Zdancewic},
  title = {Relational Parametricity for Polymorphic Linear Lambda Calculus},
  booktitle = {Proceedings of the Eighth {ASIAN} Symposium on Programming Languages and Systems (APLAS)},
  year = 2010,
  hsconf = {yes},
  plclub = {yes},
  nsfo = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZZ10.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZZ10.pdf</a>},
  abstract = {
This paper presents a novel syntactic logical relation for a polymorphic
linear lambda-calculus that treats all types as linear and introduces the
constructor ! to account for intuitionistic terms, and Fo---an
extension of System F that uses kinds to distinguish linear from intuitionistic
types. We define a logical relation for open values under both open linear and
intuitionistic contexts, then extend it for open terms with evaluation and
open relation substitutions. Relations that instantiate type quantifiers are
for open terms and types. We demonstrate the applicability of this logical
relation through its soundness with respect to contextual equivalence, along
with free theorems for linearity that are difficult to achieve by closed
logical relations. When interpreting types on only closed terms, the model
defaults to a closed logical relation that is both sound and complete with
respect to contextual equivalence and is sufficient to reason about
isomorphisms of type encodings. All of our results have been mechanically
verified in Coq.
}
}
</pre>

<a name="ZZZ10tr"></a><pre>
@unpublished{<a href="plclub.html#ZZZ10tr">ZZZ10tr</a>,
  author = {Jianzhou Zhao and Qi Zhang and Steve Zdancewic},
  title = {Relational Parametricity for Polymorphic Linear Lambda Calculus (Extended TR)},
  year = 2010,
  htr = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZZ10tr.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZZ10tr.pdf</a>},
  abstract = {This is the technical report for the corrsponding APLAS 2010 paper.}
}
</pre>

<a name="NZMZ10"></a><pre>
@inproceedings{<a href="plclub.html#NZMZ10">NZMZ10</a>,
  author = {Santosh Nagarakatte and Jianzhou Zhao and Milo M.~K. Martin and Steve Zdancewic},
  title = {{CETS}: Compiler-Enforced Temporal Safety for C},
  booktitle = {Proceedings of the ACM International Symposium on Memory Management (ISMM)},
  year = 2010,
  hsconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/NZMZ10.pdf">http://www.cis.upenn.edu/~stevez/papers/NZMZ10.pdf</a>},
  abstract = {
Temporal memory safety errors, such as dangling pointer dereferences and
double frees, are a prevalent source of software bugs in unmanaged
languages such as C.  Existing schemes that attempt to retrofit temporal
safety for such languages have high runtime overheads and/or are
incomplete, thereby limiting their effectiveness as debugging aids.
This paper presents CETS, a compile-time transformation for detecting
all violations of temporal safety in C programs. Inspired by existing
approaches, CETS maintains a unique identifier with each object,
associates this metadata with the pointers in a disjoint metadata space
to retain memory layout compatibility, and checks that the object is
still allocated on pointer dereferences.  A formal proof shows that this
is sufficient to provide temporal safety even in the presence of
arbitrary casts if the program contains no spatial safety violations.
Our CETS prototype employs both temporal check removal optimizations
and traditional compiler optimizations to achieve a runtime overhead of
just 48\% on average.  When combined with a
spatial-checking system, the average overall overhead is 116\%
for complete memory safety.
}
}
</pre>

<a name="MZ10"></a><pre>
@inproceedings{<a href="plclub.html#MZ10">MZ10</a>,
  author = {Karl Mazurak and Steve Zdancewic},
  title = {Lolliproc: to {Concurrency from Classical Linear Logic
                 via Curry-Howard and Control}},
  booktitle = {Proc. of the 15th ACM SIGPLAN International Conference on
		  Functional Programming (ICFP)},
  year = 2010,
  hsconf = {yes},
  plclub = {yes},
  nsfr = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MZ10.pdf">http://www.cis.upenn.edu/~stevez/papers/MZ10.pdf</a>},
  abstract = {
While many type systems
based on the intuitionistic fragment of linear logic have been
proposed, applications in programming languages of the full power of
linear logic---including double-negation elimination---have remained
elusive.  Meanwhile, linearity has been used in many type systems for
concurrent programs---e.g., session types---which suggests
applicability to the problems of concurrent programming, but the ways
in which linearity has interacted with concurrency primitives in
lambda calculi have remained somewhat ad-hoc.  In this paper we
connect classical linear logic and concurrent functional programming
in the language Lolliproc, which provides simple primitives for
concurrency that have a direct logical interpretation and that combine
to provide the functionality of session types.  Lolliproc features a
simple process calculus ``under the hood'' but hides the machinery of
processes from programmers.  We illustrate Lolliproc by example and
prove soundness, strong normalization, and confluence results, which,
among other things, guarantees freedom from deadlocks and race
conditions.
}
}
</pre>

<a name="LZ10"></a><pre>
@article{<a href="plclub.html#LZ10">LZ10</a>,
  author = {Peng Li and Steve Zdancewic},
  title = {{Arrows for Secure Information Flow}},
  journal = {Theoretical Computer Science},
  volume = {411},
  number = {19},
  pages = {1974-1994},
  year = 2010,
  publisher = {Elsevier},
  plclub = {yes},
  hjournal = {yes},
  nsfo = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ10.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ10.pdf</a>},
  abstract = {
This paper presents an embedded security sublanguage for enforcing information- 
flow policies in the standard Haskell programming language. The sublanguage pro- 
vides useful information-flow control mechanisms including dynamic security lat- 
tices, run-time code privileges and declassification all without modifying the base 
language. This design avoids the redundant work of producing new languages, low- 
ers the threshold for adopting security-typed languages, and also provides great 
flexibility and modularity for using security-policy frameworks. 

The embedded security sublanguage is designed using a standard combinator in- 
terface called \textit{arrows}. Computations constructed in the sublanguage have static and 
explicit control-flow components, making it possible to implement information-flow 
control using static-analysis techniques at run time, while providing strong secu- 
rity guarantees. This paper presents a formal proof that our embedded sublanguage 
provides noninterference, a concrete Haskell implementation and an example appli- 
cation demonstrating the proposed techniques.
  }
}
</pre>

<a name="MZZ10"></a><pre>
@inproceedings{<a href="plclub.html#MZZ10">MZZ10</a>,
  author = {Karl Mazurak and
               Jianzhou Zhao and
               Steve Zdancewic},
  title = {Lightweight linear types in {System} {F}$^{\circ}$},
  booktitle = {ACM SIGPLAN International Workshop on Types in Languages Design and Implementation (TLDI)},
  year = 2010,
  pages = {77-88},
  plclub = {yes},
  hconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MZZ10.pdf">http://www.cis.upenn.edu/~stevez/papers/MZZ10.pdf</a>},
  abstract = {
We present F$^{\circ}$, an extension of System F that uses
\emph{kinds} to distinguish between linear and unrestricted types,
simplifying the use of linearity for general-purpose programming. We
demonstrate through examples how F$^{\circ}$ can elegantly express many
useful protocols, and we prove that any protocol representable
as a DFA can be encoded as an F$^{\circ}$ type.  We supply
mechanized proofs of F$^{\circ}$'s
soundness and parametricity properties, along with a
nonstandard operational semantics that formalizes common intuitions
about linearity and aids in reasoning about protocols.

We compare F$^{\circ}$ to other linear systems, noting that the simplicity of our
kind-based approach leads to a more explicit account of what linearity
is meant to capture, allowing otherwise-conflicting interpretations of
linearity (in particular, restrictions on \emph{aliasing} versus
restrictions on resource \emph{usage}) to coexist peacefully.
We also discuss extensions to F$^{\circ}$ aimed at making the
core language more practical, including the additive fragment of
linear logic, algebraic datatypes, and recursion.
}
}
</pre>

<a name="MGLZ09"></a><pre>
@inproceedings{<a href="plclub.html#MGLZ09">MGLZ09</a>,
  author = {Michael J. May and
               Carl A. Gunter and
               Insup Lee and
               Steve Zdancewic},
  title = {Strong and Weak Policy Relations},
  booktitle = {POLICY 2009, IEEE International Symposium on Policies for
               Distributed Systems and Networks},
  year = {2009},
  pages = {33-36},
  plclub = {yes},
  hconf = {yes}
}
</pre>

<a name="JZ09"></a><pre>
@inproceedings{<a href="plclub.html#JZ09">JZ09</a>,
  author = {Limin Jia and
               Steve Zdancewic},
  title = {Encoding information flow in {Aura}},
  booktitle = {Proceedings of the 2009 Workshop on Programming Languages
               and Analysis for Security (PLAS)},
  year = 2009,
  pages = {17-29},
  plclub = {yes},
  hconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/JZ09.pdf">http://www.cis.upenn.edu/~stevez/papers/JZ09.pdf</a>},
  abstract = {
  Two of the main ways to protect security-sensitive
  resources in computer systems are to enforce access-control policies
  and information-flow policies. In this paper, we show how to enforce
  information-flow policies in AURA, which is a programming
  language for access control. When augmented with this mechanism for
  enforcing information-flow polices, AURA can further improve the
  security of reference monitors that implement access control.

  We show how to encode security types
  and lattices of security labels using AURA's existing constructs
  for authorization logic. We prove a noninterference theorem for
  this encoding.  We also investigate how to use expressive
  access-control policies specified in authorization logic as the policies
  for information declassification.
  }
}
</pre>

<a name="BPSW+09"></a><pre>
@inproceedings{<a href="plclub.html#BPSW+09">BPSW+09</a>,
  author = {Aaron Bohannon and Benjamin C. Pierce and Vilhelm Sj\"oberg and Stephanie Weirich and Steve Zdancewic},
  title = {Reactive Noninterference},
  booktitle = {ACM Computer and Communications Security Conference (CCS)},
  year = 2009,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/BPSW+09.pdf">http://www.cis.upenn.edu/~stevez/papers/BPSW+09.pdf</a>},
  abstract = {
Many programs operate reactively---patiently waiting for user input, running
for a while producing output, and eventually returning to a state where they
are ready to accept another input (or occasionally diverging).  When a
reactive program communicates with multiple parties, we would like to be
sure that it can be given secret information by one without leaking it to
others.

Motivated by web browsers and client-side web applications,
we explore definitions of noninterference for reactive programs and
identify two of special interest---one corresponding to
termination-insensitive noninterference for a simple sequential language,
the other to termination-sensitive noninterference.  We focus on the former
and develop a proof technique for showing that program behaviors are secure
according to this definition.  To demonstrate the viability of the approach,
we define a simple reactive language with an information-flow type system
and apply our proof technique to show that well-typed programs are secure.
}
}
</pre>

<a name="FPZ09"></a><pre>
@inproceedings{<a href="plclub.html#FPZ09">FPZ09</a>,
  author = {J. Nathan Foster and Benjamin C. Pierce and Steve Zdancewic},
  title = {Updatable Security Views},
  booktitle = {Proc. of 22nd IEEE Computer Security Foundations Symposium (CSF)},
  year = 2009,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/FPZ09.pdf">http://www.cis.upenn.edu/~stevez/papers/FPZ09.pdf</a>},
  abstract = {
Security views are a flexible and effective mechanism for controlling
access to confidential information.  Rather than allowing untrusted
users to access source data directly, they are instead provided with a
restricted view, from which all confidential information has been
removed.  The program that generates the view effectively embodies a
confidentiality policy for the underlying source data. However, this
approach has a significant drawback: it prevents users from updating
the data in the view.

To address the ``view update problem'' in general, a number of
bidirectional languages have been proposed. Programs in these
languages---often called lenses---can be run in two directions: read
from left to right, they map sources to views; from right to left,
they map updated views back to updated sources. However, existing
bidirectional languages do not deal adequately with security.  In
particular, they do not provide a way to ensure the integrity of
source data as it is manipulated by untrusted users of the view.

We propose a novel framework of secure lenses that addresses these
shortcomings. We enrich the types of basic lenses with equivalence
relations capturing notions of confidentiality and integrity, and
formulate the essential security conditions as non-interference
properties. We then instantiate this framework in the domain of string
transformations, developing syntax for bidirectional string
combinators with security-annotated regular expressions as their
types.
}
}
</pre>

<a name="NZMZ09"></a><pre>
@inproceedings{<a href="plclub.html#NZMZ09">NZMZ09</a>,
  author = {Santosh Nagarakatte and Jianzhou Zhao and Milo M. K. Martin and Steve Zdancewic},
  title = {{SoftBound}: {Highly Compatible and Complete Spatial Memory Safety for C}},
  booktitle = {Proc. 2009 {ACM} SIGPLAN Conference on Programming Languages Design and Implementation (PLDI)},
  year = 2009,
  plclub = {yes},
  hsconf = {yes},
  nsfo = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/NZMZ09.pdf">http://www.cis.upenn.edu/~stevez/papers/NZMZ09.pdf</a>},
  abstract = {
The serious bugs and security vulnerabilities facilitated by C/C++'s
lack of bounds checking are well known, yet C and C++ remain in
widespread use.  Unfortunately, C's arbitrary pointer arithmetic,
conflation of pointers and arrays, and programmer-visible memory layout
make retrofitting C/C++ with spatial safety guarantees extremely
challenging.  Existing approaches suffer from incompleteness, have high
runtime overhead, or require non-trivial changes to the C source code.
Thus far, these deficiencies have prevented widespread adoption of such
techniques.

This paper proposes SoftBound, a compile-time transformation for
enforcing spatial safety of C.  Inspired by HardBound, a
previously proposed hardware-assisted approach, SoftBound similarly
records base and bound information for every pointer as disjoint
metadata.  This decoupling enables SoftBound to provide
spatial safety without requiring changes to C source code.  Unlike
HardBound, SoftBound is a software-only approach and performs
metadata manipulation only when loading or storing pointer values.  A
formal proof shows that this is sufficient to provide spatial safety
even in the presence of arbitrary casts.  SoftBound's full checking
mode provides complete spatial violation detection with 67\%
runtime overhead on average.  To further reduce overheads, SoftBound
has a store-only checking mode that successfully detects all the
security vulnerabilities in a test suite at the cost of only
22\% runtime overhead on average.
}
}
</pre>

<a name="JVMZ+08"></a><pre>
@inproceedings{<a href="plclub.html#JVMZ+08">JVMZ+08</a>,
  author = {Limin Jia and Jeffrey A. Vaughan and Karl Mazurak and
  Jianzhou Zhao and Luke Zarko and Joseph Schorr and Steve Zdancewic},
  title = {{AURA}: {A} Programming Language for Authorization and Audit},
  booktitle = {Proc. of the 13th ACM SIGPLAN International Conference on
		  Functional Programming (ICFP)},
  year = 2008,
  address = {Victoria, British Columbia, Canada},
  month = sep,
  hsconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/JVMZ08.pdf">http://www.cis.upenn.edu/~stevez/papers/JVMZ08.pdf</a>},
  abstract = {
This paper presents AURA, a programming language for access control that
treats ordinary programming constructs (e.g., integers and recursive functions) 
and authorization logic constructs (e.g., principals and access control
policies) in a uniform way.
AURA is based on polymorphic DCC and uses dependent types to
permit assertions that refer directly to AURA values while keeping
computation out of the assertion level to ensure tractability.
The main technical results of this paper include fully mechanically
verified proofs of the decidability and soundness
for AURA's type system, and a prototype typechecker and interpreter.
}
}
</pre>

<a name="VJMZ08"></a><pre>
@inproceedings{<a href="plclub.html#VJMZ08">VJMZ08</a>,
  author = {Jeffrey A. Vaughan and Limin Jia and Karl Mazurak and
                  Steve Zdancewic},
  title = {Evidence-based Audit},
  booktitle = {Proc. of 21st IEEE Computer Security Foundations Symposium (CSF)},
  pages = {177--191},
  year = 2008,
  publisher = {{IEEE} Computer Society Press},
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/VJMZ08.pdf">http://www.cis.upenn.edu/~stevez/papers/VJMZ08.pdf</a>},
  abstract = {
Authorization logics provide a principled and flexible approach to
specifying access control policies.  One of their compelling benefits
is that a proof in the logic is \emph{evidence} that an access-control
decision has been made in accordance with policy.  Using such proofs
for auditing reduces the trusted computing base and enables the ability to
detect flaws in complex authorization policies. Moreover, the proof
structure is itself useful, because proof
normalization can yield information about the relevance of policy
statements. Untrusted, but well-typed, applications that access
resources through an appropriate interface must obey the access
control policy and create proofs useful for audit.

This paper presents AURA, an authorization logic based on a
dependently-typed variant of DCC and proves the metatheoretic
properties of subject-reduction and normalization.  It shows the
utility of proof-based auditing in a number of examples and discusses
several pragmatic issues that must be addressed in this context.
}
}
</pre>

<a name="TZ08tr"></a><pre>
@techreport{<a href="plclub.html#TZ08tr">TZ08tr</a>,
  author = {Stephen Tse and Steve Zdancewic},
  title = {Concise Concrete Syntax},
  institution = {University of Pennsylvania},
  year = 2008,
  number = {MS-CIS-08-11},
  plclub = {yes},
  htr = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ08tr.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ08tr.pdf</a>}
}
</pre>

<a name="JVMZ+08tr"></a><pre>
@techreport{<a href="plclub.html#JVMZ+08tr">JVMZ+08tr</a>,
  author = {Limin Jia and Jeffrey A. Vaughan and Karl Mazurak and Jianzhou Zhao and Luke Zarko and Joseph Schorr and Steve Zdancewic},
  title = {{AURA}:Preliminary Technical Results},
  institution = {University of Pennsylvania},
  year = 2008,
  number = {MS-CIS-08-10},
  plclub = {yes},
  htr = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/JVMZ08tr.pdf">http://www.cis.upenn.edu/~stevez/papers/JVMZ08tr.pdf</a>}
}
</pre>

<a name="VJMZ08tr"></a><pre>
@techreport{<a href="plclub.html#VJMZ08tr">VJMZ08tr</a>,
  author = {Jeffrey C. Vaughan and Limin Jia and Karl Mazurak and Steve Zdancewic},
  title = {Evidence-based Audit, Technical Appendix},
  institution = {University of Pennsylvania},
  year = 2008,
  number = {MS-CIS-08-09},
  plclub = {yes},
  htr = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/VJMZ08tr.pdf">http://www.cis.upenn.edu/~stevez/papers/VJMZ08tr.pdf</a>}
}
</pre>

<a name="DBMZ08"></a><pre>
@inproceedings{<a href="plclub.html#DBMZ08">DBMZ08</a>,
  author = {Joe Devietti and Colin Blundell and Milo M.K. Martin and Steve Zdancewic},
  title = {HardBound: Architectural Support for Spatial Safety of the C Programming Language},
  booktitle = {International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)},
  year = 2008,
  month = mar,
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/DBMZ08.pdf">http://www.cis.upenn.edu/~stevez/papers/DBMZ08.pdf</a>},
  abstract = {
The C programming language is at least as well known for its absence of
spatial memory safety guarantees (i.e., lack of bounds checking) as it is
for its high performance.  C's unchecked pointer arithmetic and
array indexing allow simple programming mistakes to lead to erroneous
executions, silent data corruption, and security vulnerabilities.  Many
prior proposals have tackled enforcing spatial safety in C programs by
checking pointer and array accesses.  However, existing software-only
proposals have significant drawbacks that may prevent wide
adoption, including: unacceptably high runtime overheads, lack of
completeness, incompatible pointer representations, or need for
non-trivial changes to existing C source code and compiler
infrastructure.

Inspired by the promise of these software-only approaches, this paper
proposes a \textit{hardware bounded pointer} architectural primitive
that supports cooperative hardware/software enforcement of spatial
memory safety for C programs.  This bounded pointer is a new hardware
primitive datatype for pointers that leaves the standard C pointer
representation intact, but augments it with bounds information
maintained separately and invisibly by the hardware. The bounds are
initialized by the software, and they are then propagated and enforced
transparently by the hardware, which automatically checks a pointer's
bounds before it is dereferenced.  One mode of use requires
instrumenting only \texttt{malloc}, which enables enforcement of
per-allocation spatial safety for heap-allocated objects for existing
binaries.  When combined with simple intra-procedural compiler
instrumentation, hardware bounded pointers enable a low-overhead
approach for enforcing complete spatial memory safety in unmodified C
programs.
  }
}
</pre>

<a name="MZ07"></a><pre>
@inproceedings{<a href="plclub.html#MZ07">MZ07</a>,
  author = {Karl Mazurak and Steve Zdancewic},
  title = {{ABash}: Finding Bugs in Bash Scripts},
  booktitle = {ACM SIGPLAN Workshop on Programming Languages and Analysis for Security (PLAS)},
  year = 2007,
  month = jun,
  plclub = {yes},
  hconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MZ07.pdf">http://www.cis.upenn.edu/~stevez/papers/MZ07.pdf</a>},
  abstract = {
  This paper describes the design and implementation of ABash, a
  tool for statically analyzing programs written in the \texttt{bash} scripting
  language.  Although it makes no formal guarantees against missed errors
  or spurious warnings (largely due to
  the highly dynamic nature of \texttt{bash} scripts), ABash is useful for
  detecting certain common program errors that may lead to security
  vulnerabilities.  In experiments with 49 \texttt{bash} scripts taken
  from popular Internet repositories,
  ABash was able to identify 20 of them as containing bugs of varying
  severity while yielding only a reasonable number of spurious warnings on
  both these scripts and the generally bug-free initialization scripts of
  the Ubuntu Linux distribution.  ABash works by performing
  \textit{abstract interpretation} of a \texttt{bash} script via an abstract
  semantics that accounts for shell variable expansion.
  The analysis is also parameterized by a collection of
  signatures that describe external program interfaces (for Unix
  commands, etc.), yielding an easily configurable and extensible
  framework for finding bugs in \texttt{bash} scripts.
  }
}
</pre>

<a name="VZ07"></a><pre>
@inproceedings{<a href="plclub.html#VZ07">VZ07</a>,
  author = {Jeffrey A. Vaughan and Steve Zdancewic},
  title = {A Cryptographic Decentralized Label Model},
  booktitle = {{IEEE} 2007 Symposium on Security and Privacy (Oakland)},
  year = 2007,
  pages = {192--206},
  plclub = {yes},
  hsconf = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/VZ07.ps">http://www.cis.upenn.edu/~stevez/papers/VZ07.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/VZ07.pdf">http://www.cis.upenn.edu/~stevez/papers/VZ07.pdf</a>},
  abstract = {
  Information-flow security policies are an appealing way of
  specifying confidentiality and integrity policies in information
  systems. Most previous work on language-based security has assumed
  that programs run in a closed, managed environment and that they use
  potentially unsafe constructs, such as \emph{declassification}, to
  interface to external communication channels, perhaps after
  encrypting data to preserve its confidentiality.  This situation is
  unsatisfactory for systems that need to communicate over untrusted
  channels or use untrusted persistent storage, since the connection
  between the cryptographic mechanisms used in the untrusted
  environment and the abstract security labels used in the trusted
  language environment is ad hoc and unclear.  

  This paper addresses this problem in three ways: First, it presents
  a simple, security-typed language with a novel mechanism called
  \textit{packages} that provides an abstract means for creating
  opaque objects and associating them with security labels; well-typed
  programs in this language enforce noninterference.  Second, it shows
  how to implement these packages using public-key cryptography.  This
  implementation strategy uses a variant of Myers and Liskov's
  \textit{decentralized label model}, which supports a rich label
  structure in which mutually distrusting data owners can specify
  independent confidentiality and integrity requirements.  Third, it
  demonstrates that this implementation of packages is sound with
  respect to Dolev-Yao style attackers---such an attacker cannot
  determine the contents of a package without possessing the
  appropriate keys, as determined by the security label on the
  package. 
}
}
</pre>

<a name="LZ07"></a><pre>
@inproceedings{<a href="plclub.html#LZ07">LZ07</a>,
  author = {Peng Li and Steve Zdancewic},
  title = {Combining Events And Threads For Scalable Network Services},
  booktitle = {Proc. 2007 {ACM} SIGPLAN Conference on Programming Languages Design and Implementation (PLDI)},
  year = 2007,
  pages = {189--199},
  plclub = {yes},
  hsconf = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ07.ps">http://www.cis.upenn.edu/~stevez/papers/LZ07.ps</a>},
  abstract = {
This paper proposes to combine two seemingly opposed programming
models for building massively concurrent network services: the
event-driven model and the multithreaded model.  The result is a
hybrid design that offers the best of both worlds---the ease of use
and expressiveness of threads and the flexibility and performance of
events.

This paper shows how the hybrid model can be implemented entirely at
the application level using {\em concurrency monads} in Haskell,
which provides type-safe abstractions for both events and threads.
This approach simplifies the development of massively concurrent
software in a way that scales to real-world network services.  The
Haskell implementation supports exceptions, symmetrical multiprocessing,
software transactional memory, asynchronous I/O mechanisms and
application-level network protocol stacks.  Experimental results
demonstrate that this monad-based approach has good performance: the
threads are extremely lightweight (scaling to ten million threads),
and the I/O performance compares favorably to that of Linux NPTL.
}
}
</pre>

<a name="ACZ06"></a><pre>
@inproceedings{<a href="plclub.html#ACZ06">ACZ06</a>,
  author = {Rajeev Alur and Pavol {\v C}ern{\'y} and Steve Zdancewic},
  title = {Preserving Secrecy under Refinement},
  booktitle = {Proc. of 33rd International Colloquium on Automata, Languages and Programming (ICALP)},
  year = 2006,
  pages = {107--118},
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ACZ06.pdf">http://www.cis.upenn.edu/~stevez/papers/ACZ06.pdf</a>},
  abstract = {
We propose a general framework of secrecy and 
preservation of secrecy for labeled transition systems. Our
definition of secrecy is parameterized by the distinguishing power of
the observer, the properties to be kept secret, and the executions of
interest, and captures a multitude of definitions in the literature.
We define a notion of secrecy preserving refinement between
systems by strengthening the classical trace-based refinement so that
the implementation leaks a secret only when the specification also
leaks it.  We show that secrecy is in general not definable in
mu-calculus, and thus not expressible in specification logics
supported by standard model-checkers.  However, we develop a
simulation-based proof technique for establishing secrecy preserving
refinement.  This result shows how existing refinement checkers can be
used to show correctness of an implementation with respect to a
specification.
}
}
</pre>

<a name="LZ06a"></a><pre>
@inproceedings{<a href="plclub.html#LZ06a">LZ06a</a>,
  author = {Peng Li and Steve Zdancewic},
  title = {Encoding Information Flow in {Haskell}},
  booktitle = {Proc. of 19th IEEE Computer Security Foundations Workshop (CSFW)},
  year = 2006,
  pages = {16--27},
  publisher = {{IEEE} Computer Society Press},
  plclub = {yes},
  hsconf = {yes},
  nsfo = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf</a>},
  abstract = {
  This paper presents an embedded security sublanguage for enforcing
  information-flow policies in the standard Haskell programming
  language.  The sublanguage provides useful information-flow control
  mechanisms including dynamic security lattices, run-time code
  privileges and declassification, without modifying the base
  language. This design avoids the redundant work of producing new
  languages, lowers the threshold for adopting security-typed
  languages, and also provides great flexibility and modularity for
  using security-policy frameworks.
  
  The embedded security sublanguage is designed using a standard
  combinator interface called arrows.  Computations constructed
  in the sublanguage have static and explicit control-flow components,
  making it possible to implement information-flow control using
  static-analysis techniques at run time, while providing strong
  security guarantees.  This paper presents a concrete Haskell
  implementation and an example application demonstrating the proposed
  techniques.
}
}
</pre>

<a name="SHTZ06"></a><pre>
@inproceedings{<a href="plclub.html#SHTZ06">SHTZ06</a>,
  author = {Nikhil Swamy and Michael Hicks and Stephen Tse and Steve Zdancewic},
  title = {Managing Policy Updates in Security-Typed Languages},
  booktitle = {Proc. of 19th IEEE Computer Security Foundations Workshop (CSFW)},
  year = 2006,
  pages = {202--216},
  publisher = {{IEEE} Computer Society Press},
  plclub = {yes},
  hsconf = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/SHTZ06.pdf">http://www.cis.upenn.edu/~stevez/papers/SHTZ06.pdf</a>},
  abstract = {
This paper presents RX, a new security-typed
programming language with features intended to make the management of
information-flow policies more practical.  Security labels in RX,
in contrast to prior approaches, are defined in terms of \emph{owned
roles}, as found in the RT role-based trust-management framework.
Role-based security policies allow flexible delegation, and our
language RX provides constructs through which programs can robustly
update policies and react to policy updates dynamically.  Our dynamic
semantics use statically verified transactions to eliminate
illegal information flows across updates, which we call 
transitive flows.  Because policy updates can be observed
through dynamic queries, policy updates can potentially reveal
sensitive information.  As such, RX considers policy statements
themselves to be potentially confidential information and subject to
information-flow metapolicies.
}
}
</pre>

<a name="LWZ06"></a><pre>
@article{<a href="plclub.html#LWZ06">LWZ06</a>,
  author = {Jay Ligatti and David Walker and Steve Zdancewic},
  title = {A Type-theoretic Interpretation of Pointcuts and Advice},
  journal = {Science of Computer Programming: Special Issue on Foundations of Aspect-Oriented Programming},
  year = {2006},
  pages = {240--266},
  plclub = {yes},
  hjournal = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/LWZ06.pdf">http://www.cis.upenn.edu/~stevez/papers/LWZ06.pdf</a>},
  abstract = {
This paper defines the semantics of MinAML, an idealized
aspect-oriented programming language, by giving a type-directed
translation from a user-friendly external language to a compact,
well-defined core language. We argue that our framework is an
effective way to give semantics to aspect-oriented programming
languages in general because the translation eliminates shallow
syntactic differences between related constructs and permits
definition of a simple and elegant core language.

The core language extends the simply-typed lambda calculus with two
central new abstractions: explicitly labeled program points and
first-class advice.  The labels serve both to trigger advice and to
mark continuations that the advice may return to.  These constructs
are defined orthogonally to the other features of the language and
we show that our abstractions can be used in both functional and
object-oriented contexts.  We prove Preservation and Progress lemmas
for our core language and show that the translation from MinAML source
into core is type-preserving.  We also consider several extensions to
our basic framework including a general mechanism for analyzing the
current call stack. 
  }
}
</pre>

<a name="MSZ06"></a><pre>
@article{<a href="plclub.html#MSZ06">MSZ06</a>,
  author = {Andrew C. Myers and Andrei Sabelfeld and Steve Zdancewic},
  title = {Enforcing Robust Declassification and Qualified Robustness},
  journal = {Journal of Computer Security},
  year = 2006,
  volume = 14,
  number = 2,
  pages = {157--196},
  plclub = {yes},
  hjournal = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MSZ06.pdf">http://www.cis.upenn.edu/~stevez/papers/MSZ06.pdf</a>},
  abstract = {
  Noninterference requires that there
  is no information flow from sensitive to public data in a given
  system. However, many systems 
  release sensitive information as part of their
  intended function and therefore violate noninterference.
  To control information flow while permitting
  information release, some systems have a downgrading or
  declassification mechanism, but this creates the danger
  that it may cause unintentional information release.
  This paper shows that a robustness property
  can be used to characterize programs in which declassification mechanisms
  cannot be controlled by attackers to release more information than
  intended. It describes a simple way to provably enforce this robustness
  property through a type-based compile-time program analysis. The paper also
  presents a generalization of robustness that
  supports upgrading (endorsing) data integrity.
  }
}
</pre>

<a name="TZ08"></a><pre>
@article{<a href="plclub.html#TZ08">TZ08</a>,
  author = {Stephen Tse and Steve Zdancewic},
  title = {Run-time principals in information-flow type systems},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = 2008,
  volume = 30,
  number = 1,
  pages = 6,
  plclub = {yes},
  hjournal = {yes},
  nsfo = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ08.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ08.pdf</a>},
  abstract = {
  Information-flow type systems are a promising approach for enforcing
  strong end-to-end confidentiality and integrity policies. Such
  policies, however, are usually specified in terms of static
  information---data is labeled  _high_ or _low_ security at
  compile time.  In practice, the confidentiality of data may depend
  on information available only while the system is running.
  
  This paper studies language support for _run-time principals_,
  a mechanism for specifying security policies that depend on which
  principals interact with the system.  We establish the basic
  property of noninterference for programs written in such language,
  and use run-time principals for specifying run-time authority in
  downgrading mechanisms such as declassification.
  
  In addition to allowing more expressive security policies, run-time
  principals enable the integration of language-based security
  mechanisms with other existing approaches such as Java stack
  inspection and public key infrastructures. We sketch an
  implementation of run-time principals via public keys such that
  principal delegation is verified by certificate chains.
  }
}
</pre>

<a name="ABFF05"></a><pre>
@inproceedings{<a href="plclub.html#ABFF05">ABFF05</a>,
  author = {Brian E. Aydemir and
   Aaron Bohannon and
   Matthew Fairbairn and
   J. Nathan Foster and
   Benjamin C. Pierce and
   Peter Sewell and
   Dimitrios Vytiniotis and
   Geoffrey Washburn and
   Stephanie Weirich and
   Steve Zdancewic},
  title = {{Mechanized Metatheory for the Masses: The POPLMark Challenge}},
  booktitle = {International Conference on Theorem Proving in Higher Order Logics (TPHOLs)},
  year = 2005,
  pages = {50--65},
  hsconf = {yes},
  plclub = {yes},
  nsfr = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ABFF05.pdf">http://www.cis.upenn.edu/~stevez/papers/ABFF05.pdf</a>},
  abstract = { How close are we to a world where every paper on
  programming languages is accompanied by an electronic appendix with
  machine-checked proofs?

  We propose an initial set of benchmarks for measuring progress in
  this area.  Based on the metatheory of System F-Sub, a typed
  lambda-calculus with second-order polymorphism, subtyping, and
  records, these benchmarks embody many aspects of programming
  languages that are challenging to formalize: variable binding at
  both the term and type levels, syntactic forms with variable numbers
  of components (including binders), and proofs demanding complex
  induction principles.  We hope that these benchmarks will help
  clarify the current state of the art, provide a basis for comparing
  competing technologies, and motivate further research.  }
}
</pre>

<a name="HTHZ05"></a><pre>
@inproceedings{<a href="plclub.html#HTHZ05">HTHZ05</a>,
  author = {Michael Hicks and Stephen Tse and Boniface Hicks 
                  and Steve Zdancewic},
  title = {Dynamic updating of information-flow policies},
  booktitle = {Proc. of Foundations of Computer Security Workshop (FCS)},
  year = 2005,
  hconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/HTHZ05.pdf">http://www.cis.upenn.edu/~stevez/papers/HTHZ05.pdf</a>},
  abstract = { Applications that manipulate sensitive information
  should ensure \emph{end-to-end} security by satisfying two
  properties: \emph{sound execution} and some form of
  \emph{noninterference}.  By the former, we mean the program should
  always perform actions in keeping with its current policy, and by
  the latter we mean that these actions should never cause
  high-security information to be visible to a low-security observer.
  Over the last decade, security-typed languages have been developed
  that exhibit these properties, increasingly improving so as to model
  important features of real programs.

  No current security-typed language, however, permits general changes
  to security policies in use by running programs.  This paper
  presents a simple information flow type system for that allows for
  dynamic security policy updates while ensuring sound execution and a
  relaxed form of noninterference we term \emph{noninterference
  between updates}.  We see this work as an important step toward
  using language-based techniques to ensure end-to-end security for
  realistic applications.}
}
</pre>

<a name="LZ05c"></a><pre>
@inproceedings{<a href="plclub.html#LZ05c">LZ05c</a>,
  author = {Peng Li and Steve Zdancewic},
  title = {{Unifying Confidentiality and Integrity in Downgrading 
                  Policies}},
  booktitle = {Proc. of Foundations of Computer Security Workshop (FCS)},
  year = 2005,
  hconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ05c.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ05c.pdf</a>},
  abstract = {Confidentiality and integrity are often treated as dual
  properties in formal models of information-flow control, access
  control and many other areas in computer security. However, in
  contrast to confidentiality policies, integrity policies are less
  formally studied in the information-flow control literature. One
  important reason is that traditional noninterference-based
  information-flow control approaches give very weak integrity
  guarantees for untrusted code. Integrity and confidentiality
  policies are also different with respect to implicit information
  channels. 

  This paper studies integrity downgrading policies in
  information-flow control and compares them with their
  confidentiality counterparts. We examine the drawbacks of integrity
  policies based on noninterference formalizations and study the
  integrity policies in the framework of downgrading policies and
  program equivalences. We give semantic interpretations for
  traditional security levels for integrity, namely, tainted and
  untainted, and explain the interesting relations between
  confidentiality and integrity in this framework.  }
}
</pre>

<a name="Zda04"></a><pre>
@inproceedings{<a href="plclub.html#Zda04">Zda04</a>,
  author = {Steve Zdancewic},
  title = {{Challenges for Information-flow Security}},
  booktitle = {Proceedings of the 1st International Workshop on the
  Programming Language Interference and Dependence (PLID'04)},
  year = 2004,
  note = {(5 pages)},
  hinvited = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/Zda04.pdf">http://www.cis.upenn.edu/~stevez/papers/Zda04.pdf</a>}
}
</pre>

<a name="Zda03"></a><pre>
@inproceedings{<a href="plclub.html#Zda03">Zda03</a>,
  author = {Steve Zdancewic},
  title = {{A Type System for Robust Declassification}},
  booktitle = {Proceedings of the Nineteenth Conference on the 
                  Mathematical Foundations of Programming Semantics (MFPS)},
  year = 2003,
  note = {(16 pages)},
  month = mar,
  publisher = {Electronic Notes in Theoretical Computer Science},
  hinvited = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/Zda03.ps">http://www.cis.upenn.edu/~stevez/papers/Zda03.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/Zda03.pdf">http://www.cis.upenn.edu/~stevez/papers/Zda03.pdf</a>},
  abstract = {Language-based approaches to information security have led to the
  development of \emph{security type systems\/} that permit the
  programmer to describe confidentiality policies on data.  Security
  type systems are usually intended to enforce \emph{noninterference},
  a property that requires that high-security information not affect
  low-security computation.  However, in practice, noninterference is
  often too restrictive---the desired policy does permit some
  information leakage.

  
  To compensate for the strictness of noninterference, practical
  approaches include some mechanism for \emph{declassifying}
  high-security information.  But such declassification is potentially
  dangerous, and its use should be restricted to prevent unintended
  information leaks. Zdancewic and Myers previously introduced the
  notion of \emph{robust declassification\/} in an attempt to capture
  the desired restrictions on declassification, but that work did not
  propose a method for determining when a program satisfies the robust
  declassification condition.


  This paper motivates robust declassification and shows that a simple
  change to a security type system can enforce it.  The idea is to
  extend the lattice of security labels to include \emph{integrity}
  constraints as well as confidentiality constraints and then require
  that the decision to perform a declassification have high
  integrity.}
}
</pre>

<a name="ZM02"></a><pre>
@article{<a href="plclub.html#ZM02">ZM02</a>,
  author = {Steve Zdancewic and Andrew C. Myers},
  title = {{Secure Information Flow via Linear Continuations}},
  journal = {Higher Order and Symbolic Computation},
  volume = 15,
  number = {2/3},
  year = 2002,
  pages = {209--234},
  hjournal = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM02.ps">http://www.cis.upenn.edu/~stevez/papers/ZM02.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM02.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM02.pdf</a>},
  abstract = {\emph{Security-typed languages} enforce secrecy or integrity policies by
type-checking.  This paper investigates continuation-passing style (CPS) as a
means of proving that such languages enforce noninterference and as a first
step towards understanding their compilation.  We present a low-level, secure
calculus with higher-order, imperative features and \emph{linear
continuations}.


Linear continuations impose a stack discipline on the control flow of
programs.  This additional structure in the type system lets us establish a
strong information-flow security property called \emph{noninterference}.  We prove
that our CPS target language enjoys the noninterference property and we show
how to translate secure high-level programs to this low-level
language.  This noninterference proof is the first of its kind for a
language with higher-order functions and state.}
}
</pre>

<a name="ZZNM02"></a><pre>
@article{<a href="plclub.html#ZZNM02">ZZNM02</a>,
  author = {Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers},
  title = {{Secure Program Partitioning}},
  journal = {Transactions on Computer Systems},
  year = 2002,
  volume = 20,
  number = 3,
  pages = {283--328},
  hjournal = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM02.ps">http://www.cis.upenn.edu/~stevez/papers/ZZNM02.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM02.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZNM02.pdf</a>},
  abstract = {This paper presents secure program partitioning, a language-based
technique for protecting confidential data during computation in
distributed systems containing mutually untrusted hosts. Confidentiality
and integrity policies can be expressed by annotating programs with
security types that constrain information flow; these programs can then
be partitioned automatically to run securely on heterogeneously trusted
hosts. The resulting communicating subprograms collectively implement
the original program, yet the system as a whole satisfies the security
requirements of participating principals without requiring a universally
trusted host machine.  The experience in applying this methodology and
the performance of the resulting distributed code suggest that this is a
promising way to obtain secure distributed computation.


This article is an expanded version of the published paper ``Untrusted
Hosts and Confidentiality: Secure Program Partitioning''.
The main difference between the two is Appendix A, which
contains a correctness proof for the control-transfer protocols described
in Section 5.}
}
</pre>

<a name="GMZ00"></a><pre>
@article{<a href="plclub.html#GMZ00">GMZ00</a>,
  author = {Dan Grossman and Greg Morrisett and Steve Zdancewic},
  title = {{Syntactic Type Abstraction}},
  journal = {Transactions on Programming Languages and Systems},
  year = 2000,
  volume = 22,
  number = 6,
  pages = {1037--1080},
  month = nov,
  hjournal = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/GMZ00.ps">http://www.cis.upenn.edu/~stevez/papers/GMZ00.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/GMZ00.pdf">http://www.cis.upenn.edu/~stevez/papers/GMZ00.pdf</a>},
  abstract = {Software developers often structure programs in such a
way that different pieces of code constitute distinct
principals. Types help define the protocol by which these principals
interact. In particular, abstract types allow a principal to make
strong assumptions about how well-typed clients use the facilities
that it provides. We show how the notions of principals and type
abstraction can be formalized within a language. Different principals
can know the implementation of different abstract types. We use
additional syntax to track the flow of values with abstract types
during the evaluation of a program and demonstrate how this framework
supports syntactic proofs (in the style of subject reduction) for
type-abstraction properties. Such properties have traditionally
required semantic arguments; using syntax avoids the need to build a
model for the language. We present various typed lambda calculi with
principals, including versions that have mutable state and recursive types.}
}
</pre>

<a name="TZ05a"></a><pre>
@inproceedings{<a href="plclub.html#TZ05a">TZ05a</a>,
  author = {Stephen Tse and Steve Zdancewic},
  title = {{Designing a Security-typed Language with Certificate-based Declassification}},
  booktitle = {Proc. of the 14th European Symposium on Programming (ESOP)},
  year = 2005,
  volume = 3444,
  pages = {279--294},
  hsconf = {yes},
  plclub = {yes},
  nsfo = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ05a.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ05a.pdf</a>},
  abstract = {This paper presents a calculus that supports information-flow
  security policies and certificate-based declassification. The
  decentralized label model and its downgrading mechanisms are
  concisely expressed in the polymorphic lambda calculus with
  subtyping (System F-Sub).  We prove a conditioned version of the
  noninterference theorem such that authorization for declassification
  is justified by digital certificates from public-key
  infrastructures.}
}
</pre>

<a name="LZ05b"></a><pre>
@inproceedings{<a href="plclub.html#LZ05b">LZ05b</a>,
  author = {Peng Li and Steve Zdancewic},
  title = {{Practical Information-flow Control in Web-based Information Systems}},
  booktitle = {Proc. of 18th IEEE Computer Security Foundations Workshop (CSFW)},
  year = 2005,
  pages = {2--15},
  hsconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ05b.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ05b.pdf</a>},
  abstract = {This paper presents a practical application of
  language-based information-flow control, namely, a domain-specific
  web scripting language designed for interfacing with databases.  The
  primary goal is to provide strong enforcement of confidentiality and
  integrity policies: confidential data can be released only in
  permitted ways and trustworthy data must result from expected
  computations or conform to expected patterns.  Such security
  policies are specified in the database layer and statically enforced
  for the rest of the system in an end-to-end fashion.

  In contrast with existing web-scripting languages, which provide
  only ad hoc mechanisms for information security, the scripting
  language described here uses principles based on the well-studied
  techniques in information-flow type systems.  However, because web
  scrips often need to downgrade confidential data and manipulate
  untrusted user input, they require practical and convenient ways of
  downgrading secure data.  To achieve this goal, the language allows
  safe downgrading according to \emph{downgrading policies} specified
  by the programmer.  This novel, pattern-based approach provides a
  practical instance of recent work on \emph{delimited release} and
  \emph{relaxed noninterference} and extends that work by accounting
  for integrity policies.  }
}
</pre>

<a name="LZ05"></a><pre>
@inproceedings{<a href="plclub.html#LZ05">LZ05</a>,
  author = {Peng Li and Steve Zdancewic},
  title = {{Downgrading Policies and Relaxed Noninterference}},
  booktitle = {Proc. 32nd {ACM} Symp. on Principles of Programming
		  Languages (POPL)},
  year = 2005,
  pages = {158--170},
  month = jan,
  hsconf = {yes},
  plclub = {yes},
  nsfo = {no},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ05a.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ05a.pdf</a>},
  abstract = { In traditional information-flow type systems, the
    security policy is often formalized as noninterference properties.
    However, noninterference alone is too strong to express security
    properties useful in practice.  If we allow downgrading in such
    systems, it is challenging to formalize the security policy as an
    extensional property of the system.


    This paper presents a generalized framework of downgrading
  policies.  Such policies can be specified in a simple and tracable
  language and can be statically enforced by mechanisms such as type
  systems.  The security guarantee is then formalized as a concise
  extensional property using program equivalences.  This
  \textit{relaxed noninterference} generalizes traditional pure
  noninterference and precisely characterizes the information released
  due to downgrading.  
}
}
</pre>

<a name="MSZ04"></a><pre>
@inproceedings{<a href="plclub.html#MSZ04">MSZ04</a>,
  author = {Andrew C. Myers and Andrei Sabelfeld and Steve Zdancewic},
  title = {Enforcing Robust Declassification},
  booktitle = {Proc. of 17th IEEE Computer Security Foundations Workshop (CSFW)},
  pages = {172--186},
  year = 2004,
  hsconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MSZ04.pdf">http://www.cis.upenn.edu/~stevez/papers/MSZ04.pdf</a>},
  abstract = {Noninterference requires that there is no information
  flow from sensitive to public data in a given system.  However, many
  systems perform intentional release of sensitive information as part
  of their correct functioning and therefore violate noninterference.
  To control information flow while permitting intentional information
  release, some systems have a downgrading or declassification
  mechanism.  A major danger of such a mechanism is that it may cause
  unintentional information release.  This paper shows that a
  robustness property can be used to characterize programs in which
  declassification mechanisms cannot be exploited by attackers to
  release more information than intended.  It describes a simple way
  to provably enforce this robustness property through a type-based
  compile-time program analysis.  The paper also presents a
  generalization of robustness that supports upgrading (endorsing)
  data integrity.}
}
</pre>

<a name="LZ04a"></a><pre>
@inproceedings{<a href="plclub.html#LZ04a">LZ04a</a>,
  author = {Peng Li and Steve Zdancewic},
  title = {{Advanced Control Flow in Java Card Programming}},
  booktitle = {Proceedings of the 2004 ACM SIGPLAN/SIGBED Conference on Languages, 
                  Compilers, and Tools for Embedded Systems (LCTES)},
  pages = {165--174},
  year = 2004,
  month = jun,
  hsconf = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ04a.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ04a.pdf</a>},
  abstract = {
Java Card technology simplifies the development of smart card
applications by providing a high-level programming language similar to
Java.  However, the master-slave programming model used in current
Java Card platform creates control flow difficulties when writing
complex card programs, making it inconvenient, tedious, and
error-prone to implement Java Card applications. This paper examines
these drawbacks of the master-slave model and proposes a concurrent
thread model for developing future Java Card programs, which is much
closer to conventional Java network programming.  This paper also
presents a code translation algorithm and a corresponding tool that
makes it possible to write card programs in the concurrent thread
model without losing compatibility with the existing Java Card API.
}
}
</pre>

<a name="TZ04a"></a><pre>
@inproceedings{<a href="plclub.html#TZ04a">TZ04a</a>,
  author = {Stephen Tse and Steve Zdancewic},
  title = {{Run-time Principals in Information-flow Type Systems}},
  booktitle = {IEEE 2004 Symposium on Security and Privacy (Oakland)},
  year = 2004,
  pages = {179--193},
  month = may,
  publisher = {{IEEE} Computer Society Press},
  hsconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ04a.ps">http://www.cis.upenn.edu/~stevez/papers/TZ04a.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ04a.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ04a.pdf</a>},
  abstract = {
  Information-flow type systems are a promising approach for enforcing
  strong end-to-end confidentiality and integrity policies. Such
  policies, however, are usually specified in term of static
  information--data is labeled \textit{high} or \textit{low} security at
  compile time.  In practice, the confidentiality of data may depend
  on information available only while the system is running
  

  This paper studies language support for \textit{run-time principals}, a
  mechanism for specifying information-flow security policies that
  depend on which principals interact with the system.  We establish
  the basic property of noninterference for programs written in such
  language, and use run-time principals for specifying run-time
  authority in downgrading mechanisms such as declassification.
  

  In addition to allowing more expressive security policies, run-time
  principals enable the integration of language-based security
  mechanisms with other existing approaches such as Java stack
  inspection and public key infrastructures. We sketch an
  implementation of run-time principals via public keys such that
  principal delegation is verified by certificate chains.
  }
}
</pre>

<a name="LMZ03"></a><pre>
@inproceedings{<a href="plclub.html#LMZ03">LMZ03</a>,
  author = {Peng Li and Yun Mao and Steve Zdancewic},
  title = {{Information Integrity Policies}},
  booktitle = {Proceedings of the Workshop on Formal Aspects in Security \& Trust (FAST)},
  year = 2003,
  month = sep,
  hconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/LMZ03.ps">http://www.cis.upenn.edu/~stevez/papers/LMZ03.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/LMZ03.pdf">http://www.cis.upenn.edu/~stevez/papers/LMZ03.pdf</a>},
  abstract = {Information integrity policies are traditionally enforced by
  access control mechanisms that prevent unauthorized users from
  modifying data.  However, access control does not provide end-to-end
  assurance of integrity.  For that reason, integrity guarantees in
  the form of noninterference assertions have been proposed.  Despite
  the appeals of such information-flow based approaches to integrity,
  that solution is also unsatisfactory because it leads to a weaker
  notion of integrity than needed in practice.
  

  This paper attempts to clarify integrity policies by
  comparing and contrasting access control vs. information flow,
  integrity vs. confidentiality policies, and
  integrity vs. availability policies.  The paper also examines data
  invariants as a way to strengthen integrity.  The result is a better
  classification of information-integrity policies.}
}
</pre>

<a name="WZL03"></a><pre>
@inproceedings{<a href="plclub.html#WZL03">WZL03</a>,
  author = {David Walker and Steve Zdancewic and Jay Ligatti},
  title = {{A Theory of Aspects}},
  booktitle = {Proc. of the 8th ACM SIGPLAN International Conference on
		  Functional Programming (ICFP)},
  year = 2003,
  pages = {127--139},
  address = {Upsala, Sweden},
  month = aug,
  hsconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/WZL03.ps">http://www.cis.upenn.edu/~stevez/papers/WZL03.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/WZL03.pdf">http://www.cis.upenn.edu/~stevez/papers/WZL03.pdf</a>},
  abstract = {This paper define the semantics of MinAML, an idealized
aspect-oriented programming language, by giving 
a type-directed translation from its user-friendly external language
to its compact, well-defined core language.
We argue that our framework is an effective way
to give semantics to aspect-oriented programming languages in
general because the translation eliminates shallow syntactic differences
between related constructs and permits definition of a clean,
easy-to-understand, and easy-to-reason-about core language.


The core language extends the simply-typed lambda
calculus with two central new abstractions: explicitly labeled program
points and first-class advice.  The labels serve both to trigger
advice and to mark continuations that the advice may return to.  These
constructs are defined orthogonally to the other features of the
language and we show that our abstractions can be used in both
functional and object-oriented contexts.  The labels are well-scoped
and the language as a whole is well-typed.  Consequently, programmers
can use lexical scoping in the standard way to prevent aspects from
interfering with local program invariants.
  }
}
</pre>

<a name="SSDK03"></a><pre>
@inproceedings{<a href="plclub.html#SSDK03">SSDK03</a>,
  author = {Usa Sammapun and Raman Sharykin and Margaret Delap and Myong Kim and Steve Zdancewic},
  title = {{Formalizing {Java-MaC}}},
  booktitle = {Proceedings of the Third Runtime Verification Workshop},
  publisher = {Electronic Notes in Theoretical Computer Science},
  year = 2003,
  pages = {171--190},
  month = jul,
  hconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/SSDK03.ps">http://www.cis.upenn.edu/~stevez/papers/SSDK03.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/SSDK03.pdf">http://www.cis.upenn.edu/~stevez/papers/SSDK03.pdf</a>},
  abstract = {The Java-MaC framework is a run-time verification system for Java
  programs that can be used to dynamically test and enforce safety
  policies.  This paper presents a formal model of the Java-MaC safety
  properties in terms of an operational semantics for Middleweight
  Java, a realistic subset of full Java.  This model is intended to be
  used as a framework for studying the correctness of Java-MaC program
  instrumentation, optimizations, and future experimentation with
  run-time monitor expressiveness.  As a preliminary demonstration of this model's
  applicability for these tasks, the paper sketches a correctness result
  for a simple program instrumentation scheme.
  }
}
</pre>

<a name="ZM03"></a><pre>
@inproceedings{<a href="plclub.html#ZM03">ZM03</a>,
  author = {Steve Zdancewic and Andrew C. Myers},
  title = {{Observational Determinism for Concurrent Program Security}},
  booktitle = {Proc. of 16th IEEE Computer Security Foundations Workshop (CSFW)},
  year = 2003,
  pages = {29--45},
  month = jul,
  address = {Asilomar, CA},
  hsconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM03.ps">http://www.cis.upenn.edu/~stevez/papers/ZM03.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM03.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM03.pdf</a>},
  abstract = {Noninterference is a property of sequential programs that is useful
for expressing security policies for data confidentiality and
integrity. However, extending noninterference to concurrent programs has
proved problematic. In this paper we present a relatively expressive
secure concurrent language. This language, based on existing
concurrent calculi, provides first-class channels, higher-order
functions, and an unbounded number of threads.  Well-typed programs
obey a generalization of noninterference that ensures
immunity to internal
timing attacks and to attacks that exploit information about the thread
scheduler. Elimination of these refinement attacks is possible because
the enforced security property extends noninterference with
observational determinism. Although the security property is strong,
it also avoids some of the restrictiveness imposed on 
previous security-typed concurrent languages.
}
}
</pre>

<a name="GGKS03"></a><pre>
@inproceedings{<a href="plclub.html#GGKS03">GGKS03</a>,
  author = {Michael Greenwald and Carl A. Gunter and Bj\"{o}rn Knutsson and
                  Andre Scedrov and Jonathan M. Smith and Steve Zdancewic},
  title = {{Computer Security is Not a Science (but it should be)}},
  booktitle = {Proceedings of the Large-Scale Network Security Workshop},
  year = 2003,
  month = mar,
  hconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/GGKS03.ps">http://www.cis.upenn.edu/~stevez/papers/GGKS03.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/GGKS03.pdf">http://www.cis.upenn.edu/~stevez/papers/GGKS03.pdf</a>}
}
</pre>

<a name="ZCZM03"></a><pre>
@inproceedings{<a href="plclub.html#ZCZM03">ZCZM03</a>,
  author = {Lantian Zheng and Stephen Chong and Steve Zdancewic
                  and Andrew C. Myers},
  title = {{Building Secure Distributed Systems Using Replication and 
                  Partitioning}},
  booktitle = {{IEEE} 2003 Symposium on Security and Privacy (Oakland)},
  year = 2003,
  pages = {236--250},
  publisher = {{IEEE} Computer Society Press},
  hsconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZCZM03.ps">http://www.cis.upenn.edu/~stevez/papers/ZCZM03.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZCZM03.pdf">http://www.cis.upenn.edu/~stevez/papers/ZCZM03.pdf</a>},
  abstract = {A challenging unsolved security problem is how to
specify and enforce system-wide security policies; this problem is
even more acute in distributed systems with mutual distrust. This
paper describes a way to enforce policies for data confidentiality and
integrity in such an environment. Programs annotated with security
specifications are statically checked and then transformed by the
compiler to run securely on a distributed system with untrusted
hosts. The code and data of the computation are partitioned across the
available hosts in accordance with the security specification.  The
key contribution is automatic replication of code and data to increase
assurance of integrity---without harming confidentiality, and without
placing undue trust in any host.  The compiler automatically generates
secure run-time protocols for communication among the replicated code
partitions. Results are given from a prototype implementation applied
to various distributed programs.  }
}
</pre>

<a name="ZZNM01"></a><pre>
@inproceedings{<a href="plclub.html#ZZNM01">ZZNM01</a>,
  year = 2001,
  author = {Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers},
  title = {{Untrusted Hosts and Confidentiality: Secure Program Partitioning}},
  series = {Operating Systems Review},
  booktitle = {Proc. 18th {ACM} Symp. on Operating System Principles (SOSP)},
  address = {Banff, Canada},
  month = oct,
  volume = {35(5)},
  pages = {1--14},
  hsconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM01.ps">http://www.cis.upenn.edu/~stevez/papers/ZZNM01.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM01.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZNM01.pdf</a>},
  abstract = {This paper presents secure program partitioning, a
  language-based technique for protecting confidential data during
  computation in distributed systems containing mutually untrusted
  hosts. Confidentiality and integrity policies can be expressed by
  annotating programs with security types that constrain information
  flow; these programs can then be partitioned automatically to run
  securely on heterogeneously trusted hosts. The resulting
  communicating subprograms collectively implement the original
  program, yet the system as a whole satisfies the security
  requirements of participating principals without requiring a
  universally trusted host machine. The experience in applying this
  methodology and the performance of the resulting distributed code
  suggest that this is a promising way to obtain secure distributed
  computation. }
}
</pre>

<a name="ZM01b"></a><pre>
@inproceedings{<a href="plclub.html#ZM01b">ZM01b</a>,
  author = {Steve Zdancewic and Andrew C. Myers},
  title = {{Robust Declassification}},
  booktitle = {Proc. of 14th IEEE Computer Security Foundations Workshop (CSFW)},
  month = jun,
  year = 2001,
  address = {Cape Breton, Canada},
  pages = {15--23},
  hsconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM01b.ps">http://www.cis.upenn.edu/~stevez/papers/ZM01b.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM01b.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM01b.pdf</a>},
  abstract = { Security properties based on information flow, such as
  noninterference, provide strong guarantees that confidentiality is
  maintained. However, programs often need to leak some amount of
  confidential information in order to serve their intended purpose,
  and thus violate noninterference. Real systems that control
  information flow often include mechanisms for downgrading or
  declassifying information; however, declassification can easily
  result in the unexpected release of confidential information.


This paper introduces a formal model of information flow in systems
that include intentional information leaks and shows how to
characterize what information leaks. Further, we define a notion of
robustness for systems that include information leaks introduced by
declassification. Robust systems have the property that an attacker is
unable to exploit declassification channels to obtain more
confidential information than was intended to be released. We show
that all systems satisfying a noninterference-like property are
robust; for other systems, robustness involves a nontrivial
interaction between confidentiality and integrity properties. We
expect this model to provide new tools for the characterization of
information flow properties in the presence of intentional information
leaks. }
}
</pre>

<a name="ZM01"></a><pre>
@inproceedings{<a href="plclub.html#ZM01">ZM01</a>,
  author = {Steve Zdancewic and Andrew C. Myers},
  title = {{Secure Information Flow and {CPS}}},
  booktitle = {Proc. of the 10th European Symposium on Programming (ESOP)},
  year = 2001,
  volume = 2028,
  month = apr,
  series = {Lecture Notes in Computer Science},
  pages = {46--61},
  hsconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM01.ps">http://www.cis.upenn.edu/~stevez/papers/ZM01.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM01.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM01.pdf</a>},
  abstract = {Security-typed languages enforce secrecy or integrity
  policies by type-checking. This paper investigates
  continuation-passing style as a means of proving that such languages
  enforce non-interference and as a first step towards understanding
  their compilation. We present a low-level, secure calculus with
  higher-order, imperative features. Our type system makes novel use
  of ordered linear continuations.}
}
</pre>

<a name="ZGM99"></a><pre>
@inproceedings{<a href="plclub.html#ZGM99">ZGM99</a>,
  author = {Steve Zdancewic and Dan Grossman and Greg Morrisett},
  title = {{Principals in Programming Languages: A Syntactic Proof Technique}},
  booktitle = {Proc. of the 4th ACM SIGPLAN International Conference on
		  Functional Programming (ICFP)},
  year = 1999,
  pages = {197--207},
  address = {Paris, France},
  month = sep,
  hsconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZGM99.ps">http://www.cis.upenn.edu/~stevez/papers/ZGM99.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZGM99.pdf">http://www.cis.upenn.edu/~stevez/papers/ZGM99.pdf</a>},
  abstract = {Programs are often structured around the idea that
  different pieces of code comprise distinct principals, each with a
  view of its environment. Typical examples include the modules of a
  large program, a host and its clients, or a collection of
  interactive agents.


In this paper, we formalize this notion of principal in the
programming language itself. The result is a language in which
intuitive statements such as, ``the client must call open to obtain a
file handle'', can be phrased and proven formally.


We add principals to variants of the simply-typed lambda-calculus and
show how we can track the code corresponding to each principal
throughout evaluation. This multiagent calculus yields syntactic
proofs of some type abstraction properties that traditionally require
semantic arguments.}
}
</pre>

<a name="MCGG99"></a><pre>
@inproceedings{<a href="plclub.html#MCGG99">MCGG99</a>,
  author = {Greg Morrisett and Karl Crary and Neal Glew and Dan
		  Grossman and Richard Samuels and Frederick Smith and David
		  Walker and Stephanie Weirich and Steve Zdancewic},
  title = {{{TALx86}: A Realistic Typed Assembly Language}},
  booktitle = {2nd {ACM SIGPLAN} Workshop on Compiler Support for
		  System Software},
  year = 1999,
  pages = {25--35},
  hconf = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/MCGG99.ps">http://www.cis.upenn.edu/~stevez/papers/MCGG99.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/MCGG99.pdf">http://www.cis.upenn.edu/~stevez/papers/MCGG99.pdf</a>},
  abstract = {The goal of typed assembly language (TAL) is to provide
  a low-level, statically typed target language that is better suited
  than Java bytecodes for supporting a wide variety of source
  languages and a number of important optimizations. In previous work,
  we formalized idealized versions of TAL and proved important safety
  properties about them. In this paper, we present our progress in
  defining and implementing a realistic typed assembly language called
  TALx86. The TALx86 instructions comprise a relatively complete
  fragment of the Intel IA32 (32-bit 80x86 flat model) assembly
  language and are thus executable on processors such as the Intel
  Pentium. The type system for the language incorporates a number of
  advanced features necessary for safely compiling large programs to
  good code.


To motivate the design of the type system, we demonstrate how various
high-level language features are compiled to TALx86. For this purpose,
we present a type-safe C-like language called Popcorn.}
}
</pre>

<a name="TZ05atr"></a><pre>
@techreport{<a href="plclub.html#TZ05atr">TZ05atr</a>,
  author = {Stephen Tse and Steve Zdancewic},
  title = {{Designing a Security-typed Language with Certificate-based Declassification}},
  institution = {University of Pennsylvania},
  number = {MIS-CIS-04-16},
  year = 2004,
  htr = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ05atr.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ05atr.pdf</a>},
  abstract = {This paper presents the design of a programming language that
  supports information-flow security policies and certificate-based
  declassification.

  
  The language uses monadic information-flow annotations in the style
  of Abadi et al.'s dependency core calculus, and has an effects
  system and fixpoints. The type system conflates security concepts
  such as labels, principals, and privileges with abstract types,
  allowing a uniform treatment of lattice structures throughout the
  language.  Myers' and Liskov's decentralized label model is encoded
  using type constructors that describe confidentiality and integrity
  policies, and label refinements and principal groups follow
  naturally from intersection and union types.  Singleton types,
  combined with bounded universal and existential quantifications,
  connect the type system with public-key infrastructures whose
  digital certificates provide authorization for privileged operations
  such as declassification.  These features allow specification of
  security policies in term of dynamic entities such as run-time user
  identities and file access permissions.

  
  Besides showing that the language is sound, we present a security
  theorem that generalizes standard noninterference to account for
  information flows introduced by declassification.  Although this
  result gives only a coarse approximation to the information
  potentially leaked, it captures our intuitions about
  certificate-based declassification.
  }
}
</pre>

<a name="TZ04c"></a><pre>
@techreport{<a href="plclub.html#TZ04c">TZ04c</a>,
  author = {Stephen Tse and Steve Zdancewic},
  title = {{Translating Dependency into Parametricity}},
  institution = {University of Pennsylvania},
  year = 2004,
  number = {MIS-CIS-04-01},
  htr = {yes},
  plclub = {yes},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ04btr.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ04btr.pdf</a>},
  abstract = {
  The \textit{dependency core calculus} (DCC) was introduced by Abadi
  et al. as a unifying formal framework in which to study a variety of
  important program analyses including binding-time, information-flow,
  slicing, and function call tracking. The novel feature of DCC is a
  lattice of monads and a nonstandard typing rule for their associated
  \texttt{bind} operations.  Intuitively, the lattice structure describes
  which computations in a program may depend on each other.  Abadi et
  al.  prove a \textit{noninterference} result that establishes the
  correctness of DCC's type system, and they use that result to show
  that type systems for the above-mentioned analyses are correct.
  
  In this paper, we study the relationship between DCC and the
  Girard--Reynolds polymorphic lambda calculus (System F).  In
  particular, we show how to encode the recursion-free fragment of DCC
  into F via a type-directed translation.  The main theorem we present
  uses this translation to derive the noninterference result for DCC
  from the standard parametricity theorem of System F.  In addition to
  providing insight into DCC's type system, the hope is that the
  translation presented here may yield implementation strategies for
  non-standard type systems (e.g. for information flow security) in
  languages that have parametric polymorphism.
  }
}
</pre>

<a name="TZ03"></a><pre>
@techreport{<a href="plclub.html#TZ03">TZ03</a>,
  author = {Stephen Tse and Steve Zdancewic},
  title = {{Run-time Principals in Information-flow Type Systems}},
  institution = {University of Pennsylvania},
  year = 2003,
  number = {MS-CIS-03-39},
  note = {The conference version appears in {IEEE} Security and Privacy 2004},
  htr = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ03.ps">http://www.cis.upenn.edu/~stevez/papers/TZ03.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ03.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ03.pdf</a>},
  abstract = {
  Information-flow type systems are a promising approach for enforcing
  strong end-to-end confidentiality and integrity policies. Such
  policies, however, are usually specified in term of static
  information--data is labeled \textit{high} or \textit{low} security at
  compile time.  In practice, the confidentiality of data may depend
  on information available only while the system is running

  
  This paper studies language support for \textit{run-time principals}, a
  mechanism for specifying information-flow security policies that
  depend on which principals interact with the system.  We establish
  the basic property of noninterference for programs written in such
  language, and use run-time principals for specifying run-time
  authority in downgrading mechanisms such as declassification.

  
  In addition to allowing more expressive security policies, run-time
  principals enable the integration of language-based security
  mechanisms with other existing approaches such as Java stack
  inspection and public key infrastructures. We sketch an
  implementation of run-time principals via public keys such that
  principal delegation is verified by certificate chains.
  }
}
</pre>

<a name="ZZNM01b"></a><pre>
@techreport{<a href="plclub.html#ZZNM01b">ZZNM01b</a>,
  year = 2001,
  title = {{Secure Program Partitioning}},
  author = {Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers},
  institution = {Computer Science Dept., Cornell University},
  number = {2001-1846},
  htr = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.ps">http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.pdf</a>},
  abstract = {This paper presents secure program partitioning, a
  language-based technique for protecting confidential data during
  computation in distributed systems containing mutually untrusted
  hosts. Confidentiality and integrity policies can be expressed by
  annotating programs with security types that constrain information
  flow; these programs can then be partitioned automatically to run
  securely on heterogeneously trusted hosts. The resulting
  communicating subprograms collectively implement the original
  program, yet the system as a whole satisfies the security
  requirements of participating principals without requiring a
  universally trusted host machine. The experience in applying this
  methodology and the performance of the resulting distributed code
  suggest that this is a promising way to obtain secure distributed
  computation.


This Technical Report is an expanded version of the published paper
``Untrusted Hosts and Confidentiality: Secure Program Partitioning''.
The main difference between the two is Appendix A, which contains a
correctness proof for the control-transfer protocols described in
Section 5.}
}
</pre>

<a name="ZM00"></a><pre>
@techreport{<a href="plclub.html#ZM00">ZM00</a>,
  author = {Steve Zdancewic and Andrew C. Myers},
  title = {{Confidentiality and Integrity with Untrusted Hosts}},
  institution = {Computer Science Dept., Cornell University},
  year = 2000,
  number = {2000-1810},
  htr = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM00.ps">http://www.cis.upenn.edu/~stevez/papers/ZM00.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM00.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM00.pdf</a>},
  abstract = {Several \emph{security-typed languages} have recently been proposed to enforce
security properties such as confidentiality or integrity by type checking.
We propose a new security-typed language, Spl@, that
addresses two important limitations of previous approaches.


First, existing languages assume that the underlying execution platform
is trusted; this assumption does not scale to distributed computation in
which a variety of differently trusted hosts are available to execute
programs. Our new approach, \emph{secure program partitioning}, translates
programs written assuming complete trust in a single executing host into
programs that execute using a collection of variously trusted hosts to
perform computation.  As the trust configuration of a distributed system
evolves, this translation can be performed as necessary for security.


Second, many common program transformations do not work in existing
security-typed languages; although they produce equivalent
programs, these programs are rejected because of \emph{apparent} information
flows. Spl@ uses a novel mechanism
based on \emph{ordered linear continuations} to permit a richer class of program
transformations, including secure program partitioning.}
}
</pre>

<a name="ZG99"></a><pre>
@techreport{<a href="plclub.html#ZG99">ZG99</a>,
  author = {Steve Zdancewic and Dan Grossman},
  title = {{Principals in Programming Languages: Technical Results}},
  institution = {Computer Science Dept., Cornell University},
  year = 1999,
  number = {TR99-1752},
  month = jun,
  htr = {yes},
  plclub = {yes},
  ps = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZG99.ps">http://www.cis.upenn.edu/~stevez/papers/ZG99.ps</a>},
  pdf = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZG99.pdf">http://www.cis.upenn.edu/~stevez/papers/ZG99.pdf</a>},
  abstract = {This is the companion technical report for ``Principals
  in Programming Languages: A Syntactic Proof Technique.'' See that
  document for a more readable version of these results.


In this paper, we describe two variants of the simply typed
lambda-calculus extended with a notion of principal. The results are
languages in which intuitive statements like ``the client must call
open to obtain a file handle'' can be phrased and proven formally.


The first language is a two-agent calculus with references and
recursive types, while the second language explores the possibility of
multiple agents with varying amounts of type information. We use these
calculi to give syntactic proofs of some type abstraction results that
traditionally require semantic arguments. }
}
</pre>

<a name="bastani2018active"></a><pre>
@inproceedings{<a href="plclub.html#bastani2018active">bastani2018active</a>,
  title = {Active learning of points-to specifications},
  author = {Bastani, Osbert and Sharma, Rahul and Aiken, Alex and Liang, Percy},
  booktitle = {PLDI},
  year = {2018},
  plclub = {yes}
}
</pre>

<a name="feng2018program"></a><pre>
@inproceedings{<a href="plclub.html#feng2018program">feng2018program</a>,
  title = {Program synthesis using conflict-driven learning},
  authors = {Feng, Yu and Martins, Ruben and Bastani, Osbert and Dillig, Isil},
  booktitle = {PLDI},
  year = {2018},
  plclub = {yes}
}
</pre>

<a name="bastani2017synthesizing"></a><pre>
@inproceedings{<a href="plclub.html#bastani2017synthesizing">bastani2017synthesizing</a>,
  title = {Synthesizing program input grammars},
  author = {Bastani, Osbert and Sharma, Rahul and Aiken, Alex and Liang, Percy},
  booktitle = {PLDI},
  year = {2017},
  plclub = {yes}
}
</pre>

<a name="feng2017automated"></a><pre>
@inproceedings{<a href="plclub.html#feng2017automated">feng2017automated</a>,
  title = {Automated synthesis of semantic malware signatures using maximum satisfiability},
  author = {Feng, Yu and Bastani, Osbert and Martins, Ruben and Dillig, Isil and Anand, Saswat},
  booktitle = {NDSS},
  year = {2017},
  plclub = {yes}
}
</pre>

<a name="clapp2016minimizing"></a><pre>
@inproceedings{<a href="plclub.html#clapp2016minimizing">clapp2016minimizing</a>,
  title = {Minimizing GUI event traces},
  author = {Clapp, Lazaro and Bastani, Osbert and Anand, Saswat and Aiken, Alex},
  booktitle = {FSE},
  year = {2016},
  plclub = {yes}
}
</pre>

<a name="bastani2015interactive"></a><pre>
@inproceedings{<a href="plclub.html#bastani2015interactive">bastani2015interactive</a>,
  title = {An interactive approach to mobile app verification},
  author = {Bastani, Osbert and Anand, Saswat and Aiken, Alex},
  booktitle = {MobileDeLi},
  year = {2015},
  plclub = {yes}
}
</pre>

<a name="bastani2015interactively"></a><pre>
@inproceedings{<a href="plclub.html#bastani2015interactively">bastani2015interactively</a>,
  title = {Interactively verifying absence of explicit information flows in Android apps},
  author = {Bastani, Osbert and Anand, Saswat and Aiken, Alex},
  booktitle = {OOPSLA},
  year = {2015},
  plclub = {yes}
}
</pre>

<a name="bastani2015specification"></a><pre>
@inproceedings{<a href="plclub.html#bastani2015specification">bastani2015specification</a>,
  title = {Specification inference using context-free language reachability},
  author = {Bastani, Osbert and Anand, Saswat and Aiken, Alex},
  booktitle = {POPL},
  year = {2015},
  plclub = {yes}
}
</pre>

